## 08. 좋은 리액트 코드 작성을 위한 환경 구축하기

### ESLint를 활용한 정적 코드 분석

`정적 코드 분석`이란 코드의 실행과 별개로 코드 그 자체만으로 코드 스멜(잠재적으로 버그를 야기할 수 있는 코드)을 찾아내어 문제의 소지가 있는 코드를 사전에 수정하는 것을 의미한다. 자바스크립트에서 생태계에서 가장 많이 사용되는 정적 코드 분석 도구는 바로 `ESLint`이다.

### ESLint 살펴보기

ESLint는 자바스크립트 코드를 정적 분석해 잠재적인 문제를 발견하고 나아가 수정까지 도와주는 도구이다. 그렇다면 ESLint는 어떻게 자바스크립트 코드를 읽어서 분석하는 것일까? 간단하게 요약하면 다음과 같다.

1. 자바스크립트 코드를 문자열로 읽는다.
2. 자바스크립트 코드를 분석할 수 있는 파서(parser)로 코드를 구조화한다.
3. 2번에서 구조화한 트리를 AST(Abstract Syntax Tree)라 하며, 이 구조화된 트리를 기준으로 각종 규칙과 대조한다.
4. 규칙과 대조했을 때 이를 위반하는 코드를 알리거나(report) 수정한다(fix).

여기서 주목해야 할 것은 1번 과정애서 읽은 코드를 구조화하는 과정인 2번이다. 자바스크립트를 분석하는 파서에는 여러가지가 있는데, ESLint는 기본값으로 `espree`를 사용한다.

```javascript
function hello(str) {}
```

이 코드를 espree로 분석하면 다음과 같이 JSON 형태로 구조화된 결과를 얻을 수 있다.

```json
{
  "type": "Program",
  "start": 0,
  "end": 22,
  "range": [0, 22],
  "body": [
    {
      "type": "FunctionDeclaration",
      "start": 0,
      "end": 22,
      "range": [0, 22],
      "id": {
        "type": "Identifier",
        "start": 9,
        "end": 14,
        "range": [9, 14],
        "name": "hello"
      },
      "expression": false,
      "generator": false,
      "async": false,
      "params": [
        {
          "type": "Identifier",
          "start": 15,
          "end": 18,
          "range": [15, 18],
          "name": "str"
        }
      ],
      "body": {
        "type": "BlockStatement",
        "start": 20,
        "end": 22,
        "range": [20, 22],
        "body": []
      }
    }
  ],
  "sourceType": "module"
}
```

espree나 다른 파서로 자바스크립트/타입스크립트 코드를 분석해 보고 싶다면 AST explorer를 방문해보자. 앞의 코드는 AST explorer에서 파서를 espree로 설정하고 분석한 결과이다.

espree 같은 분석 도구는 단순히 변수인지, 함수인지, 함수명은 무엇인지 등을 파악하는 것이 아니라 코드의 정확한 위치와 같은 아주 세세한 정보도 분석해 알려준다. 이러한 자세한 정보가 있어야만 ESLint나 Prettier 같은 도구가 줄바꿈, 들여쓰기 등을 파악할 수 있게 된다.

타입스크립트의 경우도 마찬가지로 @typescript-eslint/typescript-estree라고 하는 espree 기반 파서가 있으며, 이를 통해 타입스크립트 코드를 분석해 구조화한다.

![espree 파서](../asset/espree_parser.png)

ESLint가 espree로 코드를 분석한 결과를 바탕으로, 어떤 코드가 잘못된 코드이며 어떻게 수정해야 할지도 정해야 한다. 이를 ESLint 규칙(rules)이라고 하며, 특정한 규칙의 모음을 plugins라고 한다.

예를 들어, 코드에서 debugger 사용을 금지하고 싶다고 가정해보자. debugger는 코드 개발 과정에서만 사용해야 하는 구문으로, 프로덕션 애플리케이션에서는 절대 존재해서는 안되는 구문이다. 이 구문을 ESLint를 이용해 사용을 금지하는 규칙을 만든다고 가정해보자. 먼저 debugger가 espree로 분석하면 어떻게 변환되는지 알아야 한다. debugger를 espree로 분석하면 다음과 같은 결과를 확인할 수 있다.

```javascript
debugger;
```

```json
{
  "type": "Program",
  "start": 0,
  "end": 8,
  "range": [0, 8],
  "body": [
    {
      "type": "DebuggerStatement",
      "start": 0,
      "end": 8,
      "range": [0, 8]
    }
  ],
  "sourceType": "module"
}
```

body의 type이 DebuggerStatement를 반환하는 것을 확인할 수 있다. 그리고 이 debugger 사용을 제한하는 규칙인 no-debugger를 확인해보자.

```javascript
module.exports = {
  meta: {
    type: 'problem',

    docs: {
      description: 'Disallow the use of `debugger`',
      recommended: true,
      url: 'https://eslint.org/docs/latest/rules/no-debugger',
    },

    fixable: null,
    schema: [],

    messages: {
      unexpected: "Unexpected 'debugger' statement.",
    },
  },

  create(context) {
    return {
      DebuggerStatement(node) {
        context.report({
          node,
          messageId: 'unexpected',
        });
      },
    };
  },
};
```

먼저 meta라는 이름에서 알 수 있듯 해당 규칙과 관련된 메타 정보를 나타낸다. 규칙을 어겼을 때 반환하는 경고 문구인 messages, 문서화에 필요한 정보인 docs, eslint --fix로 수정했을 때 수정가능한지 여부를 나타내는 fixable 등을 확인할 수 있다.

그리고 create가 실제로 코드에서 문제점을 확인하는 곳이다. create에 있는 함수는 espree로 만들어진 AST 트리를 실제로 순회해, 여기서 선언한 특정 조건을 만족하는 코드를 찾고, 이러한 작업을 코드 전체에서 반복한다. 즉, 여기서 DebuggerStatement를 만나면 해당 노드를 리포해 debugger를 사용했다는 것을 알려준다.

### eslint-plugin과 eslint-config

**eslint-plugin**

`eslint-plugin`이라는 접두사를 시작하는 플러그인은 앞서 언급했던 `규칙을 모아놓은 패키지`이다. 예를 들어 `eslint-plugin-import`라는 패키지는 자바스크립트에서 다른 모듈을 불러오는 import와 관련된 다양한 규칙을 제공한다. 또 한 가지 눈여겨봐야 할 패키지는 `eslint-plugin-react`이다. 만약 코드를 작성하다가 JSX 배열에 키를 선언하지 않았다는 경고 메세지를 본 적이 있다면 바로 이 `eslint-plugin-react`가 제공하는 규칙 중 하나인 react/jsx-key가 경고 메세지를 보여준 것이다. 만약 이러한 규칙이 없다면 브라우저의 콘솔에서 경고해 주는 내용을 확인해야만 수정이 가능하다. 비록 ESLint는 말 그대로 코드 정적 분석 도구라서 key가 유니크한 값인지까지는 확인해 줄 수 없지만 존재 여부만 확인해도 큰 도움을 받을 수 있다. JSX 배열에서 key가 누락된 경우에 경고를 보여주기 위해 이 규칙을 export하는 create 함수를 살펴보면 개발자 입장에서는 별거 아닌 것 같아 보이는 규칙을 위해 엄청나게 복잡한 코드가 숨겨져 있다는 것을 알 수 있다.

**eslint-config**

eslint-plugin이 리액트, import와 같이 특정 프레임워크나 도메인과 관련된 규칙을 묶어서 제공하는 패키지라면 `eslint-config`는 이러한 `eslint-plugin`을 한데 묶어서 완벽하게 한 세트로 제공하는 패키지라 할 수 있다.

예를 들어, 어떤 조직에 여러 자바스크립트 저장소가 있고, 이 저장소는 모두 리액트 기반의 비슷한 개발 환경으로 구성되어 있으며, 이 개발 환경에 맞는 ESLint 규칙과 정의를 일괄적으로 적용하고 싶다고 가정해보자. 물론 eslint-plugin도 규칙을 묶어서 제공하지만 여기에 필요한 eslint-plugin 또한 여러 가지가 있을 수 있다. 이처럼 여러 프로젝트에 걸쳐 동일하게 사용할 수 있는 ESLint 관련 설정을 제공하는 패키지가 바로 `eslint-config`이다.

참고로 eslint-plugin과 eslint-config으 네이밍 관련된 규칙이 한 가지 있는데, eslint-plugin, eslint-config라는 접두사를 준수해야 하며, 반드시 한 단어로 구성해야 한다. 예를 들어, eslint-plugin-naver는 가능하지만 eslint-plugin-naver-financials는 불가능하다. 특정 스코프가 앞에 붙는 것까지는 가능하다. 예를 들어, @titicaca/eslint-config-triple은 가능하지만 마찬가지로 @titicaca/eslint-config-triple-rules는 불가능하다.

**eslint-config-airbnb**

`eslint-config-airbnb`는 지금까지도 리액트 기반 프로젝트에서 eslint-config를 선택한다고 가정했을 때 가장 먼저 손에 꼽는 eslint-config이다. 프로젝트 소개의 맨 첫 줄애서 자랑하는 것처럼 자바스크립트 프로젝트에 적용할 ESLint 중에서는 가장 합리적인 선택이 될 수 있다. 이름에서 알 수 있듯 에어비앤비(Airbnb)애서 만들어졌으며, 에어비앤비 개발자뿐만 아니라 500여 명의 수많은 개발자가 유지보수하고 있는 단연 가장 유명한 eslint-config이며, 다른 유명한 config인 eslint-config-google이나 eslint-config-naver 대비 압도적인 다운로드 수를 자랑한다.

**@titicaca/eslint-config-kit**
`@titicaca/eslint-config-kit`는 한국 커뮤니티에서 운영되는 eslint-config 중 유지보수가 활발한 편에 속하며, 많이 쓰는 eslint-config 중 하나이다. 스타트업 개발사인 트리플(현 인터파크트리플)에서 개발하고 있으며, 현재도 꾸준히 업데이트되고 있다. 이 eslint-config는 다른 패키지와 몇 가지 특징이 있다. 대부분의 eslint-config가 앞서 언급한 eslint-config-airbnb를 기반으로 약간의 룰을 수정해 배포되고 있는 것과 다르게 해당 패키지는 자체적으로 정의한 규칙을 기반으로 운영되고 있다. eslint-config-airbnb를 기반으로 하지 않았음에도 대부분의 유용하고 자바스크립트 개발자 사이에서 널리 알려진 규칙은 모두 제공하기 떄문에 사용하는 데 큰 지정이 없다.

또 한 가지 눈여겨볼 만한 것은 외부로 제공하는 규칙에 대한 테스트 코드가 존재한다는 것이다. 이는 eslint-config를 사용하는 개발자가 규칙을 수정하거나 추가할 때, 기대하는 바대로 eslint-config-triple에서 규칙이 추가됐는지 확인할 수 있다. 그리고 CI/CD 환경, 카나리 베포 등 일반적인 npm 라이브러리 구축 및 관리를 위한 시스템이 잘 구축되어 있다. 그리고 별도의 frontend 규칙도 제공하고 있어 Node.js 환경 또는 리액트 환경에 맞는 규칙을 적용할 수 있다는 장점도 있다.

@titicaca/triple-config-kit는 ESLint뿐만 아니라 Prettier와 Stylelint를 각각 별도의 툴인 @titicaca/prettier-config-triple, @titicaca/stylelint-config-triple로 모노래포를 만들어 관리하고 있어 Prettier나 Stylelint도 필요에 따라 설치해서 사용할 수 있다.

**eslint-config-next**

`eslint-config-next`는 리액트 기반 Next.js 프레임워크를 사용하고 있는 프로젝트에서 사용할 수 있는 eslint-config이다. 이 `eslint-config-next`애서 눈여겨볼 점은 단순히 자바스크립트 코드를 정적으로 분석할 뿐만 아니라 페이지나 컴포넌트에서 반환하는 JSX 구문 및 \_app, \_document에서 작성되어 있는 HTML 코드 또한 정적 분석 대상으로 분류해 제공한다는 점이다. 이는 단순히 자바스크립트 코드에 대한 향상뿐만 아니라 전체적인 Next.js 기반 웹 서비스의 성능 향상에 도움이 될 수 있다는 점에서 매우 유용하다. 여기에는 또한 핵심 웹 지표(core web vitals)라고 하는 웹 서비스 성능에 영향을 미칠 수 있는 요소들을 분석해 제공하는 기능도 포함되어 있다. 따라서 Next.js로 작성된 코드라면 반드시 설치하는 것이 좋을 것이다.

### 나만의 ESLint 규칙 만들기

자바스크립트 코드를 작성하다 보면 eslint-config나 eslint-plugin에서 제공하고 있지 않지만 같은 코드를 수정하는 조직 내부에서 필요로 하는 규칙 또는 코드의 변화로 인해 일관적으로 고쳐야 하는 코드가 있을 수도 있다. 이런 경우에 사용할 수 있는 방법이 바로 나만의 ESLint 규칙을 생성하는 것이다. ESLint 규칙을 생성해 관리하면 개발자가 일일이 수정하는 것보다 훨씬 더 빠르고 쉽게 수정할 수 있고, 이후에 반복되는 실수 또한 방지할 수 있어 매우 유용하다.

**이미 존재하는 규칙을 커스터마이징해서 적용하기**

리액트 17버전부터는 새로운 JSX 런타임 덕분에 import React 구문이 필요 없어졌다. 이에 따라 import React를 삭제하게 되면 아주 약간아니마 번들러의 크기를 줄일 수 있게된다.

먼저 import React 구문이 있는 코드를 npm run start로 실행한 뒤 제공되는 bundle.js로 확인해보면, 모든 파일에 `/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(/*! react */ "./node_modules/react/index.js");`가 존재하는 것을 볼 수 있다. 그리고 이렇게 웹팩에서 선언한 `react_WEBPACK_IMPORTED_MODULE_0__` 변수는 선언만 됐을 뿐 어디에서도 쓰이지 않는다. 이렇게 쓰이지 않는 변수가 import React를 사용한 횟수만큼 추가되어 있을 것이다. 그리고 import React가 없는 코드에서는 해당 변수가 존재하지 않고, 그 덕분에 파일의 크기도 조금이나마 차이가 있음을 알 수 있다. 이처럼 리액트 17 버전을 사용하고 있다면 import React 구문을 모두 확인한 후에 제거하는 것이 좋다.

그너란 두 코드가 import React 외에 모두 동일한 코드라는 가정하에 npm run build로 빌드된 자바스크립트 파일을 비교하면 정확히 똑같은 크기가 되는 것을 확인할 수 있다. 이는 웹팩에서 제공하는 트리쉐이킹 기능이 사용하지 않는 코드를 모두 삭제하기 때문이다. 결과적으로 두 코드의 크기가 완전히 동일하다 하더라도 import React를 제거하는 것이 여전히 유용하다. 왜나하면 웹팩이 트리쉐이킹을 하는 데 걸리는 시간을 그만큼 줄일 수 있기 때문이다. 트리쉐이킹에 소요되는 시간이 없어진다면 자연스럽게 빌드 속도 또한 빨라질 것이다.

이렇게 사용되는 import React에 대해 리포트할 수 있는 ESLint 규칙을 만들어보자. 여기서 사용할 규칙은 `no-restricted-imports`이다. 이 규칙은 어떠한 모듈을 import 하는 것을 금지하기 위해 만들어진 규칙이다. 이 규칙은 추가적으로 인수를 제공하면 import할 수 있는 모듈을 제한할 수 있는데, 이를 활용하면 import React를 금지할 수 있다.

```json
// eslint.json
{
  "rules": {
    "no-restricted-imports": [
      "error",
      {
        // paths에 금지시킬 모듈을 추가한다.
        "paths": [
          {
            // 모듈명
            "name": "react",
            // 모듈의 이름
            "importNames": ["default"],
            // 경고 메세지
            "message": "import React from 'react'는 react 17부터 더 이상 필요하지 않습니다. 필요한 것만 react로부터 import해서 사용해 주새요."
          }
        ]
      }
    ]
  }
}
```

우리가 금지시킬 모듈은 react인데, 그중에서도 default export만 금지시킬 것이다. 그래야 import React만 올바르게 필터링할 수 있다. 이 exports를 제대로 하지 않는다면 모든 "import {} from 'react'"에 에러가 있다는 잘못된 ESLint 리포트가 만들어질 것이다.

![ESLint no-restricted-imports 커스터마이징](../asset/eslint_import_customizing_01.png)

이러한 원리를 활용하면 트리쉐이킹이 되지 않는 lodash 같은 라이브러리를 import 하는 것도 방지할 수 있다.

```json
// eslint.json
{
  "rules": {
    "no-restricted-imports": [
      "error",

      {
        "paths": [
          {
            "name": "lodash",
            "message": "lodash는 CommonJS로 작성되어 있어 트리쉐이킹이 되지 않아 번들 사이즈를 크게 합니다. lodash/* 형식으로 import 해주세요"
          }
        ]
      }
    ]
  }
}
```

![ESLint no-restricted-imports 커스터마이징](../asset/eslint_import_customizing_02.png)

`import throttle from 'lodash/throttle';`과 같이 lodash/something은 문제없이 작동한다.

**완전히 새로운 규칙 만들기**

이번에는 한 가지 상황을 가정해 규칙을 만들어보자. 자바스크립트 환경에서는 현재 시간을 알기위해 new Date()를 사용한다. 그러나 이 현재 시간은 기기에 종속된 현재 시간으로, 기기의 현재 시간을 바꿔버리면 new Date()가 반환하는 현재 시간 또한 변경된다. 만약 개발하고자 하는 서비스가 모종의 이유로 사용 중인 기기에 상관없이 한국시간을 반환해야 한다고 가정해보자. 이 경우 new Date()는 기기에 의존적이어사 사용이 불가능하므로 항상 한국시간을 반환하는 서버에 의존해 작업해야 하는 규칙을 팀에서 정의했다고 가정해보자. 따라서 new Date()는 사용하지 못하고, 서버의 시간을 반환하는 함수인 ServerDate()를 만들어 이 함수만 사용해야 하고, 이러한 규칙을 쉽게 준수할 수 있도록 ESLint 규칙을 만들어보자. 여기서 한 가지 조건은 `new Date(123782398429)`나 `new Date('2024-11-25')`는 허용해야 한다는 것이다.

이 규칙을 만들기 전에 해야 할 일은 자바스크립트 코드 내부에서 new Date()의 존재를 파악하는 것이다. new Date()라는 코드를 작성한 다음, espree에서 AST를 어떻게 만드는지 살펴보자.

```json
{
  "type": "Program",
  "start": 0,
  "end": 10,
  "range": [0, 10],
  "body": [
    {
      "type": "ExpressionStatement",
      "start": 0,
      "end": 10,
      "range": [0, 10],
      "expression": {
        "type": "NewExpression",
        "start": 0,
        "end": 10,
        "range": [0, 10],
        "callee": {
          "type": "Identifier",
          "start": 4,
          "end": 8,
          "range": [4, 8],
          "name": "Date"
        },
        "arguments": []
      }
    }
  ],
  "sourceType": "module"
}
```

- `ExpressionStatement`는 해당 코드의 표현식 전체를 나타낸다.
- `ExpressionStatement.expression`는 ExpressionStatement에 어떤 표현이 들어가 있는지 확인한다. 이것이 ESLint에서 확인하는 하나의 노드 단위이다.
- `ExpressionStatement.expression.type`은 해당 표현이 어떤 타입인지 나타내는데, 여기에서는 생성자(new)를 사용한 `NewExpression`임을 알 수 있다.
- `ExpressionStatement.expression.callee`는 생성자를 표현한 표현식에서 생성자의 이름을 나타낸다. 여기서는 `Date`임을 알 수 있다.
- `ExpressionStatement.expression.argument`는 생성자를 표현한 표현식에서 생성자에 전달하는 인수를 나타낸다. 여기서는 인수가 없다.

```javascript
module.exports = {
  meta: {
    type: 'suggestion',
    docs: {
      description: 'disallow use of the new Date()',
      recommended: false,
    },
    fixable: 'code',
    schema: [],
    messages: {
      message:
        'new Date()는 클라이언트에서 실행 시 해당 기기의 시간에 의존적이라 정확하지 않습니다. 현재 시간이 필요하면 ServerDate()를 사용해 주세요.',
    },
  },

  create: function (context) {
    return {
      NewExpression: function (node) {
        if (node.callee.name === 'Date' && node.arguments.length === 0) {
          context.report({
            node: node,
            messageId: 'message',
            fix: function (fixer) {
              return fixer.replaceText(node, 'ServerDate()');
            },
          });
        }
      },
    };
  },
};
```

meta 필드는 해당 규칙과 관련된 정보를 나타내는 필드이다. 규칙과 관련된 정보를 재공하는 필드로, 실제 규칙이 작동하는 코드와는 크게 관련이 없다. 여기서 사용가능한 옵션은 공식 홈페이지의 meta 필드를 참고하면 된다.

중요한 부분은 create 필드에 만들 함수이다. 이 함수는 객체를 반환해야 하는데, 이 객체에서는 코드 스멜을 감지할 선택자나 이벤트명 등을 선언할 수 있다. 여기서는 NewExpression라고 하는 타입의 선택자를 키로 선언해서 new 생성자를 사용할 때 ESLint가 실행되게 한다. 그리고 해당 NewExpression를 찾았을 때, 해당 node를 기준으로 찾고자 하는 생성자인지 검증하는 코드를 넣는다. 여기서는 callee.name이 Date이고, 인수는 없는 경우를 찾는다. 이를 찾았다면 context.report를 통해 해당 코드 스멜을 리포트하고, 문제가 되는 node를 찾았을 때 노출하고 싶은 message를 가리킨다. 이 메세지 정보를 meta.messages애서 가져올 수 있는데, meta.messages의 객체에 키 값을 선언해두면 해당 키 값을 가진 meta.messages의 값을 가져오게 된다. 마지막으로, fix를 키로 하는 함수를 활용해 자동으로 수정하는 코드를 넣어줄 수 있다. 여기서는 ServerDate()라고 하는 함수로 대체할 것이므로 해당 코드로 대체하는 코드까지 넣어준다.

이제 규칙을 만들었으니, 해당 규칙을 배포해보자. 규칙을 하나씩 만들어 배포하는 것은 불가능하며, 반드시 eslint-plugin 형태로 규칙을 묶음으로 배포하는 것만 가능하다.

먼저 빈 패키지를 만든 다음, yo와 generate-eslint를 활용해 eslint-plugin을 구성할 환경을 빠르게 구성해보자.

```shell
yo eslint:plugin

yo eslint:rule
```

rules/no-new-date.js에 앞서 작성한 규칙을 넣고, docs에는 해당 규칙을 위한 설명을, tests에는 테스트 코드를 작성한다.

```javascript
/**
 * @fileoverview nonewdate
 * @author nonewdate
 */
'use strict';

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const rule = require('../../../lib/rules/no-new-date'),
  RuleTester = require('eslint').RuleTester;

//------------------------------------------------------------------------------
// Tests
//------------------------------------------------------------------------------

const ruleTester = new RuleTester();
ruleTester.run('no-new-date', rule, {
  valid: [
    // give me some code that won't trigger a warning
    {
      code: 'new Date(2024, 11, 25)',
    },
    {
      code: 'new Date(2024-11-25)',
    },
  ],

  invalid: [
    {
      code: 'new Date()',
      errors: [{ message: rule.meta.messages.message }],
      output: 'ServerDate()',
    },
  ],
});
```

그리고 마지막으로 npm publish로 배포한 다음, 원하는 프로젝트에서 설치해서 사용하면 된다.

- [커스텀 eslint 레포지토리](https://github.com/wikibook/react-deep-dive-example/tree/main/chapter8/eslint-plugin-yceffort)

### 주의할 점

**Prettier와의 충돌**

Prettier는 코드의 포메팅을 도와주는 도구이다. ESLint와 마찬가지로 코드를 정적으로 분석해서 문제를 해결한다는 점은 동일하지만, 두 페키지가 지향하는 목표는 다르다. ESLint는 코드의 잠재적인 문제가 될 수 있는 부분을 분석해 준다면, Prettier는 포메팅과 관련된 작업, 즉 줄바꿈, 들여쓰기, 작은따옴표와 큰따옴표 등을 담당한다. 자바스크립트에서만 작동하는 ESLint와는 다르게, Prettier는 자바스크립트 뿐만 아니라 HTML, CSS, 마크다운, JSON 등 다양한 언어에서 적용 가능하다.

여기서 문제는 Prettier와 ESLint가 서로 충돌을 일으킬 수 있다는 것이다. 즉, ESLint에서도 Prettier에서 처리하는 작업(들여쓰기, 줄바꿈, 따옴표, 최대 글자 수 등)을 처리할 수 있기 때문에 두 가지 모두 자바스크립트 코드에서 실행한다면 서로 충돌하는 규칙으로 인해 에러가 발생하고, 최악의 경우 ESLint, Prettier 모두 만족하지 못하는 코드가 만들어질 수도 있다.

이 문제를 해겷하는 방법은 두 가지가 있는데, 첫 번째 방법은 서로 규칙이 충돌되지 않게끔 규칙을 잘 선언하는 것이다. Prettier에서 제공하는 규칙을 어기지 않도록, ESLint에서는 해당 규칙을 끄는 방법이다. 이 경우 코드에 ESLint를 적용하는 작업과 코드 포메팅을 하는 작업이 서로 다른 패키지에서 발생하게 된다.

두 번째 방법은 자바스크립트나 타입스크립트는 ESLint에, 그 외 파일(마크다운, YAML, JSON 등)은 모두 Prettier에 맡기는 것이다. 그 대신 자바스크립트에 추가적으로 필요한 Prettier 관련 규칙은 모두 eslint-plugin-prettier를 사용한다. eslint-plugin-prettier는 Prettier에서 제공하는 모든 규칙을 ESLint에서 사용할 수 있는 규칙으로 만들어둔 플러그인이다. 이렇게 Prettier와 ESLint가 서로 관여하는 파일을 물리적으로 분리한다면 코드 충돌의 위험은 없애고 Prettier가 제공하는 모든 규칙을 사용할 수 있다.

**규칙에 대한 예외처리**

만약 일부 코드에서 특정 규칙을 임시로 제외시키고 싶다면 `eslint-disable-` 주석을 사용하면 된다.

개발자라면 이러한 규칙을 가장 많이 사용하는 곳 중 하나가 바로 `eslint-disable-line no-exhaustive-deps`일 것이다. 이 규칙을 useEffect나 useMemo 같이 의존성 배열을 제대로 선언했는지 확인하는 역할을 한다. 겉보기에는 굉장히 별거 아닌 규칙처럼 보이지만 이 규칙을 위해 작성된 코드는 자그마치 1,800여 줄에 걸쳐 있다. 그만큼 리액트 팀에서는 의존성 배열을 검사하기 위해 많은 공을 들인다고 볼 수 있다. 물론 정말 넣을 것이 없어서 []를 넣는 경우는 당연히 제외된다. 여기서 말하는 경우는 상태에 의존하고 있음에도 고의로 빈 배열을 넣는 경우를 말한다.

이 규칙을 사용하는 케이스

- 괜찮다고 임의로 판단하는 경우: 해당 변수는 컴포넌트 상태와 별개로 동작한다는 것을 의미한다. 이 경우에는 해당 변수를 어떻게 선언할지 다시 고민해 봐야한다.
- 의존성 배열이 너무 긴 경우: 이 말은 useEffect 내부 함수가 너무 길다는 말과 동일하다. useEffect를 쪼개서 의존성 배열의 가독성과 안전성을 확보해야 한다.
- 마운트 시점에 한 번만 실행하고 싶은 경우: [] 배열이 있다는 것은 컴포넌트의 상태값과 별개의 부수 효과가 되어 컴포넌트 상태와 불일치가 일어날 수 있게된다. 상태와 관계없이 한 번만 실행되어야 하는 것이 있다면 컴포넌트에 존재할 이유가 없다. 이 경우 적절한 위치로 옮기는 것이 옳다.

**ESLint 버전충돌**

create-react-app으로 생성된 앱에 원하는 eslint-config-triple을 설치하는 상황을 가정해보자. 최신 버전의 react-scripts인 5.0.1에서 eslint-config-triple 최신 버전을 함께 설치하고 ESLint를 수행하면 다음과 같은 에러가 발생한다.

분명 eslint-plugin-promise는 eslint-plugin-triple에서 제공하고 있기 때문에 정상적으로 설치되어 있다. 그러나 이를 못찾는 이유는 바로 두 개의 다른 ESLint 버전이 설치되어 있기 때문이다.

create-react-app을 실행하면 설치되는 react-scripts의 5.0.1 버전에는 ESLint 8에 의존성을, eslint-config-triple은 ESLint 7에 의존성을 가지고 있다. ESLint가 실행되는 순간, 높은 버전인 8이 실행됐고, 8에는 eslint-plugin-promise가 없기 때문에 에러가 발생한다. 이 때문에 ESLint 공식문서에서는 ESLint를 peerDependencies로 설정해두라고 권장하고 있다.

이러한 문제를 미연에 방지하려면 설치하고자 하는 eslint-config, eslint-plugin이 지원하는 ESLint 버전을 확인하고, 또 설치하고자 하는 프로젝트에서 ESLint 버전을 어떻게 지원하고 있는지 살펴봐야 한다. 두 버전을 모두 충족시킬 수 있는 환경을 만들어두고 설치하는 것이 좋다. 만약 이러한 사전 준비를 제대로 하지 않는다면 ESLint를 사용할 때마다 버전이 맞지 않는다는 오류 메세지를 마주하게 될 것이다.
