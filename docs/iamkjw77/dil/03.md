## 03. 리액트 훅 깊게 살펴보기

### 리액트의 모든 훅 파헤치기

훅은 클래스 컴포넌트에서만 가능했던 state, ref 등 리액트의 핵심적인 기능을 함수에서도 가능하게 만들었고, 무엇보다 클래스 컴포넌트보다 간결하게 작성할 수 있어 훅이 등장한 이래로 대부분의 리액트 컴포넌트는 함수 컴포넌트로 작성되고 있을 정도로 많은 사랑을 받고 있다.

1. **useState**

useState는 함수 컴포넌트 내부에서 상태를 정의하고, 이 상태를 관리할 수 있게 해주는 훅이다.

useState는 클로저를 이용했다. 여기서 클로저는 어떤 함수(useState) 내부에 선언된 함수(setState)가 함수의 실행이 종료된 이후에도(useState가 호출된 이후에도) 지역변수인 state를 계속 참조할 수 있다는 것을 의미한다.

```javascript
// useState 내부 모습을 구현한 모습

const MyReact = (function () {
  const global = {};
  // react에서는 여러 개의 상태를 하나의 컴포넌트에서 사용할 수 있기 때문에 인데스를 사용해 각 상태를 구분한다.
  let index = 0;

  function useState(initialState) {
    if (!global.states) {
      global.states = [];
    }

    const currentState = global.states[index] || initialState;
    global.states[index] = currentState;

    // setState는 함수 내부의 currentIndex가 클로저로 저장되었다.
    // 외부함수(즉시 실행함수), 내부함수(function (value) {...})
    // setState는 currentIndex라는 값을 기억하고 있어서
    // 이 값으로 항상 해당 인덱스의 상태만 변경하게 된다.
    // 즉시 실행함수를 사용하지 않으면 index 값을 고정하지 못함
    // 이를 통해 useState가 여러 번 호출되어도 각각의 setState는 고유한 index 상태를 가지게 된다
    const setState = (function () {
      let currentIndex = index;
      return function (value) {
        global.states[currentIndex] = value;
      };
    })();

    index = index + 1;

    return [currentState, setState];
  }

  function Component() {
    const [value, setValue] = useState(0);
  }
})();
```

**게으른 초기화**
useState의 인수로 특정한 값을 넘기는 함수를 인수로 넣어줄 수도 있다. useState에 변수 대신 함수를 넘기는 것을 게으른 초기화(lazy initialization)라고 한다.

이러한 게으른 초기화는 useState의 초깃값이 복잡하거나 무거운 연산(localStorage나 sessionStorage에 대한 접근, map, filter, find 같은 배열에 대한 접근, 혹은 초깃값 계산을 위해 함수 호출이 필요할 때)을 포함하고 있을 때 사용하라고 되어있다. 이 게으른 초기화 함수는 오로지 state가 처음 만들어질 때만 사용된다. 만약 리렌더링이 발생된다면 이 함수의 실행은 무시된다.

```javascript
const [count, setCount] = useState(() =>
  Number.parseInt(window.localStorage.getItem(cacheKey))
);
```

2. **useEffect**

useEffect는 애플리케이션 내 컴포넌트의 여러 값들을 활용해 동기적으로 부수효과를 만드는 메커니즘이다.

useEffect는 첫 번째 인수로는 실행할 부수효과가 포함된 함수를, 두 번째 인수로는 의존성 배열을 전달한다.

useEffect는 자바스크립트의 proxy나 데이터 바인딩, 옵저버와 같은 특별한 기능을 통해 값의 변화를 관찰하는 것이 아니고 렌더링할 때마다 의존성에 있는 값을 보면서 이 의존성의 값이 이전과 다른게 하나라도 있으면 부수효과를 실행하는 평범한 함수라 볼 수 있다.

**클린업 함수의 목적**

```javascript
import { useState, useEffect } from 'react';

export default function App() {
  const [counter, setCounter] = useState(0);

  function handleClick() {
    setCounter((prev) => prev + 1);
  }

  useEffect(() => {
    function addMouseEvent() {
      console.log();
    }

    window.addEventListener('click', addMouseEvent);

    return () => {
      console.log('클린업 함수 실행!', counter);
      window.removeEventListener('click', addMouseEvent);
    };
  }, [counter]);

  return (
    <>
      <h1>{counter}</h1>
      <button onClick={handleClick}>+</button>
    </>
  );
}

// 실행결과
// 클린업 함수 실행! 0
// 1

// 클린업 함수 실행! 1
// 2

// 클린업 함수 실행! 2
// 3

// 클린업 함수 실행! 3
// 4

// ...
```

위 로그를 살펴보면 클린업 함수는 이전 counter 값, 즉 이전 state를 참조해 실행된다는 것을 알 수 있다. `클린업 함수는 새로운 값과 함께 렌더링된 뒤에 실행되기 때문에 위와 같은 메세지가 나타난다.` 여기서 중요한 것은, 클린업 함수는 비록 새로운 값을 기반으로 렌더링 된 뒤에 실행되지만 `이 변경된 값을 읽는 것이 아니라 함수가 정의됐을 당시에 선언됐된 이전 값을 보고 실행된다는 것`이다.

함수 컴포넌트의 useEffect는 그 콜백이 실행될 때마다 이전의 클린업 함수가 존재한다면 그 클린업 함수를 실행한 뒤애 콜백을 실행한다. 따라서 이벤트를 추가하기 전에 이전에 등록했던 이벤트 핸들러를 삭제하는 코드를 클린업 함수에 추가하는 것이다. 이렇게 함으로써 특정 이벤트의 핸들러가 무한히 추가되는 것을 방지 할 수 있다.

이처럼 클린업 함수는 생명주기 메서드의 언마운트 개념과는 조금 차이가 있는 것을 볼 수 있다. 클린업 함수는 언마운트라기보다는 함수 컴포넌트가 리렌더링됐을 때 의존성 변화가 있었을 당시 이전의 값을 기준으로 실행되는, 말 그대로 `이전 상태를 청소해 주는 개념`으로 보는 것이 좋다.

**의존성 배열**

```javascript
// 1
function Component() {
  console.log('렌더링 됨');
}

// 2
function Component() {
  useEffect(() => {
    console.log('렌더링 됨');
  }, []);
}

// 서버 사이드 렌더링 관점에서 useEffect는 클라이언트 사이드에서 실행되는 것을 보장해준다
// useEffect 내부에서는 window 객체의 접근에 의존하는 코드를 사용해도 된다
// 반면 1번과 같이 함수 내부에서의 직접 실행은 컴포넌트가 렌더링되는 도중에 실행된다
// 따라서 2번과 달리 서버 사이드 렌더링의 경우에 서버에서도 실행된다
// 그리고 이 작업은 함수 컴포넌트의 반환을 지연시키는 행위이다
// 즉, 무거운 작업일 경우 렌더링을 방해하므로 성능에 악영향을 미칠 수 있다
```

```javascript
// useEffect의 구현
const MyReact = (function () {
  const global = {};
  let index = 0;

  function useEffect(callback, dependencies) {
    const hooks = global.hooks;

    let previousDependencies = hooks[index];

    let isDependenciesChanged = previousDependencies
      ? dependencies.some(
          (value, idx) => !Object.is(value, previousDependencies[idx])
        )
      : true;

    if (isDependenciesChanged) {
      callback();

      index++;

      hooks[index] = dependencies;
    }

    return { useEffect };
  }
})();
```

핵심은 의존성 배열의 이전 값과 현재 값의 얕은 비교이다. 리액트는 값을 비교할 때 Object.is를 기반으로 하는 얕은 비교를 수행한다. `이전 의존성 배열과 현재 의존성 배열이 값에 하나라도 변경사항이 있다면 callback으로 선언한 부수효과를 실행한다.`
이것이 useEffect의 본질이다.

**useEffect를 사용할 때 주의할 점**

1. eslint-disable-line react-hooks/exhaustive-deps 주석은 최대한 자제하라

   - 위 eslint 룰은 useEffect 인수 내부에서 사용하는 값 중 의존성 배열에 포함되 있지 않은 값이 있을 때 경고를 발생시킨다.
   - useEffect는 반드시 의존성 배열로 전달한 값의 변경에 의해 실행되야 하는 훅이다.

2. useEffect의 첫 번째 인수에 함수명을 부여하라
   - useEffect의 코드가 복잡해지고 많아질수록 무슨 일을 하는 useEffect 코드인지 파악하기 어려워진다. 이때 이 useEffect의 인수를 익명함수가 아닌 적절한 이름을 사용한 기명 함수로 바꾸는 것이 좋다.

```javascript
useEffect(
  function logActiveUser() {
    logging(user.id);
  },
  [user.id]
);
```

3. 거대한 useEffect를 만들지 마라

   - useEffect는 의존성 배열을 바탕으로 렌더링 시 의존성이 변경될 때마다 부수효과를 실행한다. 이 부수효과의 크기가 커질수록 애플리케이션의 성능에 악영향을 미친다. 비록 useEffect가 컴포넌트의 렌더링 이후에 실행되기 때문에 렌더링 작업에는 영향을 적게 미칠 수 있지만 여전히 자바스크립트 실행성능에 영향을 미친다는 것은 변함없다.

   - 만약 부득이하게 큰 useEffect를 만들어야 한다면 적은 의존성 배열을 사용하는 여러 개의 useEffect로 분리하는 것이 좋다.

4. 불필요한 외부함수를 만들지 마라

```javascript
// useEffect 외부에 있던 함수를 내부로 가져왔더니 훨씬 간결한 모습이다.

function Component({ id }: { id: string }) {
  const [info, setInfo] = (useState < number) | (null > null);

  useEffect(() => {
    const controller = new AbortController();

    (async () => {
      const result = await fetchInfo(id, { signal: controller.signal });
      setInfo(await result.json());
    })();

    return () => controller.abort();
  }, [id]);

  return <div>렌더링</div>;
}
```

**왜 useEffect의 콜백인수로 비동기 함수를 바로 넣을 수 없을까?**

만약 useEffect의 인수로 비동기 함수가 사용 가능하다면 비동기 함수의 응답속도에 따라 결과가 이상하게 나타날 수 있다. 극단적인 예제로 이전 state 기반의 응답이 10초가 걸렸고, 이후 바뀐 state 기반의 응답이 1초 뒤에 왔다면 이전 state 기반으로 결과가 나와버리는 불상사가 생길 수 있다. 이러한 문제를 `useEffect의 경쟁상태(race condition)`라고 한다.

```javascript
useEffect(() => {
  let shouldIgnore = false;

  async function fetchData() {
    const response = await fetch('http://some.data.com');
    const result = await response.json();

    if (!shouldIgnore) {
      setData(result);
    }
  }

  fetchData();

  return () => {
    // shouldIgnore를 통해 setData의 실행을 막는 것뿐만 아니라
    // AbortController를 활용해 직전 요청 자체를 취소하는 것도 좋은방법이 될 수 있다.

    shouldIgnore = true;
  };
}, []);
```

비동기 함수가 useEffect 내부에 존재하게 되면, useEffect 내부에서 생성되고 실행되는 것을 반복하므로 클린업 함수에 이전 비동기 함수에 대한 처리를 추가하는 것이 좋다. fetch의 경우 abortController 등으로 이전 요청을 취소하는 것이 좋다.

3. **useMemo**

useMemo는 비용이 큰 연산에 대한 결과를 저장(메모이제이션)해 두고, 이 저장된 값을 반환하는 훅이다.

첫 번째 인수로는 어떠한 값을 변환하는 생성 함수를, 두 번째 인수로는 해당 함수가 의존하는 값의 배열을 전달한다. useMemo는 의존성 배열의 값이 변경되지 않았으면 함수를 재실행하지 않고 이전에 기억해 둔 해당 값을 반환하고, 의존상 베열의 값이 변경됐다면 첫 번째 인수의 함수를 실행한 후에 그 값을 반환하고 그 값을 다시 기억해둔다. 이러한 메모이제이션은 단순히 값 뿐만 아니라 컴포넌트도 가능하다.

```javascript
import { useEffect, useMemo, useState } from 'react';

function ExpensiveComponent({ value }) {
  useEffect(() => {
    console.log('rendering!');
  });

  return <span>{value + 1000}</span>;
}

function App() {
  const [value, setValue] = useState(10);
  const [, triggerRendering] = useState(false);

  // 이 경우에는 React.memo를 쓰는 것이 더 현명하다
  const MemoizedComponent = useMemo(
    () => <ExpensiveComponent value={value} />,
    [value]
  );

  function handleChange(e) {
    setValue(Number(e.target.value));
  }

  function handleClick() {
    triggerRendering((prev) => !prev);
  }

  return (
    <>
      <input type="text" value={value} onChange={handleChange} />
      <button onClick={handleClick}>렌더링 발생!</button>
      {MemoizedComponent}
    </>
  );
}

export default App;
```

4.  **useCallback**

    useMemo가 값을 기억했다면, useCallback은 인수로 넘겨받은 콜백 자체를 기억한다. 쉽게 말해 useCallback은 특정함수를 새로 만들지 않고 다시 재사용한다는 의미이다.

```javascript
const ChildComponent = memo(({ name, value, onChange }) => {
  useEffect(() => {
    console.log('rendering', name);
  });

  return (
    <>
      <h1>
        {name} {value ? '켜짐' : '꺼짐'}
      </h1>
      <button onClick={onChange}>toggle</button>
    </>
  );
});

function App() {
  const [status1, setStatus1] = useState(false);
  const [status2, setStatus2] = useState(false);

  const toggle1 = () => {
    setStatus1(!status1);
  };

  const toggle2 = () => {
    setStatus2(!status2);
  };

  return (
    <>
      {/* 아래 중 어느 한 버튼을 클릭하면 클릭한 컴포넌트 외에도 클릭하지 않은 컴포넌트도 렌더링 된다 */}
      {/* 그 이유는 state값이 바뀌면서 App 컴포넌트가 리렌더링되고, 그때마다 매번 onChange로 넘기는 함수가 재생성되고 있기 때문이다 */}

      <ChildComponent name="1" value={status1} onChange={toggle1} />
      <ChildComponent name="2" value={status2} onChange={toggle2} />
    </>
  );
}
```

```javascript
// useCallback을 사용하면 의존성 배열이 변경되지 않는 한 함수를 재생성하지 않는다

const toggle1 = useCallback(
  function toggle1() {
    setStatus1(!status1);
  },
  [status1]
);

const toggle2 = useCallback(
  function toggle2() {
    setStatus2(!status2);
  },
  [status2]
);
```

**useCallback에 기명함수를 넣어준 이유**

크롬 메모리 탭에서 디버깅을 용이하게 하기 위함이다. 익명함수는 이름이 없어 해당 함수를 추적하기 어렵다.

**useCallback 구현**

기본적으로 useCallback은 useMemo로 구현할 수 있지만, useMemo는 값 자체를 메모이제이션하는 용도이기 때문에 반환문으로 함수 선언문을 반환해야 한다. 이는 코드를 작성하거나 리뷰하는 입장에서 혼란을 불러올 수 있으므로 함수를 메모이제이션 하는 용도라면 좀 더 간단한 useCallback을 사용하자.

```javascript
export function useCallback(callback, args) {
  currentHook = 8;

  return useMemo(() => callback, args);
}
```
