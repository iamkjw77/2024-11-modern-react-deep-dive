## 12. 모든 웹 개발자가 관심을 가져야 할 핵심 웹 지표

### 웹 사이트와 성능

2019년 미국 시애틀에 있는 디지털 마케팅 에어전시 회사인 Protent의 조사에 따르면 웹사이트의 성능은 다음과 같은 요소에 영향을 미쳤다.

- 1초 내로 로딩되는 사이트는 5초 내로 로딩되는 사이트보다 전자상거래 전환율(실제 구매로 이어지는 고객의 비율)이 2.5배 높다.
- 0~5초의 범위에서, 1초 로딩이 늦어질수록 전환율은 4.42%씩 떨어진다. 즉, 5초 이상 느려지면 전환율은 20% 가까이 떨어진다.
- 페이지 로드 시간이 0~2초 사이인 페이지에서 가장 높은 전환율을 달성할 수 있다.

그리고 사용자 또한 이러한 성능에 매우 민감한 것으로 밝혀졌다.

- 소비자의 70%는 페이지 속도가 온라인 커머스 사이트를 방문하는데 영향을 미친다고 밝혔으며,
- 절반에 가까운 사람이 더욱 빠르게 로딩할 수 있다면 애니메이션과 동영상이 필요없다고 밝혔다.

구글에서도 이와 비슷하게 웹사이트 성능에 관한 통계를 내놓은 바 있다.

- 전체 웹페이지를 표시하는데 필요한 최적의 평균 리소스 요청 수는 50회 미만이다. (한 페이지를 로딩하는데 50회 미만의 요청이 발생해야 한다.)
- 평균적으로 웹페이지 전체를 요청하는데 15.3초가 걸린다.
- 인간의 뇌와 신경계를 분석한 결과, 페이지 로드 시간이 1초에서 10초로 늘어날수록 모바일 사이트를 이탈할 확률이 123% 증가한다.

또한 구글은 요즘 웹사이트의 성능에 대해 다음과 같은 내용의 글을 남기기도 했다.
`전 세계 사용자의 대부분이 모바일을 3G가 아닌 4G로 사용하고 있음에도 불구하고, 대부분의 모바일 사이트는 여전히 느리고 너무 많은 요소 때문에 비대해졌다.`

그렇다면 웹사이트 성능은 어떻게 측정할 수 있을까?
몇 년 전부터 구글은 `핵심 웹 지표(Core Web Vital)`라고 하는, 웹사이트에 우수한 사용자 경험을 제공하는데 필요한 몇 가지 핵심적인 요소를 꼽고, 이에 대한 지표를 제시하고 있다.

### 핵심 웹 지표(Core Web Vital)란?

구글에서 핵심 웹 지표로 꼽는 지표는 다음과 같다.

- 최대 콘텐트풀 페인트(LCP, Largest Contentful Paint)
- 최초 입력 지연(FID, First Input Delay)
- 누적 레이아웃 이동(CLS, Cumulative Layout Shift)

아래 두 지표는 핵심까지는 아니지만, 특정 문제를 진단하는데 사용될 수 있다고 언급했다.

- 최초 바이트까지의 시간(TTFB, Time To First Byte)
- 최초 콘텐트풀 시간(FCP, First Contentful Paint)

### 최대 콘텐트풀 페인트(LCP, Largest Contentful Paint)

`최대 콘텐트풀 페인트(LCP, Largest Contentful Paint)`란 `페이지가 처음으로 로드를 시작한 시점부터 뷰포트 내부에서 가장 큰 이미지 또는 텍스트를 렌더링하는 데 걸리는 시간`을 말한다. 뷰포트는 사용자에게 현재 노출되는 화면을 의미한다. 사용자에게 노출되는 영역은 기기에 의존하므로 뷰포트 크기는 기기마다 다르다. 즉, 모바일 기기는 PC에 비해 뷰포트가 작을 것이다. 그리고 이 뷰포트 내부에서 '큰 이미지와 텍스트'는 다음과 같이 정의되어 있다.

- `<img>`
- `<svg>` 내부의 `<image>`
- poster 속성을 사용하는 `<video>`
- url()을 통해 불러온 배경 이미지가 있는 요소
- 텍스트와 같이 인라인 텍스트 요소를 포함하고 있는 블록 레벨 요소
  - 이 블록 레벨 요소에는 `<p>`, `<div>`가 포함된다.

이미지와 텍스트가 각각 사용자에게 언제 노출됐는지를 확인하는 정확한 시점은 W3C 문서에 나와있다. 기술적인 순서로 언급되어 있지만 요약하자면 각 `엘리먼트가 등장한 시점부터 텍스트 또는 이미지가 완전히 로딩되는 시점`으로 보면된다.

즉, 최대 콘텐트풀 페인트란 `사용자의 기기가 노출하는 뷰포트 내부에서 가장 큰 영역을 차지하는 요소가 렌더링되는데 얼마나 걸리는지를 측정한 지표`인 것이다. 가장 큰 요소로 고려되는 것은 앞의 5개이며, 실제 크기가 크다고 하더라도 뷰포트 영역 밖에 넘치는 요소가 있다면 해당 영역의 크기는 고려되지 않는다. 따라서 아무리 콘텐츠 높이가 길어도, 최대 콘텐트풀 페인트에 영향을 미치는 부분은 오직 뷰포트 영역뿐이다.

웹 사이트에서 LCP가 변화하는 과정을 살펴보자.

1. 최초에 헤더가 가장 먼저 노출됐다. 그러므로 LCP는 헤더이다.
2. 그다음 바둑판 메뉴가 노출됐다. 이 영역은 헤더보다 크기 때문에 LCP가 헤더에서 이 바둑판 메뉴로 바뀌었다.
3. 시간이 지나고 콘텐트가 로딩되면서 LCP는 가운데 사진 영역으로 바뀌었다.
4. 3번에서 현재 LCP인 영역은 이미지 로딩이 필요한데, 아직 이미지 로딩이 끝나지 않았다.
5. LCP 영역 내부의 이미지 로딩이 끝나면서 LCP 지표가 기록된다.

LCP는 페이지 로딩에 따라 변화하는 지표이다. 사용자가 이용하는 디바이스의 크기에 따라, 그리고 그것이 이미지와 같이 비교적 크기가 큰 리소스라면 실제로 로딩에 필요한 시간에 따라 LCP 지표의 값이 달라질 수 있다.

**기준점수**

LCP에서 좋은 점수란 해당 지표가 2.5초 내로 응답이 오는 것이다. 4초 이내로 응답이 온다면 보통, 그 이상이 걸리면 나쁨으로 판단된다.

**개선방안**

1. 텍스트는 언제나 옳다

   가능한 한 해당영역을 텍스트로 채우는 것이 상책이다.

2. 이미지는 어떻게 불러올 것인가?

   1. `<img>`
   2. `<svg>` 내부의 `<image>`
   3. poster 속성을 사용하는 `<video>`
   4. url()을 통해 불러온 배경 이미지가 있는 요소

      1, 3번이 더 빠르게 완성된다.

      - `<img>`

        이미지는 브라우저의 프리로드 스캐너에 의해서 먼저 발견되어 빠르게 요청이 일어난다. 프리로드 스캐너란 HTML을 파싱하는 단계를 차단하지 않고 이미지와 같이 빠르게 미리 로딩하면 좋은 리소스를 먼저 찾아 로딩하는 브라우저의 기능이다. `<img>` 내부의 리소스는 이처럼 HTML 파싱이 미처 완료되지 않더라도 프리로드 스캐너가 병렬적으로 리소스를 다운로드하므로 LCP 요소를 불러오기에 적절한 방법이다. 이는 `<picture>`도 마찬가지이다.

      - `<svg>` 내부의 `<img>`

        `<img>`와 다른 점이 하나 있는데, 바로 모든 리소스를 다 불러온 이후에 이미지를 불러온다는 것이다. 즉, `<svg>` 내부의 `<img>`는 프리로드 스캐너에 의해 발견되지 않아 병렬적으로 다운로드가 일어나지 않는다. 이는 결국 LCP 점수에도 악영향을 미치므로 이러한 방식은 삼가하는 것이 좋다.

      - `<video>`의 poster

        poster는 사용자가 video 요소를 재생하거나 탐색하기 전까지 노출되는 요소이다. 이 역시 마찬가지로 프리로드 스캐너에 의해 조기 발견되어 `<img>`와 같은 성능을 나타낸다. 그리고 한 가지 알아둬야 할 사실은, 향후에 poster가 없는 video의 경우 video를 실제로 로딩해 첫 번째 프레임을 해당 poster 리소스로 대체할 예정이라는 것이다. 그러므로 video가 LCP애 영향을 받을 것 같다면 poster를 반드시 넣어주는 것이 좋다.

      - background-image: url()

        background-image를 비롯해서 CSS에 있는 리소스는 항상 느리다. 이러한 리소스는 브라우저가 해당 리소스를 필요로 하는 DOM을 그릴 준비가 될 때까지 리소스 요청을 뒤로 미루기 때문이다. 이 말인즉슨, LCP에도 별로 좋은 영향을 미치지 않는다는 것이다. 그러므로 가능하다면 background-image는 LCP와 같이 중요한 리소스에는 사용하지 않는 것이 좋다.

**그 밖에 조심해야 할 사항**

- `이미지 무손실 압축`: 당연한 이야기이지만 웹으로 서비스할 이미지는 가능한 한 무손실 형식으로 압축해 최소한의 용량으로 서비스하는 것이 좋다.
- `loading=lazy 주의`: loading=lazy는 리소스를 중요하지 않음으로 표시하고 필요할 때만 로드하는 전략으로, `<img>`, `<iframe>`등에 적용할 수 있지만 문제는 LCP의 이미지는 중요하지 않은 리소스로 분류해서는 안된다는 것이다. 이는 그저 로딩 속도만 늦출 뿐 지표 점수에는 도움이 되지 않는다. 상대적으로 중요하지 않은 이미지에서는 사용해도 좋지만 LCP의 이미지에는 사용하지 않는 것이 좋다.
- `fadein과 같은 각종 애니메이션`: 당연하게도 이미지가 그냥 뜨는 것보다 fadeIn ease 10s와 같이 처리한다면 LCP도 그만큼 늦어진다.
- `클라이언트에서 빌드하지 말 것`: 앞선 연구사례에서 볼 수 있는 최적의 시나리오는 무엇일까? 서버에서 빌드해온 HTML을 프리로드 스캐너가 바로 읽어서 LCP로 빠르게 가져가는 것이다. 그러나 만약 LCP에 대해 다음과 같은 useEffect가 있으면 어떻게 될까?

  ```javascript
  useEffect(() => {
    async function loadData() {
      const result = await fetch('https://example.com/data');
      if (result.ok) {
        setShow(true); // LCP 영역을 노출함
      }
    }
  }, []);
  ```

  이렇게 되면 결국 LCP는 HTML을 다운로드한 직후가 아닌 리액트 코드를 파싱하고 읽어서 API 요청을 보내고, 응답을 받는 만큼 늦어진다. 따라서 가능한 이 영역은 서버에서 미리 빌드된 채로 오는 것이 좋다.

- `최대 콘텐트풀 리소스는 직접 호스팅`: 가능하다면 최대 콘텐트풀 리소스는 같은 도메인에서 직접 호스팅하는 것이 좋다. 일반적인 경우 Cloudlinary 같은 이미지 최적화 서비스를 사용해 하나의 이미지에 대해 크기도 줄이고, 포멧도 변환하고, 압축해서 이미지를 관리하지만 다른 출처(origin)에서 이렇게 정제한 이미지를 가져오는 것은 최적화에 별로 좋은 영향을 미치지 않는다. 왜냐하면 이미 연결이 맺어진 현재 출처와는 다르게, 완전히 새로운 출처의 경우에는 네트워크 커넥션부터 다시 수행해야 하기 때문이다. 앞서 loading=lazy의 경우와 마찬가지로 가능한 한 중요한 리소스는 직접 다루고 그 외에 덜 중요한 리소스에 대해서만 이미지 최적화 서비스를 사용하는 식으로 관리하는 것이 좋다.

### 최초 입력 지연(FID, First Input Delay)

웹 페이지 로딩속도만큼 중요한 것이 웹사이트의 반응속도이다. 그리고 이러한 웹사이트의 반응을 측정하는 지표가 바로 `최초 입력 지연(FID: First Input Delay)`이다.
최초 입력 지연의 정의는 다음과 같다.

`사용자가 페이지와 처음 상호작용할 때(예: 링크를 클릭하거나 버튼을 탭하거나 사용자 지정 JS 기반 컨트롤을 사용할 때)부터 해당 상호작용에 대한 응답으로 브라우저가 실제로 이벤트 핸들러 처리를 시작하기까지의 시간을 측정합니다.`

최초 입력 지연은 사용자가 얼마나 빠르게 웹페이지와의 상호작용에 대한 응답을 받을 수 있는지 측정하는 지표이다. 모든 입력에 대해 측정하는 것이 아니며, 최초의 입력 하나에 대해서만 그 응답 지연이 얼마나 걸리는지 판단한다.

웹사이트 내부의 이벤트가 반응이 늦어지는 이유는 무엇일까? 그 이유는 대부분 해당 입력을 처리해야 하는 메인 스레드가 바쁘기 때문이다. 그렇다면 이 메인 스레드가 바쁜 이유는 무엇일까? 무언가 대규모 렌더링이 일어나고 있거나, 대규모 자바스크립트 파일을 분석하고 실행하는 등 다른 작업을 처리하는데 리소스를 할애하고 있기 때문이다. 이렇게 메인 스레드가 바쁜 경우, 자바스크립트 실행 환경은 `싱글 스레드`이기 때문에 자바스크립트가 이벤트 리스너와 같은 다른 작업을 실행할 수 없어 지연이 발생한다. 즉, 이벤트가 발생하는 시점에 최대한 메인 스레드가 다른 작업을 처리할 수 있도록 여유를 만들어 둬야 사용자에게 빠른 반응성을 보장할 수 있다.

이 최초 입력에 해당하는 내용에는 어떤 것이 있을까? 타이핑, 터치(클릭), 핀치 투 줌, 스크롤 등 사용자가 웹사이트에서 할 수 있는 입력은 정말로 다양하다. FID에 대한 정의를 살펴보면 이처럼 다양한 이벤트 중에서도 반응성에 해당하는 클릭, 터치, 타이핑 등 사용자의 개별 입력 작업에 초점을 맞추고 측정한다. 스크롤이나 핀치 투 줌 등은 사용자의 입력이 아닌 애니메이션으로 분류해 측정 대상에서 제외한다.

구글은 사용자 경헙을 크게 4가지로 분류해 정의하는데, 이를 RAIL이라고 한다.

- Response: 사용자의 입력에 대한 반응 속도, 50ms 미만으로 이벤트를 처리할 것
- Animation: 애니메이션의 각 프레임을 10ms 이하로 생성할 것
- Idle: 유휴 시간을 극대화해 페이지가 50ms 이내에 사용자 입력에 응답하도록 할 것
- Load: 5초 이내에 콘텐츠를 전달하고 인터렉션을 준비할 것

이 가운데 FID는 R에 해당하는 응답에 초점을 맞추고 있다.

정리하자면, FID란 화면이 최초에 그려지고 난 뒤, 사용자가 웹페이지에서 클릭 등 상호작용을 수행했을 때 메인 스레드가 이 이벤트에 대한 반응을 할 수 있을 때까지 걸리는 시간을 의미한다. 그리고 이 시간은 메인 스레드가 처리해야 하는 작업이 많을수록 느려진다.

한 가지 여기서 추가로 염두에 둬야 할 것은 이벤트가 처리되는 것이 얼마나 지연되는지만 판단한다는 것이다. 즉, 최초 이벤트 발생으로부터 해당 이벤트의 핸들러가 실행되는 순간까지 사이의 기간만 측정한다. 즉, 이벤트 핸들러가 완료되는데 걸리는 시간은 측정하지 않는다. 만약 이벤트 핸들러의 실행시간을 측정하고 싶다면 Event Timing API를 사용하는 것이 좋다.

**기준점수**

FID의 좋은 점수를 얻기 위해서는 100ms 이내로 응답이 와야하며, 300ms 이내인 경우 보통, 그 이후의 경우에는 나쁨으로 처리된다.

**개선방안**

FID를 개선하려면 FID에 가장 큰 영향을 미치는 메인 스레드에 이벤트를 실행할 여유를 줘야한다.

1. 실행에 오래걸리는 긴 작업을 분리

   - 꼭 웹페이지에서 해야하는 작업인가?

     만약 사용자 기기의 환경과 비슷하게 메인 스레드의 성능을 의도적으로 낮추고 싶다면 크롬의 개발자 도구를 활용하면 된다. 크롬 개발자 도구의 성능 탭에서 CPU를 선택하면 CPU의 성능을 의도적으로 떨어뜨릴 수 있다. 이와 비슷하게 네트워크 속도도 고의로 느리게 만들 수 있다. 이렇게 설정하고 테스트하면 열악한 모바일 기기의 상황을 재현해 웹페이지의 성능이 어떨지 미리 예측해 볼 수 있다. 만약 이렇게 테스트해보고도 오래 걸리는 작업이라면 꼭 웹페이지에서 해야 하는 작업인지 고민해 봐야한다. 만약 그런 작업이 아니라면 서버로 옮겨서 처리하는 것이 좋다. 서버에서 처리하면 상대적으로 빠르고 쾌적한 환경에서 처리해 브라우저의 메인 스레드를 오래 점유하지 않게 할 수 있다.

   - 긴 작업을 여러 개로 분리하기

     만약 꼭 웹페이지에서 처리해야 하는 작업이라면 해당 작업을 여러 개로 분리하는 것이 좋다. 하나의 긴 작업이 메인 스레드를 계속 점유할수록 사용자는 웹페이지에서 응답을 받지 못하고 있을 가능성이 크다. 일반적으로 크롬의 경우 50ms 이상 걸리면 오래 걸리는 작업이라고 간주한다. 작업을 분리한다는 것은 단순히 실행이 오래 걸릴 것 같은 작업을 분리하는 것뿐만 아니라 웹페이지 최초 로딩에 필요하지 않은 내용을 나중에 불러오는 것도 포함된다. 예를 들어, 웹페이지에서 팝업이나 레이어를 상상해보자. 사용자의 액션으로 인해 노출되는 이러한 요소들은 당장의 로딩에 필요하지 않은 리소스이다. 이러한 리소스는 리액트의 Suspense와 lazy를, 혹은 Next.js의 dynamic을 이용해 나중에 불러오게 할 수 있다.

2. 자바스크립트 코드 최소화

   - 사용되지 않는 코드 제거

     (크롬 개발자 도구 - 커버리지 - 기록 => 웹페이지 새로고침, 기록을 멈추고 싶은 경우 다시 기록 버튼 클릭)
     물론 여기에서 사용되지 않는 것으로 표시된 코드들이 필요 없는 코드이므로 삭제해야 한다는 것은 아니다. 이 중에는 사용자의 특정 이벤트에 따라 실행되는 코드, 예기치 못한 상황에서 실행될 코드 등 다양한 것들이 존재할 수 있다. 이러한 코드들은 당장에 급하지 않은 코드로 간주해 앞서 언급한 지연로딩 기법, 사용자가 필요로 하는 순간에 불러오거나 우선순위를 낮춰서 불러오는 것이 좋다.

   - 폴리필(polyfill)이란 브라우저에서 지원하지 않는 기능을 사용하기 위해 웹페이지에서 직접 구현하고 집어넣는 코드를 의미한다. 한 메서드에 들어가는 폴리필의 크기는 제법 크다. 따라서 폴리필을 집어넣기 전에는 반드시 폴리필이 필요한 환경인지 꼭 필요한 폴리필인지 먼저 확인해 봐야 한다.
     만약 바벨과 같은 도구를 사용하고 있다면 @babel/preset-env를 사용해 애플리케이션 코드에서 사용하고 잇는 내용만 폴리필에 담을 수 있다. Next.js의 SWC를 사용하고 있다면 이미 SWC 내부에 구현되어 있기 때문에 별도로 처리하지 않아도 될 것으로 보인다.

3. 타사 자바스크립트 코드 실행의 지연

   개발자가 구축한 애플리케이션에 꼭 개발자가 만든 스크립트만 들어가라는 법은 없다. Google Analytics나 Firebase와 같이 웹페이지의 통계 집계를 위해 제3자가 만든 타사 스크립트를 넣는 경우도 많다. 이러한 타사 자바스크립트 코드는 물론 통계를 구축하는데 중요한 부분이긴 하지만 이 코드의 실행으로 인해 메인 스레드가 잠시 점유되고, 이로 인해 사용자에게 안 졸은 반응성을 제공한다면 주객이 전도되는 상황을 맞닥뜨릴 것이다.

   이러한 타사 자바스크립트는 대부분 웹페이지 로드에 중요한 자원이 아니므로 `<script>`의 async와 defer를 이용해 지연 불러오기를 하는 것이 좋다.

   - `defer`: script에 defer 속성이 있다면 먼저 해당 스크립트를 다른 리소스와 함께 병렬로 다운로드한다. 다운로드하는 중에도 HTML 파싱 등의 메인 스레드 작업을 멈추지 않는다. 다운로드가 완료됐다 하더라도 이 스크립트 실행은 웹페이지가 완전히 로딩된 이후에 맨 마지막에 실행된다.
   - `async`: script에 async 속성이 있다면 마찬가지로 해당 스크립트를 다른 리소스와 함께 병렬로 다운로드한다. async 리소스의 다운로드가 완료되어 버리면 다른 리소스의 다운로드가 완료되는 것을 기다리지 않고 바로 실행한다. 따라서 async 리소스의 실행순서는 다운로드가 완료된 순서대로 실행된다.
   - `둘다 없는 경우`: script를 만나는 순간 다운로드가 우선되며, 다운로드가 완료되면 코드 실행이 우선된다. 다른 작업은 다운로드와 실행이 끝날 때까지 미뤄진다.

   스크립트는 async, defer로 갈수록 실행은 뒤로 미뤄지지만 성능은 좋아진다. 따라서 타사 자바스크립트는 가능하면 async를, 더 가능하다면 defer로 지연하는 것이 좋다. 만약 광고와 같이 실제 사용자의 뷰포트 위치에 따라 불러와야 하는 컴포넌트라면 Intersection Observer를 이용해 뷰포트에 들어오는 시점에 불러오는 것이 좋다.

### 누적 레이아웃 이동(CLS, Cumulative Layout Shift)

`페이지의 생명주기 동안 발생하는 모든 예기치 않은 이동에 대한 지표를 계산하는 것`을 바로 `누적 레이아웃 이동(CLS, Cumulative Layout Shift)`이라고 한다. 다른 지표와 마찬가지로 이 지표가 낮을수록, 즉 사용자가 겪는 예상치 못한 레이아웃 이동이 적을수록 더 좋은 웹사이트이다.
최초 렌더링 이후에 실행되는 useEffect가 많을수록, 그리고 이 useEffect가 렌더링에 영향을 미칠수록 이 누적 레이아웃 이동에 좋지 못한 점수를 받을 가능성이 커진다.

누적 레이아웃 이동은 사용자의 가시적인 콘텐츠에 영향을 미쳐야 하기 때문에 뷰포트 내부의 요소에 대해서만 측정하며, 뷰포트 밖의 요소에 대해서는 측정하지 않는다. 최초 렌더링이 시작한 위치에서 만약 레이아웃의 이동이 발생한다면 누적 레이아웃 이동 점수로 기록하게 된다. 또한 단순히 요소가 추가된다고 해서 무조건 누적 레이아웃 이동으로 간주되는 것은 아니다. 요소가 추가됐다 하더라도 다른 요소의 시작위치에 영향을 미치지 않았다면 레이아웃 이동으로 간주되지 않는다.

또한 사용자 액션으로 인해 발생한 레이아웃 이동은 점수에 포함하지 않는다. 당연하게도, 이는 사용자가 예상할 수 있는 레이아웃 이동이므로 점수에 포함시키지 않으며, 사용자가 아무런 동작을 하지 않았음에도 불구하고 레이아웃 이동이 발생하는 경우에는 점수에 포함된다.

이 점수를 계산할 때 포함되는 내용은 다음과 같다.

- 영향분율: 레이아웃 이동이 발생한 요소의 전체 높이와 뷰포트 높이의 비율을 의미한다. 예를 들어, 레이아웃 이동이 발생한 요소의 높이가 10이고, 예기치 않은 레이아웃 이동으로 인해 10만큼 내려갔다고 가정해보자. 이 경우 뷰포트의 높이가 100이라고 가정한다면 레이아웃 이동으로 인해 총 10+10만큼 뷰포트의 영향을 미쳤으므로 이 경우 영향분율은 0.2점이 된다.((10+10)/100 = 0.2)
- 거리분율: 레이아웃 이동이 발생한 요소가 뷰포트 대비 얼마나 이동했는지를 의미한다. 예를 들어, 예기치 않은 레이아웃 이동으로 인해 10만큼 내려갔고, 전체 뷰포트가 100이라면 0.1점이 된다(10/100).

이 두 가지 점수를 곱해서 최종 점수를 계산한다. 이 경우 최종 점수는 0.02점이 된다(0.2 \* 0.1).

누적 레이아웃 이동은 기기에 크기에 따라 점수가 다르게 측정될 수 있다. 누적 레이아웃 이동을 발생시키는 요소의 크기가 동일하다는 가정하에 뷰포트의 높이가 작을수록 조금 더 유리한 점수를 얻을 수 있다. 물론 이것은 어디까지나 기기에 있어서 약간의 차이일 뿐 누적 레이아웃 이동으로 인해 불편을 겪는다는 사실에는 변함이 없다.

**기준점수**

CLS의 경우 0.1 이하인 경우 좋음, 0.25 이하인 경우 보통이며 그 외에는 개선이 필요한 나쁜 점수로 보고된다.

**개선방안**

1. 삽입이 예상되는 요소를 위한 추가적인 공간 확보

   대부분의 큰 CLS는 클라이언트에서 삽입되는 동적인 요소로 인해 발생한다. 여기서는 동적으로 요소가 삽입되는 것 외에도 갑자기 요소의 크기가 바뀌거나, 뒤늦게 광고와 같은 타사 라이브러리가 브라우저에 로드되는 등의 작업 때문에 나타난다. 이러한 영향을 받는 것을 미연에 방지하기 위해서는 useEffect의 내부에서 요소에 영향을 미치는 작업, 특히 뷰포트 내부에서 노출될 확률이 높은 작업을 최소화하는 것이 좋다. useEffect 사용이 불가피하다면 useLayoutEffect 훅을 사용해 보는 것 또한 검토해 볼 만하다. useLayoutEffect는 동기적으로 발생해 브라우저의 페이팅 작업에 영향을 미치기 때문에 사용자에게 로딩이 오래 걸리는 것과 같이 보일 수 있다. 이는 CLS를 막으려다가 디른 모든 작업에 악영향을 끼칠 수 있으므로 신중하게 선택해야 한다.

   스켈레톤 UI처럼, 미리 무언가가 동적으로 뜰 것으로 예상되는 공간을 미리 확보해 두는 것이 좋은 방법이다. 레이아웃 이동을 막으면서 클라이언트 시점에 정해지는 콘텐츠를 안정적으로 보여줄 수 있으므로 대부분의 경우에 추천할 만한 방법이다. 그러나 이 역시도 해당 영역이 뜨지 않는 케이스가 있다면 CLS를 피하기는 어렵다.

   여기서 가장 좋은 방법은 SSR이다. 서버에서 이러한 동적인 요소의 유무를 사전에 판단해 클라이언트에 HTML을 미리 제공해 준다면 클라이언트에서는 이러한 고민을 할 필요 없이 깔끔하게 처리할 수 있다. 그러나 타사 스크립트에 의존해 처리하는 경우 SSR이 불가능할 수도 있으므로 이러한 경우에는 앞에서 언급한 방법을 사용해야 한다.

2. 폰트 로딩 최적화

   CLS와 폰트 간에 큰 관계가 없다고 생각할 수도 있지만 폰트 또한 레이아웃 이동을 일으키는 원인 중 하나이다. 폰트로 인해 발생할 수 있는 문제는 크게 두 가지이다.

   - `FOUT(flash of unstyled text)`: 문서에서 지정한 폰트가 보이지 않고 대체 기본 폰트로 보이고 있다가 뒤늦게 폰트가 적용되는 현상
   - `FOLI(flash of invisible text)`: HTML 문서에서 지정한 폰트가 보이지 않고, 기본 폰트도 없어서 텍스트가 없는 채로 있다가 뒤늦게 폰트가 로딩되면서 페이지에 렌더링되는 현상

   폰트는 각각 고유의 높이와 너비를 가지고 있다. 즉, 미처 지정한 폰트가 다운로드되기 전에 텍스트를 노출하려고 한다면 높이와 크기가 다른 기본 폰트를 기반으로 한 텍스트를 노출해서, 혹은 미처 텍스트를 노출하지 못해서 CLS가 발생할 수 있다. 따라서 사용자 기기의 기본 폰트 이외에 다른 폰트로 웹페이지를 보여주고 싶다면 다음과 같은 점을 유의해야 한다.

   - `<link>의 preload 사용`: `<link>` 요소의 rel=preload는 페이지에서 즉시 필요로 하는 리소스를 명시하는 기능이다. preload로 지정된 요소는 웹페이지의 생명주기에서 초기에 불러와야 하는 중요한 리소스로 간주되므로 브라우저는 리소스를 좀 더 빠르게 사용할 수 있도록 준비해 준다. 따라서 rel=preload로 스타일이나 폰트를 지정하면 페이지의 렌더링을 가로막거나 레이아웃을 방해할 가능성이 줄어든다.
   - `font-family: optional`

     폰트를 불러올 수 있는 방법은 크게 5가지로 나뉜다.

     - auto(기본값): 브라우저가 폰트를 불러오는 방법을 결정한다.
     - block: 폰트가 로딩되기 전까지 렌더링을 중단한다. (최대 3초) 웹 폰트의 로딩이 완료되면 비로소 폰트를 적용한다.
     - swap: 앞서 언급한 FOUT 방식이다. 우선 폴백 폰트로 글자를 렌더링한 다음, 웹 폰트의 로딩이 완료되면 웹 폰트를 적용한다.
     - fallback: 이 옵션을 적용하면 100ms간 텍스트가 보이지 않고, 그 이후에 폴백 폰트로 렌더링한다. 그리고 3초 안으로 폰트가 로딩된다면 해당 웹 폰트로 전환하고, 그렇지 않다면 폴백 폰트를 계속 사용한다.
     - optional: fallback과 매우 유사하다. 100ms간 텍스트가 보이지 않고, 폴백 폰트로 렌더링한다는 점은 동일하다. 그러나 0.1초 이내로 폰트가 다운로드되어 있거나 캐시되어 있지 않다면 폴백 폰트를 사용한다. 브라우저가 네트워크 상태를 파악해 일정 기간 폰트를 다운로드하지 못한다면 연결을 취소한다. 즉, 0.1초 내로 폰트가 다운로드되지 않으면 해당 폰트를 보여주지 않고, 이후에 해당 폰트 리소스를 사용할 때를 고려해 폰트를 다운로드하긴 하나 이마저도 네트워크 상황에 따라 취소될 수 있다는 점이다.

   CLS를 최소화하려면 폰트를 앞서 언급한 2가지 방법을 조합해 불러오는 것이 좋다. 요약하자면 최대한 중요한 폰트의 다운로드를 우선순위에 밀어넣고, 이 우선순위를 활용했음에도 빠르게 로딩하는데 실패했다면 다음을 기약하고 기본 폰트를 노출하는 것이다. 이는 사용자가 예기치 못하게 변경된 폰트로 인해 혼선을 겪는 것을 방지한다.

3. 적절한 이미지 크기 설정

   반응형 웹사이트란 사용자 기기의 크기에 따라 콘텐츠를 자연스럽게 노출할 수 있도록 다양한 요소를 콘텐츠 기기에 의존하도록 만든 웹사이트를 일컫는다.

   ```css
   img {
     width: 100%;
     height: auto;
   }
   ```

   위 코드의 뜻은 너비는 기기의 너비대로, 높이는 그 그림이 너비를 가지면 자동으로 비례해서(auto) 설정해 달라는 것을 의미한다.

   그러나 이 경우 CLS가 커지는 결과를 낳는다. 이것은 앞서 설정한 CSS 때문인데, 높이를 이미지가 완전히 다운로드되기 전까지는 알 수 없기 때문에 이미지의 높이를 높게 잡아 뒀다가 이미지가 완전히 로딩완료된 이후에 기기의 너비만큼 높이를 계산해서 마침내 이미지 크기만큼 자리 잡을 수 있게 된 것이다. height: auto 기법은 반응형 웹사이트에 최적화할 수 있는 기법으로, 기기의 너비가 어떻게 되든 원본 이미지의 가로세로 비율이 일정해 사용자에게 최적의 이미지를 보여줄 수 있다는 장점이 있다. 그러나 이미지의 높이를 명확하게 알지 못하기 때문에 레이아웃 이동이 크게 발생한다는 단점이 있다. 그럼 이 같은 문제를 해결하는 방법을 살펴보자.

   - `width, height 지정`: width, height를 지정하는 것이 가장 좋은 방법이다. 다음 예제와 같이 width:100%;height:auto;와 함께 width, height을 원하는 비율로 지정하면 브라우저가 이미지를 로딩하기 전에 적절한 가로세로 비율을 계산해 이미지가 표시되는 만큼 면적을 할당해 둔다. 이는 aspect-ratio 속성 덕분인데, 이 속성은 브라우저의 유저 에이전트 스타일시트(브라우저가 기본으로 제공하는 스타일)에 포함되어 있으며, 이미지의 가로세로 비율을 자동으로 맞춰주는 역할을 한다.

     ```javascript
     import './styles.css'; // width: 100%; height: auto;

     export default function App() {
       return <img src="./image.jpg" alt="이미지" width="1600" height="900" />;
     }
     ```

     이를 통해 예기치 못하게 이미지 로딩으로 인해 레이아웃이 이동하는 것을 막을 수 있다. 물론 width와 height에 실제 비율 값인 4, 3을 각각 입력해도 동일한 효과를 누릴 수 있다. 그러나 이 aspect-ratio를 지원하지 않는 오래된 브라우저나 CSS 로딩 실패 등의 시나리오를 고려한다면 이렇게 축약된 비율보다 실제 원하는 이미지 크기에 맞게 비율을 적어두는 것이 좋다.

   - 만약 사용자 뷰포트 너비에 맞춰 다른 이미지를 제공하는 경우, 즉 반응형 이미지를 사용하고 싶다면 srcset 속성을 사용하는 것이 좋다. 가로세로 비율이 똑같은, 그러나 크기가 다른 여러 개의 이미지를 미리 준비해 둔 다음 브라우저가 상황에 맞게 이미지를 사용할 수 있도록 준비하면 된다.

   ```html
   <!-- 반드시 ,로 구분되어 있어야 하며, 너비를 알려주는 w를 사용해야 한다 -->
   <img
     width="1000"
     height="1000"
     src="image-1000.jpg"
     srcset="image-1000.jpg 1000w, image-2000.jpg 2000w, image-3000.jpg 3000w"
     alt="이미지"
   />
   ```

### 핵심 웹 지표는 아니지만 성능 확인에 중요한 지표들

지금까지 핵심 웹 지표로 손꼽히는 3가지를 살펴봤다. 웹페이지의 성능을 확인할 수 있는 지표는 이 외에도 여러 가지가 있는데, 그중에서도 대표적인 몇 가지만 추가적으로 살펴보자.

**- 최초 바이트까지의 시간(Time To First Byte, TTFB)**

최초 바이트까지의 시간(Time To First Byte, TTFB)은 브라우저가 웹페이지의 첫 번째 바이트를 수신하는데 걸리는 시간을 의미한다. 즉, 페이지를 요청했을 때 요청이 완전히 완료되는 데 걸리는 시간을 측정하는 것이 아니라 최초의 응답이 오는 바이트까지가 얼마나 걸리는지를 측정하는 지표이다. 이 지표는 600ms 이상 걸릴 경우 개선이 필요한 것으로 간주된다.

이는 특히 SSR을 하고있는 애플리케이션에서 주의 깊게 살펴봐야 할 지표이다. 대체로 정적인 자원을 지속적으로 제공해 페이지를 렌더링하는 일반적인 SPA과는 달리 SSR은 최초 페이지를 만들기 위해 서버에서 어느정도 작업을 수행해야 하기 때문이다. 서버에서 첫 번째 HTML을 만들기 위해 해야 하는 작업이 많거나 느릴수록 최초 바이트까지의 시간이 길어지게 된다. 이는 사용자가 페이지를 요청했을 때 빈 화면이 뜨는 것을 의미하며 사용자 경험을 저해한다. 최초 바이트 시간을 개선하려면 다음과 같은 사항을 고려해야 한다.

- SSR을 수행하고 있다면

  - 로직을 최적화해 페이지를 최대한 빨리 준비시켜야 한다. 여기서 말하는 로직이란, Next.js를 예로 든다면 getServerSideProps 함수의 실행과 그 결과에 따른 정적 페이지 렌더링이 될 것이다. 페이지를 만드는 데 필요한 작업을 최소화하고, 페이지를 그리는 데 중요한 내용만 SSR에서 준비하는 등의 최적화가 필요하다.
  - SSR시에 API 호출이 필요하다면 이 API 호출 또한 최적화할 필요가 있다. 호출 횟수와 가져오는 정보의 크기를 최소화해서 최대한 API 응답의 속도를 빠르게 하고 크기를 가능한 한 줄여야 한다.

- 웹페이지의 주된 방문객의 국적을 파악해 최대한 해당 국적과 가깝게 서버를 위치시키는 것이 좋다. 응답해야 할 서버가 사용자와 가까울수록 응답 속도가 빨라지기 때문이다. 아마존 웹 서비스를 예로 들면, 한국 사용자에게는 us-east-_보다는 ap-_(아시아)가, 그리고 한국애서 가장 가까운 ap-northeast-2(서울)가 더 낫다.

- 리액트 SSR이라면 renderToNodeStream, renderToStaticNodeStream과 같은 스트리밍 API를 사용하는 것이 좋다. renderToString()은 완전히 HTML을 그리고 나서야 다운로드가 완료되지만 스트리밍을 사용할 경우 완성된 영역부터 조각조각 받을 수 있어 최초 바이트까지의 시간을 단축할 수 있다.

**- 최초 콘텐트풀 페인트(First Contentful Paint, FCP)**

최초 콘텐트풀 페인트(First Contentful Paint, FCP)란 페이지가 로드되기 시작한 시점부터 페이지 콘텐츠의 일부가 렌더링될 때까지의 시간을 측정한다. 조금 더 쉽게 설명하자면 웹페이지에 접속한 순간부터 페이지에 뭐라도 뜨기 시작한 시점까지의 시간을 의미한다. 여기서 의미하는 `뭐라도 뜨기 시작한`에 해당하는 요소는 텍스트, 이미지, svg 등을 의미한다.

일반적으로 최초 콘텐트풀 페인트는 1.8초 이내에 이뤄진다면 좋음, 3.0초 이내는 보통, 그 이후는 개선이 필요한 것으로 보고한다.

최초 콘텐트풀 페인트를 개선하려면 다음과 같은 사항을 고려해야 한다.

- `최초 바이트까지의 시간(TTFB)을 개선`: 일단 뭐라도 다운로드가 시작되야 렌더링을 할 수 있다. 렌더링을 최대한 빠르게하기 위해 최초 바이트까지의 시간을 단축해야 한다.
- `렌더링을 가로막는 리소스 최소화`: 자바스크립트나 CSS 같은 렌더링을 가로막는 리소스를 최소화하고, 렌더링을 방해하는 리소스를 비동기적으로 로드하도록 해야 한다. 렌더링이 최대한 빨리 이뤄져야 사용자에게 뭐라도 보여줄 수 있다.
- `Above the fold에 대한 최적화`: `Above the fold`란 신문에서 비롯된 용어로, 신문이 독자에게 제공됐을 때 가장 먼저 보이는 영역을 일컫는 말이다. 일반적으로 신문은 1페이지가 반으로 접혀서 보이지는 형태인데, 이 반으로 접혀져서 보이는 영역을 Above the fold라 한다. 이와 비슷하게 웹에서는 최초에 스크롤을 굳이 하지 않아도 보이는 영역을 Above the fold라고 한다. 이 영역은 최대한 사용자에게 빠르게 무언가를 보여줘야 하는 영역이므로 게으른 로딩을 하거나 스크립트(리액트의 useEffect)에 의존해 요소가 렌더링되는 것을 피해야 한다. 게으른 로딩이나 스크립트에 의존하는 것은 모두 최초 콘텐트풀 페인트에 도움이 되지 않는다.
- `페이지 리다이렉트 최소화`: 만약 특정 페이지에서 다른 페이지로 리다이렉트를 해야 한다면 그만큼 사용자에게 무언가를 보여줄 수 있는 시간이 지연되기 마련이다. 리다이렉트는 없거나 최소한으로 유지해야 한다.
- `DOM 크기 최소화`: HTML의 크기가 크다면, 즉 DOM이 복잡하고 크다면 그만큼 렌더링되는데 시간이 오래 걸린다. 구글의 기준에 따르면 전체 DOM 노드는 1500개 미만으로, 깊이는 32단계 정도까지만, 그리고 부모 노드는 자식 노드를 60개 정도만 가지고 있어야 한다. 이 이상으로 크고 복잡해지면 브라우저가 이를 파악해 렌더링하는데 시간이 오래 걸리게 된다. 만약 웹페이지를 소스보기로 확인해 봤을 때 DOM이 필요 이상으로 많고 복잡하다면 이를 줄일 수 있는 방법을 고민해 봐야한다.

일반적으로 웹페이지를 개발하다 보면 대부분 기능을 얼마나 완성했는가?, 버그는 얼마나 적은가? 정도에만 치중하기 때문에 성능에 대해서는 깊게 고민해 볼 시간이 많이 부족한 것은 사실이다. 대부분 웹 애플리케이션의 완성에만 초점을 맞추고 있고, 그 이후에 또다시 개발해야 할 페이지가 기다리고 있어 실무에서 약간의 성능 개선을 위한 시간조차 할애하기 어렵다. 설령 그럴 시간이 있더라도 고민할 시간 자체도 여유 있게 배정받지 못하기 때문에 성능에 대해 심도 있게 탐구해 보는 것 또한 쉽지 않다.

하지만 개발자라면 성능 또한 완성도 만큼이나 중요하게 살펴봐야 한다. 아무리 좋은 콘텐츠가 웹페이지에서 제공되고 있다 하더라도 사용자의 환경은 생각보다 열악하며, 속도는 느리고, 마지막으로 인내심도 많지 않다.

웹페이지의 성능을 개선하기로 마음먹었다면 앞서 언급한 3가지 지표와 추가로 언급한 2가지 지표 정도만 살펴본다면 충분히 사용자에게 좋은 경험을 안겨줄 수 있다. 그리고 성능 개선을 생각보다 긴 싸움이다. 앞서 언급한 지표를 돌이켜 살펴보면 0.1~0.2초 차이만으로도 사용자에게 큰 차이를 느끼게 해줄 수 있다는 것을 알 수 있을 것이다. 그러나 이 0.1초를 개선하는 것이 생각보다 쉽지 않다. 한두 가지를 개선했다 하더라도 체감될 만큼 큰 차이가 없을 수도 있다. 그러나 이러한 개선점이 하나둘씩 모이다 보면 분명 더 나은 서비스를 만들 수 있게된다.
