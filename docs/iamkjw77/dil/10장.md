## 10. 리액트 17과 18의 변경 사항 살펴보기

이번에는 리액트 17과 18 버전에 어떠한 변화가 있었는지 살펴보자. 17 버전과 18 버전으로 두 버전을 나눈 이유는 현재 가장 널리 사용되고 있는 리액트 버전이 리액트 16이기 때문에 그 이후에 나온 두 버전이 상대적으로 덜 설치되어 사용 중이기 때문이다. 아마도 대부분의 리액트 프로젝트들이 최소한 훅과 함수 컴포넌트를 사용하기 위해 16.8 버전을 기반으로 개발됐고, 이것이 고착화되어 더 이상 버전 업하지 않고 운영되고 있을 것이다.

### 리액트 17 버전 살펴보기

먼저 리액트 17 버전은 16 버전과 다르게 새롭게 추가된 기능이 없으며 호환성이 깨지는 변경사항, 즉 기존에 사용하던 코드의 수정을 필요로 하는 변경사항을 최소화했다는 점에서 가장 큰 특징으로 꼽는다. 리액트 팀에서 이야기한 바로는, 10만 개 이상의 컴포넌트 중 호환성이 깨지는 변경사항에 영향을 받은 것은 20개 미만으로, 대부분의 애플리케이션이 별다른 문제없이 16버전에서 17버전으로 업그레이드할 수 있을 것으로 내다봤다. 그만큼 16 버전에서 17 버전으로의 버전 업은 큰 부담없이 할 수 있는 작업이라 볼 수 있다.

### 리액트의 점진적인 업그레이드

리액트 16에서 17로의 업데이트는 기존 버전인 16에서 더 이상 호환되지 않는 API가 있거나 새로운 리액트 17을 사용하는데 있어 이전과 작동방식이 달라질 수 있기 때문에 단행한 주 버전 업데이트이다. 반면 수 버전 업데이트인 16.7에서 16.8로의 버전 업은 신규 기능 추가(리액트 훅)로 인해 발생한 것이다.

리액트도 유의적 버전(semantic version)을 기반으로 업데이트를 거치고 있었다. 즉, 새로운 주 버전이 릴리즈되면 이전 버전에서의 API 제공을 완전히 중단해 버리고, 전체 애플리케이션을 새롭게 업그레이드하기를 요구하고 있었다. 이는 새롭게 API를 작성하는 리액트 개발팀 입장에서는 굉장히 편리하면서도 유용한 전략이었지만 오래된 코드 베이스를 기반으로 돌아가는 실제 웹 애플리케이션에는 그다지 좋지 못한 일이다. 새로운 리액트 주 버전이 릴리즈됐다고 가정해보자. 이제 새로운 버전이 릴리즈되면 어떠한 API 수정이 있는지 일일리 확인해서 적용해야 한다. 또 지원을 중단한 API는 또 어떻게 고쳐야 할지도 파악해야 한다. 따라서 레거시 애플리케이션을 관리하는 개발자는 항상 선택의 기로에 놓여 있었다. 전체 웹 서비스가 새로운 버전으로 완전히 넘어가버리거나, 계속 현재(과거 버전)에 머물러 있어야 한다.

그러나 이제 리액트 17 버전부터는 점진적인 업그레이드가 가능해진다. 리액트 17을 설치하고, 이후에 리액트 18로 업데이트하는 상황을 가정해보자. 리액트 18에서 제공하는 대부분의 기능을 사용할 수도 있지만 일부 기능에 대헤서는 리액트 17에 머물러 있는 것이 가능해진다. 즉, 전체 애플리케이션 트리는 리액트 17이지만 일부 트리와 컴포넌트에 대해서만 리액트 18을 선택하는 점진적인 버전 업이 가능해진다. 물론 이것은 이상적인 방법이 아닐 수는 있다. 버전이 서로 다른 리액트가 두 개 존재해야 하는 것이므로 한 개가 있을 때보다는 당연히 관리 지점이 많아진다. 그러나 리액트 버전을 올리기에는 너무 부담이 되는 큰 에플리케이션의 경우에는 충분히 고려해 볼 만한 선택지가 될 수 있다.

이러한 점진적인 업그레이드를 지원하기 위한 리액트 일부 컴포넌트 변경이 리액트 17 업데이트의 주요 변경사항 중 하나이다. 향후 업데이트가 부담된다 하더라도 17 버전부터 제공되는 점진적인 업그레이드를 사용하기 위해서라도 17 버전 업데이트를 고려해 봄 직하다. 일종의 `업데이트를 위한 업데이트`라 볼 수 있다.

그렇다면 여기서 언급한 '한 애플리케이션 내에 여러 버전의 리액트가 존재하는 시나리오'는 어떤 것일까?

- [깃허브 소스코드](https://github.com/wikibook/react-deep-dive-example/tree/main/chapter10/react-gradual-demo)

위 예제는 크게 리액트 17로 구성된 애플리케이션과 리액트 16으로 구성된 애플리케이션으로 나눠서 살펴볼 수 있다. 리액트 17 애플리케이션은 내부에서 리액트 16을 게으르게(lazy) 불러온다. 불러오는 과정에서 리액트 16을 위한 별도의 루트 요소를 만들고, 여기에 불러온 리액트 16 모듈을 렌더링하는 구조로 구성되어 있다. 이렇게 불러온 결과, 서로 렌더링하는 과정에서 버전의 불일치로 인한 에러도 발생하지 않고 하나의 웹사이트에서 두 개의 리액트가 존재하게 되었다. 그리고 이 두 개의 리액트 루트는 단 하나만 존재하는 컴포넌트와 훅을 서로 불러와서 사용할 수 있다. 즉, 리액트 16과 17 버전을 모두 지원하는 컴포넌트나 훅이라면 버전이 다른 두 리액트에서도 무리없이 사용가능히다. Context도 마찬가지로 ThemeContext의 값을 리액트 16과 17이 모두 동일하게 사용하고 있으며, 이 Context가 제공하는 값을 마찬가지로 동일하게 사용할 수 있음을 알 수 있다.

리액트 팀에서는 이를 어디까지나 한꺼번에 업그레이드가 불가능한 상태에서만 차선책으로, 여전히 리액트 버전을 한꺼번에 업데이트하는 게 복잡성 감소 측면에서 좋다고 언급했다.

### 이벤트 위임 방식의 변경

이벤트 위임 방식의 변화를 이해하려면 먼저 리액트에서 이벤트가 어떻게 추가되는지를 이해해야 한다.

```javascript
import { useEffect, useRef } from 'react';

function App() {
  const buttonRef = (useRef < HTMLButtonElement) | (null > null);

  useEffect(() => {
    if (buttonRef.current) {
      buttonRef.current.addEventListener('click', function clcik() {
        alert('Button clicked!');
      });
    }
  }, []);

  function hello() {
    alert('hello');
  }

  return (
    <>
      <button onClick={hello}>리액트 버튼</button>
      <button ref={buttonRef}>그냥 버튼</button>
    </>
  );
}

export default App;
```

먼저 '리액트 버튼'은 일반적으로 리액트 애플리케이션에서 DOM에 이벤트를 추가하는 방식으로 onclick 이벤트를 추가했다. 반면 '그냥 버튼'의 이벤트는 직접 DOM을 참조해서 가져온 다음, DOM에 onclick에 직접 함수를 추가하는 고전적인 이벤트 핸들러 추가 방식을 사용했다. 이 두 방식이 실제 웹에서 어떻게 다른지 살펴보자.

![그냥 버튼](../asset/default_button.png)

![리액트 버튼](../asset/react_button.png)

리액트 버튼에 부착한 이벤트는 `<button>`의 onClick 이벤트에 noop이라는 이벤트 핸들러가 추가되어 있는 것을 볼 수 있다. 해당 버튼의 click에는 noop이라고 하는 함수가 달려있고, 이 noop은 문자 그대로(no operation) 아무런 일도 하지 않는 것을 볼 수 있다. 그러나 두 버튼 모두 동일하게 작동한다. 그렇다면 리액트에서는 이벤트를 어떻게 처리할까?

리액트는 이벤트 핸들러를 해당 이벤트 핸들러를 추가한 각각의 DOM 요소에 부탁하는 것이 아니라, 이벤트 타입(click, change)당 하나의 핸들러를 루트에 부착한다. 이를 이벤트 위임이라고 한다. 이벤트 위임을 이해하려면 이벤트가 어떤 단계로 구성되어 있는지 먼저 알아야 한다.

1. `캡쳐(capture)`: 이벤트 핸들러가 트리 최상단 요소에서부터 시작해서 실제 이벤트가 발생한 타깃 요소까지 내려가는 것을 의미한다.
2. `타깃(target)`: 이벤트 핸들러가 타깃 노드에 도달하는 단계이다. 이 단계에서 이벤트가 호출된다.
3. `버블링(bubbling)`: 이벤트가 발생한 요소에서부터 시작해 최상위 요소까지 다시 올라간다.

이벤트 위임이란 이러한 이벤트 단계의 원리를 활용해 이벤트를 상위 컴포넌트에만 붙이는 것을 의미한다.

리액트는 최초 릴리즈부터 이러한 이벤트 위임을 적극적으로 사용했다. 리액트는 이벤트 핸들러를 각 요소가 아닌 document에 연결해서 이벤트를 좀 더 효율적으로 관리한다. 그러나 이러한 이벤트 위임이 리액트 16 버전까지는 모두 document에서 수행되고 있었다. 그런데 리액트 17부터는 이러한 이벤트 위임이 모두 document가 아닌 리액트 컴포넌트 최상단 트리, 즉 루트 요소로 바뀌었다.

그 이유는 앞서 이야기한 점진적인 업그레이드 지원, 그리고 다른 바닐라 자바스크립트 코드 또는 jQuery 등이 혼재되어 있는 경우 혼란을 방지하기 위해서이다. 점진적인 업그레이드 지원이 활성화됐고, 그 덕분에 여러 리액트 버전이 한 서비스에 공존한다고 가정해보자. 마냑 기존 리액트 16 방식대로 모든 이벤트가 document에 달려있으면 어떻게 될까?

```html
<html>
  <body>
    <div id="React-16-14">
      <div id="React-16-8"></div>
    </div>
  </body>
</html>
```

리액트 16 이벤트 위임 원리에 따라 모든 이벤트는 docuemnt에 부착된다. 만약 이 상황에서 React-16-8 컴포넌트가 이벤트 전파를 막는 e.stopPropagation을 실행하면 어떻게 될까? 이미 모든 이벤트는 docuemnt로 올라가 있는 상태이기 떄문에 stopPropagation을 실행한다 하더라도 이미 모든 이벤트는 docuemnt에 있으므로 document의 이벤트 전파는 막을 수 없게된다. 따라서 e.stopPropagation() 실행이 무색하게 바깥에 있는 React-16-14에도 이 이벤트를 전달받게 될 것이다. 이처럼 서로 다른 리액트 버전에서 발생할 수 있는 문제를 해결하기 위해 이벤트 위임의 대상을 document에서 컴포넌트의 최상위로 변경했다. 이렇게 수정하게 되면 각 이벤트는 해당 리엑트 컴포넌트 트리 수준으로 격리되므로 이벤트 버블링으로 인한 혼선을 방지할 수 있다.

이러한 문제는 리액트끼리만 발생하는 것이 아니다. 한 애플리케이션에는 jQuery 같은 다른 라이브러리와 리액트 16 등이 혼재되어 있는 상황인 경우에도 이와 동일한 문제가 충분히 발생할 수 있다.

이러한 document로 이벤트를 위임하는 특성 떄문에 발생하는 또 한 가지 재미있는 일이 있는데, 리액트 16버전에서 document와 리액트가 렌더링되는 루트 컴포넌트 사이에서 이벤트 코드를 막는 코드를 추가하면 리액트의 모든 핸들러가 작동하지 않도록 막을 수 있었다.

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1 shink-to-fit=no"
    />
  </head>
  <body>
    <div id="main">
      <div id="root"></div>
    </div>
  </body>
  <script>
    document.getElementById('main').addEventListener(
      'click',
      function (e) {
        e.stopPropagation();
      },
      false
    );
  </script>
</html>
```

이제 이러한 작동 방식 또한 이벤트 위임 방식이 변경되면서 사라지게 됐다.

![리액트 이벤트](../asset/react_event.png)

이러한 변경으로 인해 코드에서 확인해 볼 것이 하나 생겼다. 만약 코드에 document.addEventListener를 활용해 리액트의 모든 이벤트를 document에서 확인하는 코드가 있다면 여기까지 이벤트가 전파되지 않는 경우도 존재할 수 있으므로 꼭 확인해 봐야한다.

```javascript
import { MouseEvent, useEffect } from 'react';

function App() {
  useEffect(() => {
    document.addEventListener('click', (e) => {
      console.log('이벤트가 document까지 올라옴');
    });
  }, []);

  function hello(e: MouseEvent<HTMLButtonElement>) {
    e.stopPropagation();
    alert('Hello');
  }

  return <button onClick={hello}>리액트 버튼</button>;
}
```

이 코드는 리액트 16과 17에서 다르게 작동한다. 리액트 16에서는 모든 이벤트가 document에 달려 있으므로 stopPropagation이 의미가 없지만 리액트 17의 경우에는 컴포넌트 루트에 달려 있으므로 document에 부착한 console 이벤트를 볼 수 없을 것이다. 리액트의 이러한 이벤트 작동 방식을 기반으로 작성한 코드가 있다면 리액트 17을 적용하면서 함께 반드시 수정해야 한다.

### import React from 'react'가 더 이상 필요없다. 새로운 JSX transform

JSX는 브라우저가 이해할 수 있는 코드가 아니므로 바벨이나 타입스크립트를 활용해 JSX를 실행하기 위해 일반적인 자바스크립트로 변환하는 과정이 꼭 필요하다. 일반적으로 create-react-app을 활용해서 개발하면 이러한 작업을 따로 처리한 경험이 없겠지만 대부분의 경우에는 이 변환 작업이 개발자에게 보이지 않는 리액트 단에서 이뤄지고 있었다. 16버전까지는 이러한 JSX 변환을 사용하기 위해 코드 내에서 React를 사용하는 구문이 없더라도 import React from 'react'가 필요했고, 이 코드가 없다면 에러가 발생했다.

그러나 리액트 17부터 바벨과 협력해 이러한 import 구문 없이도 JSX를 변환할 수 있게 됐다. 이 새로운 변환식은 import React가 필요 없다는 장점 외에도, 불필요한 import 구문을 삭제해 번들링 크기를 약간 줄일 수 있고, 컴포넌트 작성을 더욱 간결하게 해준다.

```javascript
// 구버전 JSX 변환(리액트 16)
const Component = {
  <div>
    <span>hello world</span>
  </div>
}

// React.createElement를 수행할 때 import React from 'react'가 팔요하다
var Component = React.createElement(
  'div',
  null,
  React.createElement('span', null, 'hello world')
)
```

```javascript
// 리액트 17
'use strict';

var _jsxRuntime = require('react/jsx-runtime');

var Component = (0, _jsxRuntime.jsx)('div', {
  children: (0, _jsxRuntime.jsx)('span', {
    children: 'hello world',
  }),
});
```

React.createElement가 사라진 것도 눈에 띄지만 한 가지 더 주목해 볼 만한 것은 바로 require() 구문이다. 이제 JSX 변환에 필요한 모듈인 react/jsx-runtime을 불러오는 require 구문도 같이 추가되므로 import React from 'react'를 작성하지 않아도 된다.

기존 코드에서 굳이 import React를 삭제하지 않고 둬도 상관없지만 번들링 사이즈를 조금이라도 줄이고 싶다면 react-codemod를 사용해 모두 삭제할 수 있다.

```shell
npx react-codemod update-react-imports
```

따라서 특별한 이유가 없다면 import React를 지우고, tsconfig.json의 jsx를 react-jsx 등으로 변경하여 이점을 모두 누리도록 하자.

### 그 밖에 주요 변경사항

**이벤트 풀링 제거**

과거 이벤트 16에서는 이른바 이벤트 풀링이라 불리는 기능이 있었다. 리액트에는 이벤트를 처리하기 위한 SyntheticEvent라는 이벤트가 있는데, 이 이벤트는 브라우저의 기본 이벤트를 한 번 더 감싼 이벤트 객체이다. 리액트는 이렇게 브라우저 기본 이벤트가 아닌 한번 래핑한 이벤트를 사용하기 때문에 이벤트가 발생할 때마다 이 이벤트를 새로 만들어야 했고, 그 과정에서 항상 새로 이벤트를 만들 때마다 메모리 할당 작업이 일어날 수 밖에 없다. 또한 메모리 누수를 방지하기 위해 이렇게 만든 이벤트를 주기적으로 해제해야 하는 번거로움도 있다. 여기서 이벤트 풀링이란 SyntheticEvent 풀을 만들어서 이벤트가 발생할 때마다 가져오는 것을 의미한다.

즉, 이벤트 풀링 시스템에서는 다음과 같이 이벤트가 발생한다.

1. 이벤트 핸들러가 이벤트를 발생시킨다.
2. 합성 이벤트 풀에서 합성 이벤트 객체에 대한 참조를 가져온다.
3. 이 이벤트 정보를 합성 이벤트 객체에 넣어준다.
4. 유저가 지정한 이벤트 리스너가 실행된다.
5. 이벤트 객체가 초기화되고 다시 이벤트 풀로 돌아간다.

언뜻 보기에는 이벤트 풀에 있는 합성 이벤트를 반복적으로 사용할 수 있어서 효과적으로 보이지만 풀에서 이벤트를 받아오고, 이벤트가 종료되자마자 다시 초기화하는(null로 변경하는) 방식은 분명 사용하는 쪽에서는 직관적이지 않았다.

```javascript
// error
// Cannot read properties of null (reading 'value')

export default function App() {
  const [value, setValue] = useState('');

  function handleChange(e: ChangeEvent<HTMLInputElement>) {
    setValue(() => {
      return e.target.value;
    });
  }

  return <input onChange={handleChange} value={value} />;
}
```

리액트 16 이하 버전에서는 이벤트 풀링 방식을 통해 서로 다른 이벤트 간에 이벤트 객체를 재사용하고, 그리고 이 재사용하는 사이에 모든 이벤트 필드를 null로 변경하기 때문에 위와 같은 에러가 발생한다. 좀 더 쉽게 표현하자면 한번 이벤트 핸들러를 호출한 SyntheticEvent는 이후 재사용을 위해 null로 초기화된다. 따라서 비동기 코드 내부에서 SyntheticEvent인 e에 접근하면 이미 사용되고 초기화된 이후이기 때문에 null만 얻게 된다. 비동기 코드 내부에서 이 합성 이벤트 e에 접근하기 위해서는 추가적인 작업인 e.persist() 같은 처리가 필요했다.

리액트 17부터는 매 이벤트마다 새로운 SyntheticEvent 객체를 생성한다.

```javascript
export default function App() {
  const [value, setValue] = useState('');

  function handleChange(e: ChangeEvent<HTMLInputElement>) {
    e.persist();
    setValue(() => {
      return e.target.value;
    });
  }

  return <input onChange={handleChange} value={value} />;
}
```

비동기 코드로 이벤트 핸들러에 접근하기 위해서는 이러한 방식으로 별도 메모리 공간에 합성 이벤트 객체를 할당해야 한다는 점, 그리고 모던 브라우저에서는 이와 같은 방식으로 성능 향상에 크게 도움이 안 된다는 점 때문에 이러한 이벤트 폴링 개념이 사라졌다. 그리고 모던 브라우저에서는 이러한 이벤트 처리에 대한 성능이 많이 개선됐기 때문에 이러한 처리는 더욱 의미가 퇴색하게 되었다. 따라서 이벤트 핸들러 내부에서 이벤트 객체에 접근할 때 비동기든 동기든 상관없이 일관적으로 코딩할 수 있게됐다.

**useEffect 클린업 함수의 비동기 실행**

먼저 리액트의 useEffect에 있는 클린업 함수는 리액트 16 버전까지는 동기적으로 처리됐다. 동기적으로 실행됐기 때문에 이 클린업 함수가 완료되기 전까지는 다른 작업을 방해하므로 불필요한 성능 저하로 이어지는 문제가 존재했다. 그러나 리액트 17 버전부터는 화면이 완전히 업데이트된 이후에 클린업 함수가 비동기적으로 실행된다. 조금 더 정확히 이야기하면 클린업 함수는 컴포넌트 커밋 단계가 완료될 때까지 지연된다. 즉, 화면이 업데이트가 완전히 끝난 이후에 실행되도록 바뀌었으며, 이로써 약간의 성능적인 이점을 볼 수 있게 됐다.

리액트 16에서는 클린업 함수가 'update'(Profile에서 update는 리렌더링을 의미한다) 이전에 실행됐지만 리액트 17에서는 리랜더링이 일어난 뒤에 실행되어 화면에 업데이트가 반영되는 시간인 commitTime이 조금이나마 빨라진다.

**컴포넌트의 undefined 반환에 대한 일괄적인 처리**

리액트 16과 17 버전은 컴포넌트 내부에서 undefined를 반환하면 오류가 발생한다. 이는 의도치 않게 잘못된 반환으로 인한 실수를 방지하기 위해서였다.

```javascript
export default function App() {
  // 반환되는게 없으므로 undefined가 반환됨
}
```

그러나 리액트 16에서 forwardRef나 memo에서 undefined를 반환하는 경우에는 별다른 에러가 발생하지 않는 문제가 있었다. 그러나 리액트 17부터는 에러가 정상적으로 발생한다. 참고로 리액트 18부터는 undefined를 반환해도 에러가 발생하지 않는다.
