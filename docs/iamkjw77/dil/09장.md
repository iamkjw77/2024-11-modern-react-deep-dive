## 09. 모던 리액트 개발도구로 개발 및 배포환경 구축하기

### Next.js로 리액트 개발환경 구축하기

`create-react-app`과 `create-next-app`은 각각 리액트 애플리케이션과 Next.js 애플리케이션을 손쉽게 만들기 위한 CLI 도구이다. 이 두 가지는 모두 애플리케이션을 빠르게 만들기 위해 선택할 수 있는 탁월한 도구이지만 애플리케이션 구축에 필요한 대부분의 작업을 대신해 주기 때문에 프로젝트 구조를 공부하고 이해하는 데는 크게 도움이 되지 못한다. 개발자가 직접 만든 애플리케이션을 이해하려면 package.json부터 시작해서 하나씩 필요한 파일을 직접 설정해봐야 한다.

### create-next-app 없이 하나씩 구축하기

- [완성 코드](https://github.com/wikibook/react-deep-dive-example/tree/main/chapter9/zero-to-next)

1. 모든 Node.js 프로젝트와 마찬가지로 가장 먼저 할 일은 package.json을 만드는 것이다. package.json 파일을 직접 만들 수도 있지만, npm init을 실행하면 package.json을 만드는 CLI를 실행할 수 있다.

2. Next.js 프로젝트를 실행하는 데 필요한 핵심 라이브러리인 react, react-dom, next를 설치하자.

3. 그리고 devDependencies에 필요한 패키지를 설치하자. 여기서는 typescript, 타입스크립트 내부에서 리액트 타입 지원에 필요한 @types/react, @types/react-dom, 마찬가지로 Node.js의 타입을 사용하기 위한 @types/node, 그리고 ESLint 사용에 필요한 eslint, eslint-config-next를 설치한다.

### tsconfig.json 작성하기

npm 설정을 package.json에 하는 것처럼 타입스크립트 설정은 tsconfig.json에 기록한다.

```json
{
  "$schema": "https://json.schemastore.org/tsconfig.json"
}
```

위와 같이 JSON 최상단에 `$schema` 키와 위와 같은 값을 넣어보자. `$schema`는 schemaStore에서 제공해주는 정보로, 해당 JSON 파일이 무엇을 의미하는지, 또 어떤 키와 어떤 값이 들어갈 수 있는지 알려주는 도구이다. `$schema`에 올바른 값이 설정되어 있다면 VS Code나 웹스톰 같은 IDE에서 자동완성이 가능해진다.

이 밖에도 .eslintrc, .prettierrc와 같이 JSON 방식으로 설정을 작성하는 라이브러리가 schemastore에 해당 내용을 제공하고 있다면 더욱 편리하게 JSON 설정을 작성할 수 있다.

```json
{
  "$schema": "https://json.schemastore.org/tsconfig.json",
  // ts를 js로 컴파일할 때 사용하는 옵션
  "compilerOptions": {
    // ts가 변환을 목표로 하는 언어의 버전(폴리필 지원X)
    "target": "es5",
    // dom은 ts환경에서 window, document 등 브라우저 위주의 API에 대한 명세를 사용할 수 있게하기 위함
    // esnext를 추가하면 target은 es5라 할지라도 신규기능에 대한 API 정보를 확인할 수 있게되어 에러발생X(폴리필 준비가 되어있는 상태)
    "lib": ["dom", "dom.iterable", "esnext"],
    // ts가 js 파일 또한 컴파일할지를 결정한다. 주로 js 프로젝트에서 ts로 전환하는 과정에서 .js와 .ts가 혼재됐을 때 사용하는 옵션
    "allowJs": false,
    // 라이브러리에서 제공하는 d.ts(ts 제공하는 타입에 대한 정보를 담고 있는 파일)에 대한 검사 여부를 결정한다. true이면 검사X
    // false인 경우 전체적인 프로젝트 컴파일 시간이 길어지므로 일반적으로 꺼놓은 경우가 많다
    "skipLibCheck": true,
    // ts가 컴파일러의 엄격모드를 제어한다. 켜두는 것을 권장
    "strict": true,
    // true이면 파일이름의 대소문자를 구분하도록 강제한다. 예를 들어 이 옵션이 켜져있으면 Signup과 SignUp은 서로 다른 파일로 간주한다
    "forceConsistentCasingInFileNames": true,
    // 컴파일을 하지않고, 타입 체크만 한다.
    // ts를 사용함에도 이 옵션을 켜두는 이유는 Next.js는 swc가 ts파일을 컴파일하므로 굳이 ts가 js로 컴파일할 필요가 없다
    // 이 옵션이 켜져있으면 ts는 단순히 타입검사만 한다.
    "noEmit": true,
    // CommonJs 방식으로 보낸 모듈을 ES모듈 방식의 import로 가져올 수 있게 해준다
    "esModuleInterop": true,
    // 모듈 시스템을 설정, commonjs(require 사용), esnext(import 사용)
    "module": "esnext",
    // 모듈을 해석하는 방식설정, node는 node_modules를 기준으로 모듈을 해석, classic은 tsconfig.json이 있는 디렉터리 기준으로 모듈해석
    "moduleResolution": "node",
    // JSON 파일을 import할 수 있게 해준다. 이 옵션을 켜두면 allowJS 옵션도 자동으로 켜진다
    "resolveJsonModule": true,
    // ts 컴파일러는 파일에 import나 export가 없다면 단순 스크립트 파일로 인식해 이러한 파일이 생성되지 않도록 막는다
    // 즉, 단순히 다른 모듈 시스템과 연계되지 않고 단독으로 있는 파일의 생성을 막기 위한 옵션
    "isolatedModules": true,
    // .tsx 파일 내부에 있는 JSX를 어떻게 컴파일할지 설정한다
    // preserve(변환하지 않고 그대로 유지), swc가 JSX 또한 변환해 주기때문에 preserve로 설정
    "jsx": "preserve",
    // 이 옵션이 활성화되면 ts는 마지막 컴파일 정보를 .tsbuildinfo 파일 형태로 만들어 디스크에 저장한다
    // 이렇게 컴파일 정보를 별도파일에 저장해두면 이후에 다시 컴퍼일러가 호출됐을 때 해당 정보를 활용해
    // 가장 비용이 적게 드는 방식으로 컴파일을 수행해 컴파일이 더 빨리지는 효과를 누릴 수 있다
    "incremental": true,
    // 모듈을 찾을 때 기준이 되는 디렉타리 지정
    "baseUrl": "src",
    // 경로에 별칭(alias)을 지정
    // @는 자제하는 것이 좋다. @angular, @types와 같이 스코프 패키지에 널리 사용되기 때문에 네이밍에 충돌할 여지가 있다
    "paths": {
      "#pages/*": ["pages/*"],
      "#hooks/*": ["hooks/*"],
      "#types/*": ["types/*"],
      "#components/*": ["components/*"],
      "#utils/*": ["utils/*"]
    }
  },
  // ts 컴파일 대상에서 포함시킬 파일 목록, next-env.d.ts는 Next.js에서 자동으로 생성하는 파일이다
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
  // ts 컴파일 대상에서 제외시킬 파일 목록
  "exclude": ["node_modules"]
}
```

이 밖에도 다양한 옵션이 있는데, [여기서](https://www.typescriptlang.org/tsconfig) 사용가능한 옵션을 모두 확인할 수 있다.

### next.config.js 작성하기

타입스크립트를 위한 tsconfig.json을 만들었다면 이번에는 Next.js 설정을 위한 next.config.js를 만들 차례이다.

```javascript
import type { NextConfig } from 'next';

const nextConfig: NextConfig = {
  // 리액트 엄격모드 활성화
  reactStrictMode: true,
  // 일반적으로 보안 취약점으로 취급되는 X-Powered-By 헤더를 제거
  poweredByHeader: false,
  // 빌드 시에 eslint를 무시한다. 일반적으로 eslint는 Next.js 빌드 시에 ESlint도 같이 수행하는데,
  // 여기서는 true로 설정해 빌드 시애 ESLint를 수행하지 않게 했다
  // 이후에 ESLint는 CI 과정에서 별도로 작동하게 만들어 빌드를 더욱 빠르게 만들 것이다
  eslint: {
    ignoreDuringBuilds: true,
  },
};

export default nextConfig;
```

next.config.js가 제공하는 설정 파일은 버전별로 조금씩 다르다. 본인이 사용하고 있는 next.config.js에서 사용가능한 옵션을 확인하고 싶다면 [깃허브 저장소](https://github.com/vercel/next.js)를 방문해 확인할 수 있다. 깃허브 저장소에서 본인이 사용 중인 버전의 태그를 찾아 들어가면 사용가능한 옵션을 확인할 수 있다.

![next.js 버전별 tag](../asset/next_js_tag.png)

### ESLint와 Prettier 설정하기

앞서 프로젝트 단계에서 eslint와 eslint-config-next를 설치했지만 이것만으로는 부족하다. eslint-config-next는 단순히 코드에 있을 잠재적인 문제를 확인할 뿐, 띄어쓰기나 줄바꿈과 같이 코드의 스타일링을 정의해 주지는 않는다. 코드 스타일링 등 eslint-config-next가 해주지 않는 일반적인 ESLint 작업을 수행하기 위해 가장 설치 및 설정이 쉬운 `@titicaca/eslint-config-triple`을 설치해 사용한다.

`@titicaca/eslint-config-triple` 설정은 [깃허브 저장소](https://github.com/titicacadev/triple-config-kit)에 일목요연하게 정리되어 있다. 한 가지 유념해야 할 것은 `eslint-config-next`와 `eslint-config-triple`이 함께 작동하게 하려면 다음과 같은 별도의 설정이 필요하다.

```js
// .eslintrc.js
module.exports = {
  extends: ['next/core-web-vitals'],
};
```

즉, extends에 `next/core-web-vitals`를 추가하면 두 가지 설정이 모두 적용된다. 이 외에도 `.eslintignore`나 `.prettierignore`에 `.next`나 `.node_modules`를 추가해 정적 분석 대상에서 제외시킨다.

### 스타일 설정하기

여기서는 Next.js에 스타일을 적용하기 위해 styled-components를 사용하고자 한다.
swc에 styled-components를 사용한다는 것을 알리기위헤 `styledComponents: true`를 next.config.js에 추가한다. 이렇게 하면 swc가 styled-components를 사용하는 코드를 더 빠르게 변환한다. 추가적으로 `pages/_document.tsx`의 Head에 styled-components를 사용하기 위한 ServerStyleSheet를 추가한다.

### 애플리케이션 코드 작성

Next.js 프로젝트 구축을 위한 준비를 모두 마쳤으니 이제 본격적으로 웹사이트에 필요한 코드를 작성해보자. 여기서는 JSONPlaceholder에서 제공하는 todo API를 getServerSideProps에서 불러와 렌더링하는 간단한 예시 프로젝트를 만들었다.

이제 마지막으로 Next.js 프로젝트 실행, 빌드, 린트와 관련된 명령어를 package.json에 기재하면 모든 준비는 마치게 된다.

요즘은 대다수의 서비스가 마이크로 프론트엔드를 지향하기 때문에 프로젝트를 구축하는 일도 잦다. 프로젝트를 새로 만들 때마다 똑같은 설정을 매번 반복하는 것은 비효율적이기 때문에 다음과 같은 방법을 고려해 볼 수 있다.

1. 보일러 플레이트 프로젝트를 만든 다음, 깃허브에서 'Template respository' 옵션을 체크해두는 것이다. 이렇게 저장소를 템플릿 저장소로 만들어두면 다른 저장소를 생성할 때 이 내용을 모두 복사해서 생성할 수 있다.

![깃허브에서 템플릿 설정](../asset/github_template.png)
![깃허브에서 템플릿 사용](../asset/github_template_use.png)

그리고 템플릿으로 저장소를 생성하면 저장소명과 함께 'generated from'이라는 메세지로 어떤 템플릿에서 만들어진 저장소인지 확인할 수 있다.

2. create-react-app에서 한 발 더 나아가 나만의 `create-***-app`을 만드는 것이다. 앞선 방법은 내용을 그대로 가져오는 수준이지만 cli 패키지로 만든다면 craet-next-app과 마찬가지로 사용자의 입력을 받아 서로 다른 패키지를 만들 수 있다. 이 방법은 앞선 방법보다 훨씬 더 손이 많이 가지만 조직 내에서 마이크로서비스를 지향하고 있고, 앞으로 생성해야 할 프로젝트 또한 많다면 충분히 검토해 볼 만하다. 다음 두 사이트를 참고해 create-\*\*\*-app을 한번 직접 구현해보자.

- [create-next-app 내부의 코드](https://github.com/vercel/next.js/blob/canary/packages/create-next-app/index.ts): create-next-app의 소스 코드를 살펴보면 알겠지만 일단 하나의 템플릿을 미리 만들어 둔 다음, 여기에서 CLI로 사용자의 입력을 받아 커스터마이징한 것을 알 수 있다.
- [Creating a CLI tool with Node.js](https://blog.logrocket.com/creating-a-cli-tool-with-node-js): npm을 기반으로 CLI 패키지를 만드는 방법을 상세하게 설명하고 있다.
