## 11. Next.js 13과 리액트 18

Next.js 버전 13은 Next.js의 릴리즈 역사를 통틀어 가장 큰 변화가 있는 릴리즈라고 해도 과언이 아니다. 크게 눈에 띄는 점은 먼저 SSR의 구조에 많은 변화가 있는 리액트 18을 채택했으며, 기존에 Next.js의 큰 약점으로 지적됐던 레이아웃 지원을 본격적으로 지원하기 시작했고, 바벨을 대체할 러스트(Rust) 기반 SWC를 뒤이어 웹팩을 대체할 Turbopack까지 출시했다.

### app 디렉터리의 등장

현재까지 Next.js의 아쉬운 점으로 평가받던 것 중 하나는 바로 레이아웃의 존재이다. 공통 헤더와 공통 사이드바가 거의 대부분의 페이지에 필요한 웹사이트를 개발한다고 가정해보자. 그렇다면 이 같은 구조를 Next.js에서 유지하려면 어떻게 해야할까? 13버전 이전까지는 모든 페이지는 각각의 물리적으로 구별된 파일로 독립되어 있었다. 페이지 공통으로 무언가를 집어 넣을 수 있는 곳은 \_document와 \_app이 유일하다. 그나마도 이 파일들을 다음과 같이 서로 다른 목적을 지니고 있다.

- `_document`: 페이지에서 쓰이는 `<html>`과 `<body>` 태그를 수정하거나, SSR시 styled-components 같은 일부 CSS-in-JS를 지원하기 위한 코드를 삽입하는 제한적인 용도로 사용된다. 오직 서버에서만 작동하므로 onClick과 같은 이벤트 핸들러를 붙이거나 클라이언트 로직을 붙이는 것을 금지하고 있다.
- `_app`: \_app은 페이지를 초기화하기 위한 용도로 사용되며, 다음과 같은 작업이 가능하다고 명시되어 있다.
  - 페이지 변경 시에 유지하고 싶은 레이아웃
  - 페이지 변경 시 상태유지
  - componentDidCatch를 활용한 에러 핸들링
  - 페이지간 추가적인 데이터 삽입
  - global CSS 주입

즉, 이전의 Next.js 12 버전까지는 무언가 페이지 공통 레이아웃을 유지할 수 있는 방법은 `_app`이 유일했다. 그러나 이 방식은 `_app`에서밖에 할 수 없어 제한적이고, 각 페이지별로 서로 다른 레이아웃을 유지할 수 있는 여지도 부족했다. 이러한 레이아웃의 한계를 극복하기 위해 나온 것이 Next.js의 app 레이아웃이다. 이제 레이아웃 app 디렉터리에서 어떻게 구현되는지 살펴보자.

### 라우팅

가장 먼저 눈에 띄는 변화는 기존에 /pages로 정의하던 라우팅 방식이 /app 디렉터리로 이동했다는 점, 그리고 파일명으로 라우팅하는 것이 불가능해졌다는 것이다.

**라우팅을 정의하는 법**

기본적으로 Next.js의 라우팅은 파일 시스템을 기반으로 하고 있으며, 이 원칙은 Next.js가 처음 나온 8년 전부터 지금까지 유효하다. 이번에 등장한 새로운 app 기반 라우팅 시스템은 기존에 /pages를 사용했던 것과 비슷하지만 다음과 같은 약간의 차이가 있다.

- Next.js 12 이하: `/pages/a/b.tsx` 또는 `/pages/a/b/index.tsx`는 모두 동일한 주소로 변환된다. 즉, 파일명이 index라면 이 내용은 무시된다.
- Next.js 13 app: `/app/a/b`는 `/a/b`로 변환되며, 파일명은 무시된다. 폴더명까지만 주소로 변환된다.

즉, Next.js 13의 app 디렉터리 내부의 파일명은 라우팅 명칭에 아무런 영향을 미치지 못한다. 이 app 내부에서 가질 수 있는 파일명은 뒤이어 설명할 예약어로 제한된다.

**layout.js**

Next.js 13부터는 app 디렉터리 내부의 폴더명이 라우팅 되며, 이 폴더에 포함될 수 있는 파일명은 몇 가지로 제한되어 있다. 그중 하나가 `layout.js`이다. 이 파일은 이름에서 알 수 있는 것처럼 페이지의 기본적인 레이아웃을 구성하는 요소이다. 해당 폴더에 layout이 있다면 그 하위폴더 및 주소에 모두 영향을 미친다.

```typescript
// /app/layout.tsx
import type { Metadata } from 'next';
import localFont from 'next/font/local';
import './globals.css';

const geistSans = localFont({
  src: './fonts/GeistVF.woff',
  variable: '--font-geist-sans',
  weight: '100 900',
});
const geistMono = localFont({
  src: './fonts/GeistMonoVF.woff',
  variable: '--font-geist-mono',
  weight: '100 900',
});

export const metadata: Metadata = {
  title: 'Create Next App',
  description: 'Generated by create next app',
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="ko">
      <head>
        <title>지원이의 홈페이지</title>
      </head>
      <body className={`${geistSans.variable} ${geistMono.variable}`}>
        <h1>지원이의 홈페이지에 오신 것을 환영합니다!</h1>
        <main>{children}</main>
      </body>
    </html>
  );
}

// /app/blog/layout.tsx
export default function BlogLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return <section>{children}</section>;
}
```

먼저 루트에는 단 하나의 layout을 만들어 둘 수 있다. 이 layout은 모든 페이지에 영향을 미치는 공통 레이아웃이다. 일반적으로 웹페이지를 만드는데 필요한 공통적인 내용(html, head 등)을 다루는 곳으로 보면된다. 이는 이전 버전부터 많은 개발들을 헷갈리게 했던 `_app`, `_document`를 하나로 대체할 수 있는 좋은 시작점으로 사용될 것으로 보인다. 꼭 공통 레이아웃이 필요하진 않더라도 웹페이지에 필요한 기본 정보만 담아둬도 충분히 유용하다.

`_document`가 없어짐으로써 가장 먼저 떠오르는 고민은 바로 styled-components 같은 CSS-in-JS의 초기화이다. 과거 `_document`에서 CSS-in-JS의 스타일을 모두 모은 다음, SSR시에 이를 함께 렌더링하는 방식으로 적용했는데, `_document`가 사라짐으로써 이제 그러한 방식을 적용하는 것은 불가능하다. 대신 이 작업 또한 마찬가지로 루트의 레이아웃에서 적용하는 방식으로 바뀌었다.

```typescript
// /lib/StyledComponentsRegistry.tsx
'use client';

import React, { useState } from 'react';
import { useServerInsertedHTML } from 'next/navigation';
import { ServerStyleSheet, StyleSheetManager } from 'styled-components';

export default function StyledComponentsRegistry({
  children,
}: {
  children: React.ReactNode;
}) {
  const [styledComponentsStyleSheet] = useState(() => new ServerStyleSheet());

  useServerInsertedHTML(() => {
    const styles = styledComponentsStyleSheet.getStyleElement();
    styledComponentsStyleSheet.instance.clearTag();
    return <>{styles}</>;
  });

  if (typeof window !== 'undefined') return <>{children}</>;

  return (
    <StyleSheetManager sheet={styledComponentsStyleSheet.instance}>
      {children}
    </StyleSheetManager>
  );
}

// /app/layout.tsx
export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="ko">
      <head>
        <title>지원이의 홈페이지</title>
      </head>
      <body className={`${geistSans.variable} ${geistMono.variable}`}>
        <StyledComponentsRegistry>
          <h1>지원이의 홈페이지에 오신 것을 환영합니다!</h1>
          <main>{children}</main>
        </StyledComponentsRegistry>
      </body>
    </html>
  );
}
```

- `use client`: use strict를 연상시키는 이 내용은 클라이언트 컴포넌트를 의미하는 지시자로, 리액트 18에서 새롭게 등장한 개념이다.
- `useServerInsertedHTML`: 과거 useFlushEffects라는 이름의 훅이었는데, 좀 더 명확한 useServerInsertedHTML로 변경됐다. 아 훅은 리액트 18에서 새롭게 추가된 useInsertionEffect를 기반으로 하는 훅으로, CSS-in-JS 라이브러리와 같이 서버에 추가해야 할 HTML을 넣는 용도로 만들어졌다.

즉, `_document`에서 추가하던 SSR 스타일을 이제 새로운 방식을 활용해 layout에서 집어넣게끔 변경됐다.

그리고 페이지 하위에 추가되는 layout은 해당 주소 하위에만 적용된다. 이처럼 layout은 주소별 공통 UI를 포함할 수 있을뿐만 아니라 `_app`과 `_document`를 대신해 웹페이지를 시작하는데 필요한 공통 코드를 삽입할 수도 있다. 그리고 이 공통 코드는 기존의 `_app`과 `_document`처럼 모든 애플리케이션의 영향을 미치지 않고 오로지 자신과 자식 라우팅에만 미치게 된다. 이로써 개발자들은 하나의 애플리케이션에서 레이아웃을 더욱 유연하게 구성할 수 있게 됐다.

layout.js의 또 다른 장점은 `_document.jsx`에서만 처리할 수 있었던 부자연스러움이 사라졌다는 것이다. 기존에는 애플리케이션의 `<html />`이나 `<body />`에 무언가를 추가하는 등의 작업을 하려면 `_document.jsx`를 사용해야 했을뿐만 아니라 `<Html />`이나 `<Body />`, `<Head />`처럼 Next.js에서 제공하는 태그를 사용해야만 했다. 그러나 이제 HTML에서 기본으로 제공하는 `<html />`등의 태그를 추가하고 수정함으로써 별도로 import하는 번거로움이 사라지고 좀 더 자연스럽게 코드를 작성할 수 있게됐다.

layout에서 주의해야 할 점

- layout은 app 디렉터리 내부에서는 예약어이다. 무조건 `layout.{js|jsx|ts|tsx}`로 사용해야 하며, 레이아웃 이외의 다른 목적으로는 사용할 수 없다.
- layout은 children을 props로 받아서 렌더링해야 한다. 레이아웃이므로 당연히 그려야 할 컴포넌트를 외부에서 주입받고 그려야 한다.
- layout 내부에는 반드시 export default로 내보내는 컴포넌트가 있어야 한다.
- layout 내부에서도 API 요청과 같은 비동기 작업을 수행할 수 있다.

**page.js**

layout과 마찬가지로 page도 예약어이며, 이전까지 Next.js에서 일반적으로 다뤘던 페이지를 의미한다.

```javascript
// /app/blog/page.tsx
export default function BlogPage() {
  return <h1>안녕하세요</h1>;
}
```

위 page는 앞에서 구성했던 layout을 기반으로 위와 같은 리액트 컴포넌트를 노출하게 된다. 이 page가 받는 props는 다음과 같다.

- `params`: 옵셔널 값으로, 앞서 설명한 [...id]와 같은 동적 라우트 파라미터를 사용할 경우 해당 파라미터에 값이 들어온다.
- `searchParams`: URL에서 ?a=1과 같은 URLSearchParams를 의미한다. 예를 들어, `?a=1&b=2`로 접근할 경우 searchParams에는 `{ a: '1', b: '2' }`라는 자바스크립트 객체 값이 오게된다. 한 가지 주목해야 할 것은 이 값은 layout에서 제공되지 않는다는 것이다. 그 이유는 layout은 페이지 탐색 중에는 리렌더링을 수행하지 않기 때문이다. 즉, 같은 페이지에서 search parameter만 다르게 라우팅을 시도하는 경우 layout을 리렌더링하는 것은 불필요하기 때문이다. 만약 search parameter에 의존적인 작업을 해야 한다면 반드시 page 내부에서 수행해야 한다.

page 규칙

- page도 역시 app 디렉터리 내부의 예약어이다. 무조건 `page.{js|jsx|ts|tsx}`로 사용해야 하며, 레이아웃 이외의 다른 목적으로는 사용할 수 없다.
- page도 역시 내부에서 반드시 export default로 내보내는 컴포넌트가 있어야한다.

**error.js**

error.js는 해당 라우팅 영역에서 사용되는 공통 에러 컴포넌트이다. 이 error.js를 사용하면 특정 라우팅별로 서로 다른 에러 UI를 렌더링하는 것이 가능해진다.

```typescript
// error.tsx
'use client';

import { useEffect } from 'react';

export default function Error({
  error,
  reset,
}: {
  error: Error;
  reset: () => void;
}) {
  useEffect(() => {
    console.log('logging error:', error);
  }, [error]);

  return (
    <div>
      <strong>Error: {error?.message}</strong>
      <button onClick={() => reset()}>에러 리셋</button>
    </div>
  );
}
```

error 페이지는 에러 정보를 담고있는 error: Error 객체와 에러 바운더리를 초기화할 reset: () => void를 props로 받는다. 한 가지 명심해야 할 점은, 에러 바운더리는 클라이언트에서만 작동하므로 error 컴포넌트도 클라이언트 컴포넌트이어야 한다는 점이다. 그리고 이 error 컴포넌트는 같은 수준의 layout에서 에러가 발생할 경우 해당 error 컴포넌트로 이동하지 않는다는 점도 명심해야 한다. 그 이유는 아마도 `<Layout><Error>{children}</Error></Layout>`과 같은 구조로 페이지가 렌더링되기 때문일 것이다. 만약 Layout에서 발생한 에러를 처리하고 싶다면 상위 컴포넌트의 error를 사용하거나, app의 루트 에러 처리를 담당하는 `/app/global-error.js` 페이지를 생성하면 된다.

**not-found.js**

not-found는 특정 라우팅 하위의 주소를 찾을 수 없는 404 페이지를 렌더링할 때 사용된다.

```javascript
// not-found.tsx
export default function NotFound() {
  return (
    <>
      <h2>Not Found</h2>
      <p>404</p>
    </>
  );
}
```

error 컴포넌트와 마찬가지로 전체 애플리케이션에서 404를 노출하고 싶다면 `/app/not-found.js`를 생성해 사용하면 된다.

**loading.js**

loading은 뒤이어 설명할 리액트 Suspense를 기반으로 헤당 컴포넌트가 불러오는 중임을 나타낼 때 사용할 수 있다.

```javascript
export default function Loading() {
  return 'Loading...';
}
```

이 컴포넌트는 'use client' 지시자를 사용해 클라이언트에서 렌더링되개 할 수도 있다.

**route.js**

Next.js 13.4.0에서 app 디렉터리가 정식으로 출시되면서 이전까지 지원하지 못했던 `/pages/api`에 대한 /app 디렉터리 내부의 지원도 추가됐다. `/pages/api`와 동일하게 `/app/api`를 기준으로 디랙터리 라우팅을 지원하며, 앞서 파일명에 대한 라우팅이 없어진 것과 마찬가지로 `/api`에 대해서도 파일명 라우팅이 없어졌다. 그 대신 디렉터리가 라우팅 주소를 담당하며 파일명은 `route.js`로 통일됐다.

```typescript
// /app/api/hello/route.ts
import { NextRequest } from 'next/server';

export async function GET(request: NextRequest) {}
export async function HEAD(request: NextRequest) {}
export async function POST(request: NextRequest) {}
export async function PUT(request: NextRequest) {}
export async function PATCH(request: NextRequest) {}
export async function DELETE(request: NextRequest) {}
export async function OPTIONS(request: NextRequest) {}
```

이 route.ts 파일 내부에 REST API의 get, post와 같은 메서드명을 예약어로 선언해두면 HTTP 요청에 맞게 해당 메서드를 호출하는 방식으로 작동한다. 한 가지 흥미로운 점은 /app/api 외에 다른 곳에서 선언해도 작동한다는 것이다.

```typescript
// /app/internal-api/hello/route.ts
import { NextRequest } from 'next/server';

export async function GET(request: NextRequest) {
  return new Response(JSON.stringify({ name: 'hello' }), {
    status: 200,
    headers: {
      'content-type': 'application/json',
    },
  });
}
```

```shell
curl -X GET "htts://localhost:3000/internal-api/hello"

# {name: 'hello'}
```

라우팅 명칭에 자유도가 생긴 대신, 당연하게도 route.ts가 존재하는 폴더 내부에는 page.tsx가 존재할 수 없다.

이 route의 함수들이 받을 수 있는 파라미터는 다음과 같다.

- `request`: NextRequest 객체이며, fetch의 Request를 확장한 Next.js만의 Request라고 보면된다. 이 객체에는 API 요청과 관련된 cookie, headers 등뿐만 아니라 nextUrl 같은 주소 객체도 확인할 수 있다.
- `context`: params만을 가지고 있는 객체이며, 이 객체는 앞서 파일 기반 라우팅에서 언급한 것돠 동일한 동적 라우팅 파라미터 객체가 포함되어 있다. 이 객체는 Next.js에서 별도 인터페이스를 제공하지 않으므로 주소의 필요에 따라 원하는 형식으로 선언하면 된다.

```typescript
import { NextRequest } from 'next/server';

export async function GET(
  request: NextRequest,
  context: { params: { id: string } }
) {
  const response = await fetch(
    `https://jsonplaceholder.typicode.com/users/${context.params.id}`
  );

  // ...

  return new Response(JSON.stringify(result), {
    status: 200,
    headers: {
      'Content-Type': 'application/json',
    },
  });
}
```
