## 13. 웹페이지 성능을 측정하는 다양한 방법

### 애플리케이션에서 확인하기

**create-react-app**

```typescript
// reportWebVitals.ts
import { ReportHandler } from 'web-vitals';

const reportWebVitals = (onPerfEntry?: ReportHandler) => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;
```

```typescript
// index.tsx

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();
```

reportWebVitals 함수는 웹에서 성능을 측정하기 위한 함수이다. 이름에서도 알 수 있듯이 각각 누적 레이아웃 이동(CLS), 최초 입력 지연(FID), 최초 콘텐츠풀 페인트(FCP), 최대 콘텐트 페인트(LCP), 첫 바이트까지의 시간(TTFB)을 측정하는 용도로 사용된다. 이러한 지표의 측정을 가능케 하는 것은 바로 web-vitals 라이브러리 덕분이다. 이러한 자바스크립트 수준의 라이브러리가 브라우저의 웹페이지 성능을 측정할 수 있는 이유는 PerformanceObserver라는 API를 사용하기 때문이다. PerformanceObserver는 웹페이지에서 다양한 성능을 측정할 수 있도록 도와주는 API로, 브라우저에서 웹페이지의 성능을 측정하기 위해 사용된다. 반대로 말하자면, 이 API를 제공하지 않는 브라우저에서는 web-vitals의 도움을 받아 성능을 측정하기 어렵다.

ReportHandler는 단순히 성능 객체인 Metric을 인수로 받는 타입으로, Metric을 원하는 대로 다룰 수 있다. 즉, 단순히 콘솔에 출력하는 것뿐만 아니라 서버로 전송하는 등의 작업을 할 수 있다.

```javascript
reportWebVitals(console.log);
```

![CRA reportWebVitals 출력결과](../asset/cra_webvitals.png)

단순히 console.log로 기록한다면 브라우저의 콘솔 창에 기록하는 용도로밖에 활용할 수 없다. 만약 실제로 서버 등 어딘가에 기록하고 싶다면 소량의 분석용 데이터를 전송하기 위해 만들어진 sendBeacon API나 fetch 등의 API를 사용해 임의로 서버로 정보를 보내거나 구글 애널리틱스로 보낼 수도 있다.

```typescript
function sendToAnalytics(metric: Metric) {
  const body = JSON.stringify(metric);
  // 지표 정보를 보낼 위치
  const url = '/api/analysis';

  if (navigator.sendBeacon) {
    navigator.sendBeacon(url, body);
  } else {
    // sendBeacon이 없다면 fetch 또는 axios를 사용해 보낸다
    fetch(url, { body, method: 'POST', keepalive: true });
  }
}

reportWebVitals(sendToAnalytics);
```

```typescript
function sendToAnalytics({ id, name, value }: Metric) {
  // https://support.google.com/analytics/answer/11150547
  ga('send', 'event', {
    eventCategory: 'Web Vitals',
    eventAction: name,
    eventValue: Math.round(name === 'CLS' ? value * 1000 : value),
    eventLabel: id,
    nonInteraction: true,
  });
}

reportWebVitals(sendToAnalytics);
```

**create-next-app**

Next.js에서도 CRA와 비슷한 방식으로 사용해 볼 수 있다. 기본적으로 Next.js는 성능 측정을 할 수 있는 메서드인 NextWebVitalsMetric을 제공한다. `_app` 페이지에 다음과 같이 코드를 추가해서 사용해보자.

```typescript
import type { AppProps, NextWebVitalsMetric } from 'next/app';

export function reportWebVitals(metric: NextWebVitalsMetric) {
  console.log(metric);
}

export default function App({ Component, pageProps }: AppProps) {
  return <Component {...pageProps} />;
}
```

![CNA reportWebVitals 출력결과](../asset/cna_webvitals.png)

여기서 한 가지 주목할 만한 점은 기본적인 핵심 웹 지표 외에도 다음과 같은 Next.js에 특화된 사용자 지표도 제공한다는 점이다.

- Next.js-hydration: 페이지가 SSR되어 하이드레이션하는 데 걸리는 시간
- Next.js-route-change-to-render: 페이지가 경로를 변경한 후 페이지를 렌더링를 시작하는데 걸리는 시간
- Next.js-render: 경로 변경이 완료된 후 페이지를 렌더링하는데 걸리는 시간

참고로 모든 시간 단위는 밀리초(ms)이다.

위의 3가지 지표는 어느 정도 이하로 지표가 기록되어야 한다는 등의 기준은 없다. 다만 각각의 지표를 살펴보면서 SSR 시에 오래 걸리진 않는지, 페이지 전환 시에 호출되는 getServerSideProps가 오래 걸리지 않는지 등을 살펴보면 좋다. 이 외에는 create-react-app에서 지표를 수집하는 방식과 동일하게 사용할 수 있다.

### 구글 라이트하우스

리액트 애플리케이션에서 reportWebVitals를 설치해서 지표를 수집하는 방식은 단순히 코드 몇 줄만으로 지표를 수집할 수 있다는 장점이 있지만 그럼에도 기존 애플리케이션 코드의 수정이 필요하다는 점, 그리고 별도로 지표 수집을 하기 위한 사전 준비가 필요하다는 번거로움이 있다. 이에 반해 별도의 애플리케이션 코드 수정이나 배포, 수집 없이도 지표를 수집할 수 있는 방법이 있는데 바로 구글 라이트하우스(Googl Lighthouse)이다.

구글 라이트하우스는 구글에서 제공하는 웹 페이지 성능 측정 도구로, 오픈소스로 운영되고 있다. 앞서 살펴본 핵심 웹 지표뿐만 아니라 접근성, PWA, SEO 등 웹 페이지를 둘러싼 다양한 요소들을 측정하고 점검할 수 있다. 구글 라이트하우스를 실행하는 방법은 다음과 같다.

- 브라우저 확장 프로그램 설치: 브라우저의 웹 스토어에 접속해 확장 프로그램을 설치한다.
- 크롬 개발자 도구: 크롬의 개발자 도구에는 라이트하우스가 기본적으로 내장되어 있다.
- CLI: lighthouse라는 npm 라이브러리를 이용하면 CLI 명령어로 지표를 수집할 수 있다.

  ```shell
  lighthouse https://www.naver.com
  ```

  CLI의 경우 깃허브 액션 등 터미널만 제한적으로 사용할 수 있다는 CI/CD 환경에서 사용하기에 적합하다. 여기서는 크롬 개발자 도구를 이용해 라이트하우스를 실행하는 방법을 살펴본다.

먼저 크롬을 실행해 성능 지표를 분석하고자 하는 사이트를 방문한다. 그 다음, 크롬 개발자 도구를 열어 Lighthouse 탭을 클릭한다. 크롬에 설치된 다른 확장 프로그램 등이 영향을 줄 수 있으므로 가급적 시크릿 창으로 실행해 확인하는 것을 권장한다.

![구글 라이트하우스](../asset/lighthouse.png)

기기 항목에서는 측정하고자 하는 페이지 접근 환경을, 카테고리에서는 확인하고 싶은 지표를 선택할 수 있다. 그리고 각 모드별로 어떠한 결과가 나오는지 살펴보자.

### 구글 라이트하우스 - 탐색 모드

일반적으로 페이지에 접속했을 때부터 페이지 로딩이 완료될 때까지의 성능을 측정하는 모드이다. 이 모드로 측정을 시작하면 페이지를 처음부터 다시 불러와서 페이지 로딩이 끝날 때까지 각각의 지표를 수집한다.

![구글 라이트하우스 - 탐색](../asset/lighthouse_performance.png)

**성능**

성능은 웹페이지의 성능과 관련된 지표를 확인할 수 있는 영역이다.

핵심 웹 지표인 최초 콘텐트풀 페인트(FCP), 최대 콘텐트풀 페인트(LCP), 누적 레이아웃 이동(CLS) 외에도 3가지 추가적인 지표가 있다.

- `Time to Interactive`: 페이지에서 사용자가 완전히 상호작용(인터렉션)할 수 있을 때까지 걸리는 시간을 측정한다. 여기서 상호작용에 걸리는 시간까지란 다음과 같은 것을 의미한다.

  - LCP로 측정되는 페이지 내 콘텐츠가 표시되는 시점
  - 보여지는 페이지 요소의 대부분에 이벤트 핸들러가 부착되는 시점
  - 페이지의 유저가 상호작용에 50ms 내로 응답하는 시점

  구글에서는 이 TTI 지표가 3.8초 이내면 좋음, 7.3초 이내면 보통, 그 이후는 개선이 필요한 것으로 본다. 웹 페이지가 최대한 빠르게 상호작용이 되도록 준비하려면 메인 스레드가 하는 자바스크립트 작업을 최소화하고, 전체적인 자바스크립트 실행속도 또한 높일 필요가 있다.

- `Speed Index`: 페이지가 로드되는 동안 콘텐츠가 얼마나 빨리 시각적으로 표시되는지를 계산한다. 라이트하우스는 브라우저에 로드되는 페이지를 실시간으로 캡처하고, Speedline 라이브러리를 사용해 캡처된 이미지를 분석해 speed index를 계산한다. 구글에서는 이 지표가 3.4초 이내면 좋음, 5.8초 이내면 보통, 그 이후는 느리다고 판단한다.

- `Total Blocking Time`: 메인 스레드에서 특정 시간 이상 실행되는 작업, 즉 긴 작업이 수행될 때마다 메인 스레드가 차단된 것으로 간주한다. 메인 스레드가 차단됐다고 표현하는 이유는 브라우저가 이렇게 길게 실행하는 작업 때문에 무언가 다른 작업을 수행할 수 없기 때문이다. 이렇게 메인 스레드에서 실행하는 작업이 50ms 이상 걸리면 이를 긴 작업이라고 간주하고, 이렇게 실행되는 긴 작업을 모아서 Total Blocking Time(총 차단 시간)이라고 한다. 이 총 차단 시간은 긴 작업을 모아서 각각의 긴 작업의 시간에서 50ms를 뺀 다음, 이를 모두 합해 계산한다. 이 총 차단 시간은 모든 긴 작업을 대상으로 하는 것이 아니고, 최초에 사용자에게 무언가 콘텐츠를 보여줬을 때(최초 콘텐트풀 페인트, FCP)부터 상호 작용까지 걸리는 시간(TTI) 사이의 작업만 대상으로 한다. 즉, 사용자가 무언가 작업이 진행되고 있지 않다는 것을 눈치 챌 수 있는 시간을 대상으로만 총 차단 시간을 구하게 된다.

![구글 라이트하우스 - 탐색 진단](../asset/lighthouse_diagnosis.png)

성능에서는 이 6가지 항목에 대해 각각의 점수를 계산하고, 해당 점수를 기반으로 어떠한 부분을 개선해야 하는지 알려준다.

**접근성**

접근성이란 웹 접근성을 말하며, 장애인 및 고령자 등 신체적으로 불편한 사람들이 일반적인 사용자와 동등하게 웹페이지를 이용할 수 있도록 보장하는 것을 말한다. 예를 들어, 시각으로 웹페이지를 보기 어려운 경우를 가정해보자. 이 경우 스크린 리더라고 하는 툴을 활용하면 웹페이지 내용을 직접 듣는 것이 가능하다. 그러나 그림이나 사진의 경우는 어떨까? 이 경우 스크린 리더가 그림과 사진을 읽을 수는 없으므로 적절한 대체 문자가 필요하다. 오디오나 비디오는 청각이 제한적인 경우를 위해 자막이 필요하며, 마우스를 활용할 수 없는 상황에 대비하기 위해서는 키보드만으로 모든 콘텐츠에 접근할 수 있어야 한다. 이러한 다양한 사용자들을 배려하기 위해 HTML과 CSS 등에 적절한 대안을 삽입하는 것을 접근성이라고 하며, 이 영역에서 평가하는 것은 얼마나 적절하게 접근성을 제공하는지 여부이다.

![구글 라이트하우스 - 접근성](../asset/lighthouse_accessibility.png)

어떻게 수정해야 하는지도 알려준다. 이 영역을 참고해 다양한 사용자들이 모두 평등하게 웹페이지를 이용할 수 있도록 개선하는 것이 좋다.

**권장사항**

권장사항 영역에서는 웹사이트를 개발할 때 고랴해야 할 요소들을 얼마나 지키고 있는지 확인할 수 있다.

![구글 라이트하우스 - 권장사항](../asset/lighthouse_recommendation.png)

여기서 말하는 권장사항에는 보안, 표준모드, 최신 라이브러리, 소스 맵 등 다양한 요소들이 포함되어 있다. 이러한 권장사항들을 간단하게 살펴보자.

- CSP가 XSS 공격에 효과적인지 확인: XSS란 Cross Site Scripting의 약자로, 개발자가 아닌 제3자가 삽입한 스크립트를 통해 공격하는 기법이다. 예를 들어, 게시판이 있고, 어떠한 악의적인 게시자가 내용 대신 스크립트를 작성했다고 가정해보자. 이때 개발자가 별다른 조치를 취하지 않으면 이 스크립트가 실행되어 사용자에게 위해가 되는 작업을 수행할 수 있게 된다. CSP란 Content Security Policy의 약자로, 웹 사이트에서 호출할 수 있는 컨텐츠를 제한하는 정책을 말한다. 이 제한 정책에는 이미지, 스타일, 스크립트와 같은 정적인 콘텐츠뿐만 아니라, 주소, 도메인 등의 정보도 포함된다.

- 감지된 자바스크립트 라이브러리: 페이지에서 감지되는 자바스크립트 라이브러리를 말한다. jQuery, Next.js, React, Lodash, creat-react-app 등이 나타나며, 버전까지 특정할 수 있는 경우 버전까지 확인할 수 있다.

- HTTPS 사용: HTTP 대신 보안이 더 강력한 HTTPS를 사용하는지 확인한다.

- 페이지 로드 시 위치정보 권한 요청 방지하기: 사용자의 동의 없이 페이지 로드 시에 사용자의 물리적 위치를 알 수 있는 메서드인 window.navigator.geolocation.getCurrentPosition(), window.navigator.geolocation.watchPosition()을 실행하는지 확인한다. 물론 이 두 함수가 호출된다고 해서 바로 사용자의 위치 정보를 가져올 수 있는 것은 아니며, 브라우저에서 한 번 물어보는 절차를 거치게 된다. 그러나 다짜고짜 페이지 로드 시 요청하는 것은 사용자와 특별한 액션없이 가져오는 것이므로 반드시 사용자의 액션 이후에 실행되어야 한다.

- 페이지 로드 시 알림 권한 요청 방지하기: 위치 정보와 마찬가지로 사용자의 동의 없이 페이지 로드 시 웹 페이지 알림을 요청하는 Notification.requestPermission()을 실행하는지 확인한다. 이 함수도 마찬가지로 브라우저에서 사용자에게 알림 허용 여부를 다시 한 번 확인하지만 반드시 사용자 액션이 있을 때만 호출하는 것이 좋다.

- 알려진 보안 취약점이 있는 프론트엔드 자바스크립트 라이브러리를 사용하지 않음: 보안 취약점이 존재하는 자바스크립트 라이브러리를 사용하는지 확인한다.

- 사용자가 비밀번호 입력란에 붙여넣을 수 있도록 허용: 일부 사용자는 복잡한 비밀번호를 별도의 애플리케이션에 관리해 외우지 않고 복사/붙여넣기 방식으로 비밀번호를 입력한다. 이것은 보안 관점으로 봤을 때 타당한 접근방식이나 웹페이지에서 이를 허용하지 않는다면 무용지물이다. 반드시 비밀번호 입력란은 붙여넣기가 가능해야 한다.

- 이미지를 올바른 가로세로 비율로 표시: 이미지의 실제 크기와 표시되는 크기 사이의 비율이 일치하는지 확인한다.

- 이미지가 적절한 해상도로 제공됨: 이미지가 선명하게 보일 수 있도록 크기에 맞는 해상도의 이미지를 제공하는지 확인한다.

- 페이지에 HTML Doctype 있음: 과거 웹 표준이 제대로 정착되지 않았을 때 웹페이지는 넷스케이프 브라우저의 인터넷 익스플로러용 두 가지 버전으로 따로 만들어졌다. 이후 표준이 재정되면서 이 혼란은 멈추게 되었는데, 이 표준을 준수해 웹페이지가 작성되었다고 의미하는 것이 바로 Doctype이다. 이 Doctype이 선언되지 않아다면 표준을 준수하지 않는 것으로 간주되어 호환 모드로 렌더링하게 되는데 이는 불필요한 작업이다. 따라서 웹페이지 첫 번째 줄에 `<!DOCTYPE html>`을 선언해 이러한 호환 모드 실행을 막는 것이 좋다.

- 문자 집합을 제대로 정의함: 서버가 HTML 파일을 전송할 때 문자가 어떻게 인코딩되어 있는지 지정하지 않으면 브라우저는 각 바이트가 나타내는 문자를 알 수 없게된다. 따라서 적절하게 charset을 지정해야 한다. 대부분의 웹페이지는 `<head>`의 최상단에 `<meta charset=utf-8 />`을 삽입해 UTF-8로 인코딩됐다고 명시한다.

- 지원중단 API를 사용하지 않기: 더 이상 지원하지 않는 API는 잠재적으로 보안 취약점이 될 수 있으므로 사용하지 않는 것이 좋다.

- 콘솔에 로그된 브라우저 오류 없음: 콘솔에 에러가 기록되는 것은 사용자에게 영향을 미치지 않을 수도 있지만 분명 웹페이지에 문제가 있다는 사실에는 변함이 없다. 따라서 콘솔에 에러가 기록되지 않게 해야한다.

- Chrome Devtools의 Issues 패널에 문제없음: 크롬 개발자 도구에는 문제(Issues)라는 탭이 있는데, 이 탭에는 웹페이지에 대한 여러가지 문제점을 알려준다. 여기에 기록된 문제가 있다면 확인해 조치하는 것이 좋다.

- 페이지에 유효한 소스 맵이 있음: 소스 맵은 압축되어서 읽기 어려워진 소스코드를 원본 소스코드로 변환할 수 있도록 도와주는 파일로, 이 소스맵이 있으면 개발자가 디버깅하는 데 큰 도움이 된다. 따라서 디버깅을 해야 하는 상황이라면 소스맵이 있는 것이 좋지만, 반대로 그럴 필요가 없는 경우에는 별도로 제공하지 않아도 된다.

- `font-display: optional`을 사용하는 폰트가 미리 로드됨: 폰트를 불러오는 방법 중 하나로, 개발자가 원하는 임의의 폰트를 보여줄 수도 있으면서 동시에 사용자에게 버벅거림 없는 렌더링을 보장할 수 있는 가장 효과적인 방법이다.

**검색 엔진 최적화**

검색 엔진 최적화란 웹페이지가 구글과 같은 검색엔진이 쉽게 웹페이지의 정보를 가져가서 공개할 수 있도록 최적화되어 있는지를 확인하는 것을 의미한다. 단순히 문서를 크롤링하기 쉽게 만들었는지 확인하는 것부터, robots.txt가 유효한지, 이미지와 링크에 설명 문자가 존재하는지, `<meta>`나 `<title>` 등으로 페이지의 정보를 빠르게 확인할 수 있는지 등을 확인한다. 검색엔진에 최적화되어 있을수록 검색 엔진의 검색결과에 우선순위에 높게 나타나며, 사용자가 유입될 가능성이 높아지므로 이러한 SEO를 위한 다양한 요소들을 확인하고 점검할 필요가 있다.

![구글 라이트하우스 - SEO](../asset/lighthouse_SEO.png)

### 구글 라이트하우스 - 기간 모드

기간 모드는 실제 웹페이지를 탐색하는 동안 지표를 측정하는 것이다. 기간 모든 시작을 누른 뒤 성능 측정을 원하는 작업을 수행한 다음, 기간 모드를 종료하면 그 사이에 일어난 작업들에 대한 지표를 다음과 같이 확인할 수 있다.

![구글 라이트하우스 - 기간모드](../asset/lighthouse_period_mode.png)

여기서 확인할 수 있는 지표들은 크게 성능과 권장사항으로, 앞서 탐색모드와 크게 다르지 않다. 대다수의 사용자가 빈번하게 수행할 것으로 예상되는 작업을 기간모드로 측정하면 성능 최적화에 큰 도움을 얻을 수 있다.

여기서 앞에서 볼 수 없었던 내용 두 가지를 확인할 수 있는데, 바로 흔적과 트리맵이다.

**흔적**

흔적이라는 이름은 View Trace를 번역한 것으로, 웹 성능을 추적한 기간을 성능 탭에서 보여준다. 단순히 구글에서 제안하는 감사를 보여주는 정도를 넘어서, 상세하게 시간의 흐름에 따라 어떻게 웹페이지가 로딩됐는지를 보여준다.

![구글 라이트하우스 - 흔적](../asset/lighthouse_trace.png)

**트리맵**

트리맵은 페이지를 불러올 때 함께 로딩한 모든 리소스를 함께 모아서 볼 수 있는 곳이다. 웹페이지의 전체 자바스크립트 리소스 중 어떠한 파일이 전체 데이터 로딩 중 어느 정도를 차지했는지를 비율로 확인할 수 있으며, 실제 불러온 데이터의 크기를 확인할 수도 있다.

![구글 라이트하우스 - 트리맵](../asset/lighthouse_treemap.png)

한 가지 더 확인할 수 있는 것은 로딩한 리소스에서 사용하지 않은 바이트의 크기를 확인하는 것인데, 이는 실제로 불러왔지만 사용되지 않은 리소스를 의미한다. 이 또한 전체 리소스에서 어느 정도 비율인지 확인할 수 있지만 특정 시나리오에서만 실행되는 리소스도 있기 때문에 꼭 사용하지 않는다고 해서 불필요한 것이라고 단정 지을 수 없다. 다만 이 사용하지 않는 바이트의 크기가 불필요하게 크다면 번들링된 리소스에서 불필요한 것이 없는지 확인해 보는 것이 좋다.

이러한 리소스들은 크롬 개발자 도구의 소스 탭에서 파일명을 입력해 실제로 내부의 소스코드도 확인할 수 있으니 과도하게 큰 리소스나 혹은 사용하지 않은 바이트의 비중이 큰 리소스는 한 번쯤 눈여겨보는 것이 좋다. 소스맵까지 배포되어 있다면 무슨 소스코드가 번들링되어 있는지 더 정확하게 확인할 수 있을 것이다.

### 구글 라이트하우스 - 스냅샷

스냅샷 모드는 탐색 모드와 매우 유사하지만 현재 페이지의 상태를 기준으로 분석한다는 점이 다르다. 즉, 현재 상태에서 SEO, 접근성, 성능 등을 분석할 수 있다. 페이지 로딩이 아닌 특정 페이지의 특정 상태를 기준으로 분석하고 싶다면 스냅샷 모드를 사용하면 된다. 스냅샷 모드의 지표는 탐색 모드와 매우 유사하므로 이를 참고하면 된다.

![구글 라이트하우스 - 스냅샷](../asset/lighthouse_snapshot.png)

앞서 다른 모드와 다르게 일정 기간 분석을 수행하지 않기 때문에 분석할 수 있는 내용이 제한적이다.
