## 1.6 리액트에서 자주 사용하는 자바스크립트 문법

### 1.6.1 구조 분해 할당

배열 또는 객체의 값을 말 그대로 분해해 개별 변수에 즉시 할당하는 것을 의미한다.

#### 배열 구조 분해 할당

```js
const array = [1, 2, 3, 4, 5];

const [first, second, third, ...ararayRest] = array;
```

- useState가 객체가 아닌 배열을 반환하는 이유는 배열 구조 분해할당은 사용하는 쪽에서 이름을 자유롭게 선언할 수 있기 때문에 배열을 반환한다

#### 객체 구조 분해 할당

배열과 달리 객체 내부 이름으로 꺼내온다는 차이점이 있다

```js
const object = {
  a: 1,
  b: 2,
  c: 3,
  d: 4,
  e: 5,
};

const { a, b, c, ...objectRest } = object;
```

이를 새로운 이름으로 다시 할당하는 것도 가능하다

```js
const object = {
  a: 1,
  b: 2,
};

const { a: first, b: second } = object;
```

### 1.6.2 전개 구문

객체, 문자열과 같이 순회할 수 있는 값에 대해 말 그대로 전개해 간결하게 사용할 수 있는 구문이다.

#### 배열의 전개 구문

배열 내부에서 ...배열을 사용하면 해당 배열을 마치 전개하는 것처럼 선언하고, 이를 내부 배열에서 활용할 수 있다. 이러한 특징을 활용하면 기존 배열에 영향을 미치지 않고 배열을 복사하는 것도 가능하다

```js
const arr1 = ["a", "b"];
const arr2 = [...arr1, "c", "d", "e"];
```

#### 객체의 전개 구문

객체 전개 구문에 있어서 순서가 중요하다. 위에 있을 때와 아래에 있을 때의 작동의 순서 차이로 인해 전혀 다른 객체가 생성될 수 있다.  
전개 구문에 있는 값을 덮어쓸 것인지, 혹은 그 값을 받아들일지에 따라 순서에 차이가 발생하므로 주의해야 한다

```js
const obj = {
  a: 1,
  b: 1,
  c: 1,
  d: 1,
  e: 1,
};

// {a:1, b:1, c:10, d:1, e:1}
const aObj = {
  ...obj,
  c: 10,
};

// {c:1, a:1, b:1, d:1, e:1}
const bObj = {
  c: 10,
  ...obj,
};
```

### 1.6.3 객체 초기자

객체를 선언할 때 객체에 넣고자 하는 키와 값을 가지고 있는 변수가 이미 존재한다면 해당 값을 간결하게 넣어줄 수 있는 방식이다.

```js
const a = 1;
const b = 2;

const obj = {
  a,
  b,
}; // {a:1, b:2}
```

객체를 좀 더 간편하게 선언할 수 있기 때문에 매우 유용하며, 트랜스파일 이후에도 큰 부담이 없는 것을 확인할 수 있다.

### 1.6.4 map, filter, reduce, forEash

- 생략

### 1.6.5 삼항 조건 연산자

자바스크립트에서 유일하게 3개의 피연산자를 취할 수 있는 문법이다.  
먼저 맨 앞에 조건문이 들어가고 물음표 뒤에는 참일 경우의 반환값, : 뒤에는 거짓일 때 반환할 값을 지정한다

```js
const value = 10;
const result = value % 2 === 0 ? "짝수" : "홀수";
// 짝수
```

- 삼항 연산자는 가급적이면 중첩해서 쓰지 않는 편이 좋다

## 1.7 선택이 아닌 필수, 타입스크립트

### 1.7.1 타입스크립트란?

기존 자바스크립트 문법에 타입을 가미한 것이 바로 타입스크립트이다. 동적 언어인 자바스크립트의 한계를 벗어나 타입 체크를 정적으로 런타임이 아닌 빌드 타임에 수행할 수 있게 해준다.

### 1.7.2 리액트 코드를 효과적으로 작성하기 위한 타입스크립트 활용법

#### any 대신 unkonwn을 사용하자

- any는 자바스크립트에서 타입스크립트로 넘어가는 과도기와 같은 예외적인 경우에만 사용하는 것이 좋다 대신 불가피하게 아직 타입을 단정할 수 없는 경우에는 unknown을 사용하는 것이 좋다
- unknown은 모든 값을 할당할 수 있는 이른바 top type으로, 어떠한 값도 할당할 수 있다. 하지만 이 값을 바로 사용하는 것은 불가능하다.

```js
function doSomething(callback: unknown) {
  callback(); // 'callback' is of type 'unknown'
}
```

- 위 예제의 에러 내용을 보면 callback은 unknown, 즉 아직 알 수 없는 값이기 대문에 사용할 수 없다는 내용이다. unknown으로 선언된 변수를 사용하기 위해서는 type narrowing, 즉 타입을 원래 의도했던 대로 적절히 좁혀야 한다.

```js
function doSomething(callback: unknown) {
  if(typeof callback === 'function'){
    callback()
    return
  }

  throw new Error("callback은 함수여야 합니다');
}
```

- 위와 같이 typeof를 사용해서 해당 unknown 값이 우리가 원하는 타입일 때만 의도대로 작동하도록 수정했다. 이렇게 unknown을 사용하는 것은 예상치 못한 타입을 받아들일 수 있음은 물론, 사용하는 쪽에서도 더욱 안전하게 쓸 수 있다. any 보다는 unknown을 사용하는 습관을 들이자
- unknown 타입의 반대 개념인 never 타입은 어떠한 타입도 들어올 수 없음을 의미한다.

```js
type what1 = string & number;
type what2 = ("hello" | "hi") & "react";
```

- what1은 string과 number 둘 다 만족시키는 타입은 존재하지 않기 때문에 never가 선언된다. what2도 마찬가지다.

#### 타입가드를 적극 활용하자

타입을 사용하는 쪽에선 최대한 타입을 좁히는 것이 좋다. 이렇게 타입을 좁히는데 도움을 주는 것이 타입가드이다. 조건문과 함께 타입 가드를 사용하면 타입을 효과적으로 좁힐 수 있어 조금 더 명확하게 변수나 함수를 사용할 수 있다.

- instanceof : 지정한 인스턴스가 특정 클래스의 인스턴스인지 확인할 수 있는 연산자다
- typeof : 특정 요소에 대해 자료형을 확인하는데 사용된다
- in : 주로 어떤 객체에 키가 존재하는지 확인하는 용도로 사용된다

#### 제네릭

함수나 클래스 내부에서 단일 타입이 아닌 다양한 타입에 대응할 수 있도록 도와주는 도구이다. 제네릭을 사용하면 타입만 다른 비슷한 작업을 하는 컴포넌트를 단일 제네릭 컴포넌트로 선언해 간결하게 작성할 수 있다

#### 인덱스 시그니처

객체의 키를 정의하는 방식을 의미한다. 키에 원하는 타입을 부여할 수 있다.

```js
type Hello = {
  // 인덱스 시그니처
  [key: string]: string,
};

const hello: Hello = {
  hello: "hello",
  hi: "hi",
};

hello["hi"]; // hi
hello["안녕"]; // undefined
```

- 위 예제와 같이 string으로 정의하면 범위가 너무 커지기 때문에 존재하지 않는 키로 접근하면 위와 같이 undefined로 반환할 수도 있다. 따라서 객체의 타입도 필요에 따라 좁혀야 한다.
- 객체의 키를 좁히는 방법은 2가지이다

```js
// recode를 사용
type Hello = Record<'hello' | 'hi', string>

const hello: Hello = {
  hello: 'hello',
  hi: 'hi',
}

// 타입을 사용한 인덱스 시그니처
type Hello = { [key in 'hello' | 'hi']: string}

const hello: Hello = {
  hello: 'hello',
  hi: 'hi',
}
```

- Record<Key, Value>를 사용하면 객체의 타입에 각각 원하는 키와 값을 넣을 수 있다. 그리고 인덱스 시그니처에 타입을 사용함으로써 객체를 원하는 형태로 최대한 좁힐 수 있다

### 1.7.3 타입스크립트 전환 가이드

너무 거대한 자바스크립트 프로젝트를 운영하고 있어 타입스크립트로 넘어가기가 망설여지는 경우, 아래와 같이 점진적으로 타입스크립트로 전환하는 것도 고민해 볼 수 있다

#### tsconfig.json 먼저 작성하기

- 타입스크립트를 작성할 수 있는 환경을 만들기 위해 최상위 디렉터리에 tsconfig.json을 생성해 아래와 같이 작성해보자

```json
{
  "compilerOptions": {
    "outDir": "./dist",
    "allowJs": true,
    "target": "es5"
  },
  "include": ["./src/**/*"]
}
```

#### JSDoc과 @ts-check를 활용해 점진적으로 전환하기

- 자바스크립트 파일을 굳이 타입스크립트로 전환하지 않더라도 타입을 체크하는 방법이 있다. 먼저 파일 최상단에 //@ts-check를 선언하고, JSDoc을 활용해 변수나 함수에 타입을 제공하면 타입스크립트 컴파일러가 자바스크립트 파일의 타입을 확인한다
- JSDoc을 추가하는 것은 손이 꽤나 가는 작업이기 때문에 타입스크립트로 전환하기 어려울 때만 위와 같이 타입을 확인하는 것을 추천한다

#### 타입 기반 라이브러리 사용을 위해 @types 모듈 설치하기

- 타입스크립트에서 라이브러리를 정상적으로 사용하기 위해서는 @types라 불리는 DefinitelyTyped를 설치해야 한다.

#### 파일 단위로 조금씩 전환하기

- 가장 먼저 전환해 볼만 파일은 상수나 유틸과 같이 별도의 의존성을 가지고 있지 않은 파일이다.
- 파일을 하나씩 타입스크립트로 전환하고, 상수의 경우에는 string, number와 같이 원시값 대신 가능한 한 타입을 좁혀보자. 이렇게 좁히다 보면 이를 가져다 사용하는 쪽에서도 조금씩 수정이 필요할 것이다.
