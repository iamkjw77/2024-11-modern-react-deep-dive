## 1.4 클로저

함수 컴포넌트의 구조와 작동 방식, 훅의 원리, 의존성 배열 등 함수 컴포넌트의 대부분의 기술이 모두 클로저에 의존하고 있기 때문에 함수 컴포넌트 작성을 위해서는 클로저에 대해 이해하는 것이 필수다.

### 1.4.1 클로저의 정의

클로저는 함수와 함수가 선언된 어휘적 환경의 조합으로 정의된다

```js
function add() {
  const a = 10;
  function innerAdd() {
    const b = 20;
    console.log(a + b);
  }
  innerAdd(); // 30
}

add();
```

- 위 예제는 함수가 중첩되어 있는 상황에서 변수의 범위가 어떻게 정의되는지 알 수 있다. a 변수의 범위는 add 전체이고, b의 범위는 innerAdd 전체이다.
- 즉, '선언된 어휘적 환경'은 변수가 코드 내부에서 어디서 선언됐는지를 말하는 것이다. 호출되는 방식에 따라 동적으로 결정되는 this와는 다르게 코드가 작성된 순간에 정적으로 결정된다.

### 1.4.2 변수의 유효 범위, 스코프

변수의 유효 범위를 스코프라고 하는데, 자바스크립트는 다양한 스코프가 있다

#### 전역 스코프

- 전역 레벨에서 선언하는 것을 말한다. 이 스코프에서 변수를 선언하면 어디서든 호출할 수 있게 된다.
- Node.js에서는 global, 브라우저 환경에서는 window다.

#### 함수 스코프

- 다른 언어와 달리 자바스크립트는 기본적으로 함수 레벨 스코프를 따른다. 즉, {} 블록이 스코프 범위를 결정하지 않는다.

### 1.4.3 클로저의 활용

전역 스코프는 어디서든 원하는 값을 꺼내올 수 있다는 장점이 있지만 누구든 수정할 수 있다는 뜻도 된다

```js
var counter = 0;

function handleClick() {
  counter++;
}
```

- 리액트가 관리하는 내부 상태 값은 리액트가 별도로 관리하는 클로저 내부에서만 접근할 수 있다. 이를 이제 클로저를 활용한 코드로 변경해 보자

```js
function Counter() {
  var counter = 0;

  return {
    increase: function () {
      return ++counter;
    },
    decrease: function () {
      return --counter;
    },
    counter: function () {
      console.log("counter에 접근");
      return counter;
    },
  };
}

var c = Counter();

console.log(c.increase()); // 1
console.log(c.increase()); // 2
console.log(c.increase()); // 3
console.log(c.decrease()); // 2
console.log(c.counter()); // 1
```

- 위 예제와 같이 코드를 변경했을 때 counter 변수를 직접적으로 노출하지 않음으로써 사용자가 직접 수정하는 것을 막았으며 접근하는 경우를 제한해 로그를 남기는 등의 부차적인 작업도 수행할 수 있게 됐다.
- 또한 counter 변수의 업데이트를 increase와 decrease로 제한해 무분별하게 변경되는 것을 막았다. 이처럼 클로저를 활용하면 전역 스코프의 사용을 막고, 개발자가 원하는 정보만 개발자가 원하는 방향으로 노출시킬 수 있다는 장점이 있다.

#### 리액트에서의 클로저

- 리액트에서는 useState의 변수를 저장해두고, useState의 변수 접근 및 수정 또한 클로저 내부에서 확인이 가능해 값이 변하면 렌더링 함수를 호출하는 등의 작업이 이루어질 것 이다.
- 외부 함수(useState)가 반환한 내부 함수(setState)는 외부 함수(useState)의 호출이 끝났음에도 자신이 선언된 외부 함수가 선언된 환경을 기억하기 때문에 계속해서 state 값을 사용할 수 있다.

### 1.4.4 주의할 점

클로저는 외부 함수를 기억하고 이를 내부 함수에서 가져다 쓰는 메커니즘으로 성능에 영향을 미친다. 클로저에 꼭 필요한 작업만 남겨두지 않는다면 메모리를 불필요하게 잡아먹는 결과를 야기할 수 있고, 마찬가지로 클로저 사용을 적절한 스코프로 가둬두지 않는다면 성능에 악영향을 미친다.

## 1.5 이벤트 루프와 비동기 통신의 이해

### 1.5.1 싱글 스레드 자바스크립트

- 자바스크립트가 싱글 스레드로 설계된 이유 : 자바스크립트가 처음 나올 때는 버튼 위에 이미지를 띄우거나, 간단한 경고창을 띄우거나, 폼을 처리하는 등 아주 기초적인 수준에만 제한적으로 사용됐다. 또한, 동시에 여러 쓰레드가 DOM을 조작할 수 있으면 메모리 공유로 인해 타이밍 이슈가 발생할 수 있고 브라우저의 DOM 표시에 큰 문제를 야기할 수 있다.

### 1.5.2 이벤트 루프란?

자바스크립트 런타임 외부에서 자바스크립트의 비동기 실행을 돕기 위해 만들어진 장치이다.

#### 호출 스택과 이벤트 루프

- 호출 스택은 자바스크립트에서 수행해야 할 코드나 함수를 순차적으로 담아두는 스택이다.
- 이 호출 스택이 비어있는지 확인하는 것이 바로 이벤트 루프다. 단순히 이벤트 루프만의 단일 스레드 내부에서 이 호출 스택 내부에 수행해야 할 작업이 잇는지 확인하고 수행해야 할 코드가 있다면 자바스크립트 엔진을 이용해 실행한다.
- 태스크 큐란 실행해야 할 태스크의 집합을 의미한다. 이벤트 루프는 이러한 태스크 큐를 한 개 이상 가지고 있다.
- 이벤트 루프의 역할을 호출 스택에 실행 중인 코드가 있는지, 그리고 태스크 큐에 대기 중인 함수가 있는지 반복해서 확인하는 역할을 한다. 호출 스택이 비었다면 태스크 큐에 대기 중인 작업이 있는지 확인하고, 이 작업이 실행하 가능한 오래된 것부터 순차적으로 꺼내와서 실행하게 된다. 이 작업 또한 마찬가지로 태스크규가 빌 때까지 이뤄진다.
- 자바스크립트 코드는 싱글 스레드가 이뤄지지만 외부 Web API 등으로 실행되고 콜백이 태스크 큐에 들어가는 것이다.

### 1.5.3 태스크 큐와 마이크로 태스크 큐

마이크로 태스크 큐는 기존 태스크 큐보다 우선권을 갖는다. 마이크로 태스크 큐가 빌 때까지는 기존 태스크 큐의 실행은 뒤로 미뤄진다.  
각 태스크에 들어가는 대표적인 작업은 다음과 같다

- 태스크 큐 : setTimeout, setInterval, setImmediate
- 마이크로 태스크 큐 : process, nextTick, Promise, queueMicroTask, MutationObserver

그렇다면 렌더링은 언제 실행될까? 태스크 큐를 실행하기 전에 먼저 마이크로 태스크 큐를 실행하고, 이 마이크로 태스크 큐를 실행한 뒤에 렌더링이 일어난다. 각 마이크로 태스크 큐 작업이 끝날 때마다 한 번씩 렌더링할 기회를 얻게 된다.
