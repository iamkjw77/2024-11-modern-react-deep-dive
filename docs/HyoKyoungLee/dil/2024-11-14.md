# 5장 리액트와 상태 관리 라이브러리

## 5.1 상태 관리는 왜 필요한가?

상태는 어떠한 의미를 지닌 값이며 애플리케이션의 시나리오에 따라 지속적으로 변경될 수 있는 값을 의미한다.

#### 상태로 분류될 수 있는 것

- UI: 다크/라이트 모드, 라디오를 비롯한 각종 input, 알림창의 노출 여부 등 많은 종류의 상태가 존재한다.
- URL: 브라우저에 관리되고 있는 상태값으로, 사용자의 라우팅에 따라 변경된다.
- 폼(form): loading, submit, disabled, validation 등 모두 상태로 관리된다
- 서버에서 가져온 값: 클라이언트에서 서버로 요청을 통해 가져온 값도 상태로 볼 수 있다. 대표적으로 API 요청이 있다.

웹 서비스에서 점차 다양한 기능이 제공됨에 따라 웹 내부에서 관리해야 할 상태도 점차 비례해서 증가하고 있다. 점차 증가하는 상태를 효과적으로 관리하는 방법을 계속해서 고민해야 한다.

### 5.1.1 리액트 상태 관리의 역사

#### Flux 패턴의 등장

- 페이스북 팀은 양방향 데이터 바인딩이 코드의 양을 많아지게 하고 변경 시나리가 복잡해질수록 관리가 어려워진다는 점으로 고려해 단방향으로 데이터 흐름을 변경하는 것을 제언했고, 이것이 바로 Flux 패턴이다.
- Flux 패턴 : **`Action`** → **`Dispatcher`** → **`Model`** → **`View`**
- 각 용어의 정의

  - Action: 어떠한 작업을 처리할 액션과 그 액션 발생 시 함께 포함시킬 데이터를 의미한다. 액션 타입과 데이터를 각각 정의해 이를 디스패처로 보낸다.
  - Dispatcher: 액션을 스토어에 보내는 역할을 한다. 콜백 함수 형태로 앞서 액션이 정의한 타입과 데이터를 모두 스토어에 보낸다.
  - Store: 여기에서 실제 상태에 따른 값과 상태를 변경할 수 있는 메서드를 가지고 있다. 액션의 타입에 따라 어떻게 이를 변경할지가 정의돼 있다.
  - View: 리액트의 컴포넌트에 해당하는 부분으로, 스토어에서 만들어진 데이터를 가져와 화면을 렌더링하는 역할을 한다. 또한 뷰에서도 사용자의 입력이나 행위에 따라 상태를 업데이트하고자 할 수 있을 것이다. 이 경웅에는 다음 그림처러 뷰에서 액션을 호출하는 구조로 구성된다.

- 이러한 단방향 데이터 흐름 방식은 사용자의 입력에 따라 데이터를 갱신하고 화면을 어떻게 업데이트해야 하는지도 코드로 작성해야 하므로 코드의 양이 많아지고 개발자도 수고로워진다. 그러나 데이터의 흐름은 모두 액션이라는 한 방향(단방향)으로 줄어들므로 데이터의 흐름을 추적하기 쉽고 코드를 이해하기가 수월해진다.

- Flux 패턴을 따르는 라이브러리
  - Flux
  - alt
  - Reflux
  - NuclearJS
  - Fluxible
  - Fluxxor

#### 시장 지배자 리덕스의 등장

- 리덕스는 Flux 구조에 Elem 아키텍처를 도입한 라이브러리이다.
- Elem은 웹페이지를 선언적으로 작성하기 위한 언어다. Elem 아키텍처의 핵심은 model, update, view이다.
  - model: 애플리케이션의 상태를 의미한다. 초깃값으로는 0이 주어졌다.
  - view: 모델을 표현하는 HTML을 말한다. Model을 인수로 받아서 HTML을 표현한다.
  - update: 모델을 수정하는 방식을 말한다. Increment, Decrement를 선언해 각각의 방식이 어떻게 모델을 수정하는지 나타냈다.
- 리덕스는 하나의 상태 객체를 스토어에 저장해 두고, 이 객체를 업데이트하는 작업을 디스패치해 업데이트를 수행한다. 이러한 작업은 reducer 함수로 발생시킬 수 있는데, 이 함수의 실행은 웹 애플리케이션 상태에 대한 완전히 새로운 복사본을 반환한 다음, 애플리케이션에 이 새롭게 만들어진 상태를 전파하게 된다.
- props drilling을 해결할 수 있고 스토어 필요한 컴포넌트라면 connect만 쓰면 스토어에 바로 접근할 수 있는 편리함으로 리액트에 인기있는 라이브러리였지만, 보일러 플레이트가 많다는 단점이 있다.

#### Context API와 useContext

- 리액트 팀은 리액트 16.3에서 전역 상태를 하위 컴포넌트에 주입할 수 있는 새로운 Context API를 출시했다.
- 리액트 16.3 버전 이전에도 context가 존재했으며, 이를 다루기 위한 getChildContext()를 제공했었다. 하지만 불필요한 렌더링을 발생시키고 컴포넌트와 결합도가 높아지는 등의 단점이 있었다. 이러한 단점을 해결하기 위해 새로운 context가 출시됐다.
- Context API는 상태 관리가 아닌 주입을 도와주는 기능이며, 렌더링을 막아주기 기능 또는 존재하지 않으니 사용할 때 주의가 필요하다

#### 훅의 탄생, 그리고 React Query와 SWR

- 훅과 state의 등장으로 이전에는 볼 수 없던 방식의 상태 관리가 등장하는데 바로 React Query와 SWR이다.
- 2개 모두 외부에서 데이터를 부러오는 fetch를 관리하는데 특화된 라이브러리지만, API 호출에 대한 상태를 관리하고 있기 때문에 HTTP 요청에 특화된 상태 관리 라이브러리라 볼 수 있다.

#### Recoil, Zustand, Jotai, Valtio에 이르기까지

- 요즘 새롭게 떠오르고 있는 많은 상태라이브러리는 기존의 리덕스 같은 라이브러리와는 차이점이 있는데 바로 훅을 사용해 작은 크기의 상태를 효율적으로 관리한다는 것이다.
- 이는 기존 상태 관리 라이브러리의 아쉬운 점으로 지적받던 전역 상태 패러다임에서 벗어나 개발자가 원하는 만큼의 상태를 지역적으로 관리하는 것을 가능하게 만들었고, 훅을 지원함으로써 함수 컴포넌트에서 손쉽게 사용할 수 있다는 장점이 있다.
