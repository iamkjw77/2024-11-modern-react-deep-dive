## 12.5 누적 레이아웃 이동(CLS)

### 12.5.1 정의

- 페이지의 생명주기 동안 발생하는 모든 예기치 않은 이동에 대한 지표를 개선하는 것이다.
- 다른 지표와 마찬가지로 이 지표가 낮을수록, 즉 사용자가 겪는 예상치 못한 레이아웃 이동이 적을수록 더 좋은 웹사이트이다.

### 12.5.2 의미

- 누적 레이아웃 이동은 사용자의 가시적인 콘텐츠에 영향을 미쳐야 하기 때문에 뷰포트 내부의 요소에 대해서만 측정한다.
- 최초 렌더링이 시작된 위치에서 만약 레이아웃의 이동이 발생한다면 누적 레이아웃 이동 점수로 기록하게 된다.
- 단순히 요소가 추가된다고 해서 무조건 누적 레이아웃 이동으로 간주되는 것은 아니다. 요소가 추가됐다 하더라도 다른 요소의 시작 위치에 영향을 미치지 않았다면 레이아웃 이동으로 간주되지 않는다.
- 사용자 액션으로 인해 발생한 레이아웃 이동은 점수에 포함되지 않는다. - 이 점수를 계산할 때 포함되는 내용은 다음과 같다
  - 영향분율: 레이아웃 이동이 발생한 요소의 전체 높이와 뷰포트 높이의 비율을 의미한다
  - 거리분율: 레이아웃 이동이 발생한 요소가 뷰포트 대비 얼마나 이동했는지를 의미한다

### 12.5.3 예제

생략

### 12.5.4 기준 점수

- 좋은 점수는 **0.1 이하**인 경우, 0.25 이하인 경우 보통이며 그 외에는 개선이 필요한 나쁜 점수로 보고된다

### 12.5.5 개선 방안

#### 삽입이 예상되는 요소를 위한 추가적인 공간 확보

- useEffect의 내부에서 요소에 영향을 미치는 작업, 특히 뷰포트 내부에서 노출될 확률이 높은 작업은 최소화하는 것이 좋다.
- 스켈레톤 UI처럼 미리 무언가 동적으로 뜰 것으로 예상되는 공간을 미리 확보해 두는 것도 좋은 방법이다. 레이아웃 이동을 막으면서 클라이언트 시점에 정해지는 콘텐츠를 안정적으로 보여줄 수 있다
- 가장 좋은 방법은 서버 사이드 렌더링이다. 서버에서 이러한 동적인 요소의 유무를 사전에 판단해 클라이언트에 HTML을 미리 제공해 준다면 클라이언트에서는 이러한 고민을 할 필요 없이 깔끔하게 처리할 수 있다.

#### 폰트 로딩 최적화

- 폰트로 인해 레이아웃 이동이 발생할 수 있느 문제는 아래 2가지이다
  - FOUT: HTML 문서에서 지정한 폰트가 보이지 않고 대체 기본 폰트로 보이다가 뒤늦게 폰트가 적용되는 현상
  - FOIT: HTML 문서에서 지정한 폰트가 보이지 않고, 기본 폰트도 없어서 텍스트가 없는 채로 있다가 뒤늦게 폰트가 로딩되면서 페이지에 렌더링되는 현상
- 사용자 기기의 기본 폰트 이외에 다른 폰트로 웹페이지를 보여주고 싶다면 아래와 같은 점을 유념해야 한다

  - **`<link>`의 preload 사용**
    - `<link>` 요소의 rel=preload는 페이지에서 즉시 필요로 하는 리소스를 명시하는 기능이다.
    - preload로 지정된 요소는 웹페이지의 생명주기에서 초기에 불러와야 하는 중요한 리소르로 간주되므로 브라우저는 리소를 더 빠르게 사용할 수 있도록 준비해 준다.
    - 따라서 rel=preload로 스타일이나 폰트를 지정하면 페이지의 렌더링을 가로막거나 레이아웃을 방해할 가능성이 줄어든다.
  - **font-family**
    - 폰트를 불러올 수 있는 방법은 크게 5가로 나뉜다
    - auto(기본값): 브라우저가 폰트를 불러오는 방법을 결정한다.
    - block: 폰트가 로딩되기 전까지 렌더링 중단(최대 3초), 웹 폰트의 로딩이 완료되면 비로스 폰트 적용
    - swap: 앞서 언급한 FOUT 방식, 폴백 폰트로 렌더링한 다음, 웹 폰트의 로딩이 완료되면 웹 폰트 적용
    - fallback: 100ms간 텍스트가 보이지 않고 그 이후에 폴백 폰트로 렌더링, 3초 안에 폰트가 로딩되면 해당 웹 폰트로 전환하고, 그렇지 않으면 폴백 폰트 유지
    - optional: fallback과 유사, 100ms 동안 보이지 않고 폴백 폰트로 렌더링한다는 점은 동일하나 네트워크 상태를 파악해 0.1초 이내로 폰트가 다운로드되지 않으면 해당 폰트를 보여주지 않음

- 요약하자면 최대한 중요한 폰트의 다운로드를 우선순위에 밀어넣고, 이 우선순위를 활용했음에도 빠르게 로딩하는데 실패했다면 다음을 기약하고 기본 폰트를 노출하는 것이다.

#### 적절한 이미지 크기 설정

- 많은 웹사이트가 반응형 웹사이트를 구현하면서 누적 레이아웃 이동이 커지는 결과를 낳게 되었다
- `width:100% height:auto`로 지정하면 이미지의 높이에 자동으로 비례해서 auto를 설정해준다. 하지만 이미지가 완전히 다운로드되기 전까지는 높이를 알 수 없기 때문에 이미지의 높이를 높게 잡아 뒀다가 레이아웃 이동이 크게 발생한다
- 적절한 이미지 크기를 설정하기 위한 방법은 아래와 같다

  - **width, height 지정**

    - width:100% height:auto; 와 함께 width, height를 원하는 비율로 지정하면 브라우저가 이미지를 로딩하기 전에 적절한 가로세로 비율을 계산해 이미지가 표시되는 만큼 면적을 할당해 둔다.
    - 이는 aspect-ratio 속성 덕분인데, 이 속성은 브라우저의 유저 에이전트 스타일시트에 포함돼 있으며, 이미지의 가로세로 비율을 자동으로 맞춰주는 역할을 한다

    ```js
    import "./style.css"; // width: 100%, height: auto;

    export default function App() {
      return (
        <div className="App">
          <img src="/image.jpg" alt="이미지" width="1600" height="900" />
        </div>
      );
    }
    ```

    - **만약 뷰포트 너비에 맞춰서 다른 이미지를 제공하고 싶은 경우 srcset 속성을 사용하는 것이 좋다**

    ```html
    <img
      width="1000"
      height="1000"
      src="image-1000.jpg"
      srcset="image-1000.jpg 1000w, image-2000.jpg 2000w, image-3000.jpg 3000w"
      alt="이미지"
    />
    ```

### 12.5.6 핵심 웹 지표는 아니지만 성능 확인에 중요한 지표들

#### 최초 바이트까지의 시간(Time To First Byte, TTFB)

- 페이지를 요청했을 때 요청이 완전히 완료되는 데 걸리는 시간을 측정하는 것이 아니라 최초의 응답이 오는 바이트까지가 얼마나 걸리는지를 측정하는 지표이다.
- 이 지표는 600ms 이상 걸릴 경우 개선이 필요한 것으로 간주된다
- 최초 바이트까지의 시간을 개선하기 위한 고려사항
  - 서버 사이드 렌더링을 수행하고 있다면 로직와 API 호출을 최적화해서 페이지를 빨리 준비 시켜야 한다
  - 웹페이지의 주된 방문객의 국적을 파악해 해당 국적과 가깝게 서버를 위치시키는 것이 좋다
  - 리액트 서버 사이드 렌더링이라면 renderToNodeStream, renderToStaticNodeStream과 같은 스트리밍 API를 사용하는 것이 좋다

#### 최초 콘텐츠풀 페인트(FCP)

- 웹사이트에 접속한 순간부터 페이지에 뭐라도 뜨기 시작한 시점까지의 시간이다
- 일반적으로 좋은 점수는 **1.8초 이내**이며, 3.0초 이내는 보통, 그 이후는 개선이 필요하다
- FCP 개선방법
  - TTFB를 개선한다. 렌더링을 최대한 빠르게 하기 위해 최초 바이트까지의 시간을 단축해야 한다
  - 렌더링을 가로막는 리소스를 최적화한다
  - 페이지 리다이렉트를 최소화한다.
  - DOM이 복잡하고 크다면 렌더링되는데 시간이 오래 걸리기 때문에 크기를 최적화한다
