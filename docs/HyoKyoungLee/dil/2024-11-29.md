### 8.2.3 리액트 컴포넌트 테스트 코드 작성하기

- 리액트 컴포넌트 테스트 순서

1. 컴포넌트를 렌더링한다
2. 필요하다면 컴포넌트에서 특정 액션을 수행한다
3. 컴포넌트 렌더링과 2번의 액션을 통해 기대하는 결과와 실제 결과를 비교한다

#### 프로젝트 생성

- create-react-app에는 이미 react-testing-library가 포함돼 있으므로 별도로 설치할 필요가 없다

```
npx craete-react-app react-test --template typescript
```

- 위 명령어로 생성된 프로젝트에는 App.text.tsx 파일이 생성되어 있다

```js
import React from "react";
import { render, screen } from "@testing-library/react";
import App from "./App";

test("renders learn react link", () => {
  render(<App />); // 1
  const linkElement = screen.getByText(/learn react/i); // 2
  expect(linkElement).toBeInTheDocument(); // 3
});
```

- 위 코드 내용은 아래와 같다
  1. `<App />`을 렌더링한다
  2. 렌더링하는 컴포넌트 내부에서 "learn react"라는 문자열을 가진 DOM 요소를 찾는다
  3. expect(linkElement).toBeInTheDocument()라는 어설션을 활용해 2번에서 찾은 요소가 document 내부에 있는지 확인한다

#### HTML 요소 여부를 확인하는 메소드

- 일반적으로 리액트 컴포넌트 테스트 시나리오는 HTML 요소가 있는지 확인한다. 확인하는 방법 3가지는 아래와 같다
  1. getBy...: 인수의 조건에 맞는 요소를 반환하며, 해당 요소가 없거나 두 개 이상이면 에러를 발생시킨다. 복수 개를 찾고 싶다면 getAllBy...를 사용하면 된다
  2. findBy...: getBy...와 거의 유사하나 한 가지 큰 차이점은 Promise를 반환한다는 것이다. 즉, 비동기로 찾는다는 것을 의미하며, 기본값으로 1000ms의 타임아웃을 가지고 있다. 마찬가지로 두 개 이상이면 에러를 발생시키지만 복수 개를 찾고 싶다면 findAllBy...를 사용하면 된다. 이러한 특징 때문에 findBy는 비동기 액션 이후에 요소를 찾을 때 사용한다
  3. queryBy...: 인수의 조건에 맞는 요소를 반환하는 대신, 찾지 못한다면 null을 반환한다. getBy...와 findBy...는 찾지 못하면 에러를 발생시키기 때문에 찾지 못해도 에러를 발생시키지 않고 싶다면 queryBy..를 사용하면 된다. 마찬가지로 복수 개를 찾았을 때는 에러를 발생시키며, 복수 개를 찾고 싶다면 queryAllBy...를 사용하면 된다

#### 정적 컴포넌트

- 별도의 상태가 존재하지 않아 항상 같은 결과를 반환하는 컴포넌트인 정적 컴포넌트는 테스트를 원하는 컴포넌트를 렌더링한 다음, 테스트를 원하는 요소를 찾아 원하는 테스트를 수행하면 된다.

#### 동적 컴포넌트

- 리액트 테스팅 라이브러리에서 사용자의 입력을 흉내 내고, 또 state의 변화에 따른 컴포넌트의 변화를 테스트할 수 있다

#### 비동기 이벤트가 발생하는 컴포넌트

- jest 등을 활용해서 fetch를 모킹하면 서버에서 오는 응답 시나리오를 모두 테스트하기에는 fetch가 할 수 있는 다양한 일을 일일이 모킹해야 하므로 테스트 코드가 길어지고 유지보수도 어렵다
- 이러한 문제를 해결하기 위해 MSW(Mock Service Worker)를 사용한다
- MSW는 모킹 라이브러리로, 브라우저에서는 서비스 워커를 활용해 실제 네트워크 요청을 가로채는 방식이고, Node.js에서는 https나 XMLHttpRequest의 요청을 가로채는 방식으로 작동한다.

### 8.2.4 사용자 정의 훅 테스트

- 훅이 들어가 있는 컴포넌트를 만들 경우 : 테스트 코드 작성 외에 작업이 더 추가된다
- 훅이 들어있는 컴포넌트에 대해 별도로 훅에 대한 테스트를 만들 경우 : 해당 훅이 모든 테스트 케이스를 커버하지 못할 경우 또 다른 테스트 가능한 컴포넌트를 찾아야 한다
- react-hooks-testing-library를 활용하면 훅을 편리하게 테스트할 수 있다
- renderHook 함수에서 훅을 편리하게 테스트파기 위한 rerender, unmount 등의 함수도 제공하고 있으므로 사용자 정의 훅을 테스트하고 싶다면 꼭 한번 사용해보자

### 8.2.5 테스트를 작성하기에 앞서 고려해야 할 점

#### 테스트 커버리지를 맹신하면 안된다

- 흔히들 알고 있는 사실 중 하나는 테스트 커버리지가 높을 수록 좋고 꾸준히 테스트 코드를 작성해야 한다
- 하지만 테스트 커버리지는 단순히 얼마나 많은 코드가 테스트되고 있는지를 나타내는 지표일 뿐, 테스트가 잘되고 있는지를 나타내는 것은 아니다. 그러므로 절대 테스트 커버리지를 맹신해서는 안 된다

#### 실무에서는 테스트 코드를 운영할 만큼 여유롭지 않다

- 그리고 테스트 커버리지를 100%까지 끌어올릴 수 있는 상황은 생각보다 드물다
- TDD라고 하는 개발 방법론을 차용해서 테스트를 우선시하더라도 서버 코드와는 다르게 프론트엔드 코드는 사용자의 입력이 매우 자유롭기 때문에 이러한 모든 상황을 커버해 테스트를 작성하기란 불가능하다
- 테스트를 QA에 의존해 개발을 빠르게 진행해야 할 수도 있고, 이후에 또 개발해야 할 기능이 산적해 있을 수도 있다

#### 애플리케이션에서 가장 취약하거나 중요한 부분을 파악해야 한다

- 테스트 코드를 작성하기 전에 생각해 봐야 할 최우선 과제는 애플리케이션에서 가장 취약하거나 중요한 부분을 파악하는 것이다
- 테스트 코드는 반드시 사용자의 작업과 최대한 유사하게 작성돼야 한다. 예를 들어 결제를 위해 사용자가 입력하는 절차, 장바구니, 주소 입력, 결제까지의 과정을 모두 사용자와 최대한 비슷한 입장에서 테스트를 작성하는 것이 필요하다
- 이처럼 애플리케이션에서 가장 핵심이 되는 부분부터 먼저 테스트 코드를 하나씩 작성해 나가는 것이 중요하다
- 테스트 코드는 소프트웨어 품질에 대한 확신을 얻기 위해 작성하는 것이다

### 8.2.6 그 밖에 해볼 만한 여러 가지 테스트

- 유닛 테스트 : 각각의 코드나 컴포넌트가 독립적으로 분리된 환경에서 의도된 대로 정확히 작동하는지 검증하는 테스트
- 통합 테스트 : 유닛 테스트를 통과한 여러 컴포넌트가 묶여서 하나의 기능으로 정상적으로 작동하는지 확인하는 테스트
- 엔드 투 엔드(End to End Test) : 흔히 E2E 테스트라 하며, 실제 사용자처럼 작동하는 로봇을 활용해 애플리케이션의 전체적인 기능을 확인하는 테스트
