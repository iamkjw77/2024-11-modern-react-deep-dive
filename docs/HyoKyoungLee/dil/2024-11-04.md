# 1장 리액트 개발을 위해 꼭 알아야 할 자바스크립트

## 1.1 자바스크립트의 동등 비교

리액트 컴포넌트의 렌더링이 일어나는 이유 중 하나가 바로 props의 동등 비교에 따른 결과다. 그리고 이 props의 동등 비교는 객체의 얕은 비교를 기반으로 이뤄지는데, 이 얕은 비교가 리액트에서 어떻게 작동하는지 이해하지 못하면 렌더링 최적화에 어려움을 겪을 가능성이 크다.

### 1.1.1 자바스크립트의 데이터 타입

#### 원시타입

객체 타입이 아닌 다른 모든 타입을 의미한다. 객체가 아니므로 메서드를 갖지 않는다. 총 7개의 원시 타입이 있다.

- undefined : 선언한 후 값을 할당하지 않은 변수 또는 값이 주어지지 않은 인수에 자동으로 할당되는 값
- null : 아직 값이 없거나 비어 있는 값을 표현할 때 사용한다
- boolean : 참(true)과 거짓(false)만을 가질 수 있는 데이터 타입, 조건문에서 많이 쓰인다
- number : -(2^53-1)과2^53-1 사이의 모든 숫자 값, 2진수, 8진수, 16진수 등의 별도 데이터 타입을 제공하지 않으므로 각 진수별로 값을 표현해도 모두 10진수로 해석되어 동일한 값으로 표시된다
- BigInt : 2^53-1보다 더 큰 숫자를 저장할 수 있는 타입
- String : 텍스트 타입의 데이터를 저장하기 위해 사용된다. 한 쌍의 작은 따옴표나 큰 따옴표 또는 내장 표현식을 허용하는 문자열 리터럴 표현 방식인 백틱으로도 표현할 수 있다.
- Symbol : 중복되지 않는 어떠한 고유한 값

#### 객체타입

앞에 7가지의 원시 타입 이외의 모든 것, 즉 자바스크립트를 이루고 있는 대부분의 타입이 바로 객체 타입이다. 배열, 함수, 정규식, 클래스 등이 포함된다
객체 타입은 참조를 전달한다고 해서 참조 타입으로도 불린다는 사실이다. 여기서 우리가 알아둬야 할 자바스크립트 동등 비교 특징이 나타난다

```js
typeof [] === "object"; // true
typeof {} === "object"; // true

function hello() {}
typeof hello === "function"; // true

const hello1 = function () {};

const hello2 = function () {};

// 객체인 함수의 내용이 육안으로는 같아 보여도 참조가 다르기 때문에 false가 반환된다
hello1 === hello2; // false
```

### 1.1.2 값을 저장하는 방식의 차이

원시 타입과 객체 타입의 가장 큰 차이점은 값을 저장하는 방식이다. 값을 저장하는 방식의 차이가 동등 비교를 할 때 차이를 만드는 원인이 된다.

- 먼저 원시 타입은 불변 형태의 값으로 저장된다. 그리고 이 값은 변수 할당 시점에 메모리 영역을 차지하고 저장된다

```js
let hello = "hello world";
let hi = hello;

console.log(hello === hi); // true
```

- 위와 같이 값을 전달하는 방식이 아닌 각각 선언하는 방식으로도 동일한 결과를 볼 수 있다

```js
let hello = "hello world";
let hi = "hello world";

console.log(hello === hi); // true
```

- 반면 객체는 프로퍼티를 삭제, 추가, 수정할 수 있으므로 원시 값과 다르게 변경 가능한 형태로 저장되며 값을 복사할 때도 값이 아닌 참조를 전달하게 된다.

```js
// 다음 객체는 완벽하게 동일한 내용을 가지고 있다.
var hello = {
  greet: "hello, world",
};

var hi = {
  greet: "hello, world",
};

// 그러나 동등 비교를 하면 false가 나온다
console.log(hello === hi); // false

// 원시값인 내부 속성값을 비교하면 동일하다
console.log(hello.greet === hi.greet); // true
```

- **객체는 값을 저장하는 게 아니라 참조를 저장하기 때문에 앞서 동일하게 선언했던 객체라 하더라도 저장하나는 순간 다른 참조를 바라보기 때문에 false를 반환하게 된다.** 즉, 값은 같았을지언정 참조하는 곳이 다른 셈이다. 반면 참조를 전달하는 경우에는 이전에 원시값에서 했던 것과 같은 결과를 기대할 수 있다.

```js
var hello = {
  greet: "hello, world",
};

var hi = hello;

console.log(hi === hello); // true
```

- 위 예제에서는 변수명 및 각 변수명의 주소가 서로 다르지만 참조값이 복사(얕은 복사)되어 value가 가리키는 주소는 동일하다.

### 1.1.3 자바스크립트의 또 다른 비교 공식, Object.is

ES6에서 새로 도입된 비교 문법으로 동등 비교 ===가 가지는 한계를 극복하기 위해 만들어 졌다. Object.is가 ==나 ===와 다른 점은 다음과 같다.

#### == vs Object.is

- == 비교는 같음을 비교하기전에 양쪽이 같은 타입이 아니라면 비교할 수 있도록 강제로 형변환한 후에 비교한다. 하지만 Object.is는 이러한 작업을 하지 않는다. 즉, ===와 동일하게 타입이 다르면 그냥 false다.

#### === vs Object.is

- 이 방법에도 차이가 있다. 다음 코드를 보면 알 수 있듯. Object.is가 좀 더 개발자가 기대하는 방식으로 정확히 비교한다.

```js
-0 === +0; // true
Object.is(-0, +0); // false

Number.NaN === NaN; // false
Object.is(Number.NaN, NaN); // true

NaN === 0 / 0; // false
Object.is(NaN, 0 / 0); // true
```

- 하지만 Object.is를 사용한다 하더라도 객체 비교에는 별 차이가 없다

### 1.1.4 리액트에서의 동등 비교

리액트에서 사용하는 동등 비교는 Object.is이다.  
리액트에서는 얕은 비교를 할 수 있는 [shalloweEual](https://www.npmjs.com/package/shallowequal)이라는 함수를 만들어 사용한다  
Object.is로 먼저 비교를 수행한 다음에 Object.is에서 수행하지 못하는 비교, 즉 객체 간 얕은 비교를 한 번 더 수행하는 것을 알 수 있다. 객체 간 얕은 비교란 객체의 첫 번째 깊이에 존재하는 값만 비교한다는 것을 의미한다.

```js
// Object.is는 참조가 다른 객체에 대해 비교가 불가능하다
Object.is({ hello: "world" }, { hello: "world" }); // false

// 반면 리액트 팀에서 구현한 shallowEqual은 객체의 1 depth까지는 비교가 가능하다
shallowEqual({ hello: "world" }, { hello: "world" }); // true

// 그러나 2 depth까지 가면 이를 비교할 방법이 없으므로 false를 반환한다
shallowEqual({ hello: { hi: "world" } }, { hello: { hi: "world" } }); // false
```

- 이렇게 객체의 얕은 비교까지만 구현한 이유는 무엇일까? 먼저 리액트에서 사용하는 JSX props는 객체이고, 그리고 여기에 있는 props만 일차적으로 비교하면 되기 때문이다.
- 이러한 특성을 안다면 props에 또 다른 객체를 넘겨준다면(2 depth) 리액트 렌더링이 예상치 못하게 작동하는 것을 알 수 있다
