# 2024.12.03 DIL

p550 ~

# 깃허브 액션 작성하기

```yml

name: chapter7 build  # name은 액션의 이름이다. 필수값은 아니지만, 액션을 구별하는데 도움이 되므로 이름을 지정하는 것이 좋다

run-name: ${{ github. actor }} has been added new commit. # run-name은 액션이 실행될 때 구별할 수 있는 타이틀명이다. 필수 값은 아님


on:                    # on은 필수값으로, 언제 이 액션을 실행할지를 정의한다
  push:
    branches-ignore:    # main branch를 무시하겠다. CI 하지 않겠다.
      - main


jobs: # jobs는 필수값으로, 해당 액션에서 수행할 잡을 의미한다. 여러 개를 지정하면 병렬로 실행된다

  build: # build는 임의로 지정한 이름으로, name과 같은 역할을 한다고 보면된다, jobs의 하위항목으로 반드시 들여쓰기해야 한다

    runs-on: ubuntu-latest  # 깃허브에서 제공하는 서버를 쓰고 싶다면 ubuntu-latest를 선언하면 된다

    steps: # 해당 잡에서 순차적으로 수행할 작업을 정의한다

      - uses: actions/checkout@v3   # actions/checkout@v3는 깃허브에서 제공하는 기본액션으로, 별도 파라미터를 제공하지 않으면 해당 브랜치의 마지막 커밋을 기준으로 체크아웃한다

      - uses: actions/setup-node@v3 # actions/setup-node@v3 역시 깃허브에서 제공하는 기본액션으로, 해당 러너에 Node.js를 설치한다
        with: node-version: 16      # Node.js 16 버전을 설치한다
      # run을 통해 수행할 작업을 명시했다
      - name: 'install dependencies' # 의존성을 설치하는 작업을 수행한다
        working-directory: ./chapter7/my-app # 터미널의 cd 명령과 비슷한 역할, 해당 디렉터리에서 수행하겠다는 뜻, 만약 루트에서 실행해도 된다면 따로 지정하지 않아도 된다
        run: npm ci # 수행할 작업을 명시

      - name: 'build'
        working-directory: ./chapter7/my-app
        run: npm run build
```

### 액션 작성

- 위처럼 액션을 작성하면 프로젝트를 빌드하는 CI를 작성할 수 있다.
- push마다 빌드가 발생하면 액션이 굉장히 많이 실행되기 때문에 트리거를 조정할 필요도 있고, npm이 아닌 yarn이나 pnpm을 쓴다면 별도로 패키지를 설치해야한다.
- 그러나 확실한 사실은 젠킨스를 처음부터 구축해서 사용하는 것보다는 훨씬 쉽게 CI를 구축할 수 있다는 것
- 별도의 서버를 구축하고, 젠킨스를 설치할 필요도 없이 저장소에 yaml 파일을 하나 추가해 CI를 구축할 수 있어 매우 용이하다.

### 브랜치 보호 규칙

- 머지하기 전에 꼭 성공해야 하는 액션이 있다면 별도로 저장소에 브랜치 보호 규칙을 추가할 수 있따.
- Settings -> Code and automation -> Branches -> Add branch protection rule을 클릭해 보호 가능
  [브랜치 보호 규칙 사진](<![image](https://github.com/user-attachments/assets/8c4d1a32-f790-44bd-994a-ea4900a416e6)>)

### 직접 작성하지 않고 유용한 액션과 깃허브 앱 가셔다 쓰기

- 깃허브에서는 Marketplaces 라는 서비스를 제공해 여러 사용자가 만들어 놓은 액션을 손쉽게 가져다 쓸 수 있도록 운영하고 있다.
- 공개된 액션을 적절히 활용하면 유용하게 사용할 수 있다.

- actions/checkout: 깃허브 저장소를 체크아웃하는 액션이다. 저장소를 기반으로 작업을 해야 한다면 반드시 필요하다. 일반적으로는 아무런 옵션 없이 사용해 해당 액션을 트리거한 최신 커밋을 불러오지만 ref를 지정해 특정 브랜치나 커밋을 체크아웃할 수도 있다.

- actions/set-up-node: Node.js를 설치하는 액션이다. Node.js를 사용하는 프로젝트라면 반드시 필요하다. 설치할 Node.js 버전을 지정할 수도 있다.

- actions/stale: 오래된 이슈나 PR을 자동으로 닫거나 더 이상 커뮤니케이션하지 못하도록 닫는다. 저장소가 오래되어 과거에 생성된 이슈나 PR이 너무 많을 경우 정리하는데 도움이 된다.

- actions/dependency-review-action: 의존성 그래프에 대한 변경, 즉, package.json, package.lock.json, pnpm-lock.json 등의 내용이 변경되었을 때 실행되는 액션으로, 의존성을 분석해 보안 또는 라이선스애 문제가 있다면 이를 알려준다.

- github/codeql-action: 깃허브의 코드 분석 솔루션인 code-ql을 활용해 저장소 내 코드의 취약점을 분석해준다. languages에 javascript만 설정해두면 자바스크립트와 타입스크립트를 모두 검사하므로 특정 스케줄에 맞춰서 실행하거나 CI로 활용할 수 있다.

### calibreapp/image-actions

- 저장소에 포함돼 있는 이미지를 최적화 하는 액션
- PR로 올라온 이미지(jpg,jpeg,png 등)을 sharp 패키지를 이용해 거의 무손실로 압축해 다시 커밋해주는 액션
- 몇 줄 안되는 액션만 작성해두면 저장소 내의 이미지를 좀 더 효율적으로 관리할 수 있다.
- 액션을 작성하는 것조차 번거롭게 느껴진다면 imgbot 이라고 하는 앱을 사용할 수도 있다.
  - 단 플랜에 따라 유료로 제공될 수 있음

### lirantal/is-website-vulnerable

- 특정 웹사이트를 방문해 해당 웹사이트에 라이브러리 취약점이 존재하는지 확인하는 깃허브 액션
- Snyk 라는 솔루션을 기반으로 작동하며, 실제로 웹사이트를 방문해서 웹사이트에 노출되고 있는 라이브러리를 분석한 결과를 ㅏㅇㄹ려줌
- 실제 배포에 포함되지 않은 devDependencies나 번들링 과정에서 트리쉐이킹으로 인해 사라진 코드는 취약점으로 진단되지 않는다.

### lighthouse CI

- 웹 성능 지표인 라이트하우스를 CI기반으로 실행할 수 있도록 도와주는 도구

# 깃허브 Dependabot으로 보안 취약점 해결하기

- 깃허브에서 제공하는 강력한 기능 중 하나는 Dependabot으로, 의존성에 문제가 있다면 이에 대해 문제를 알려주고 가능하다면 해결할 수 있는 풀 리퀘스트까지 열어준다.

### 버전

- 버전에 대해 이야기하려면 유의적 버전에 대해 먼저 알아야 한다.

### 유의적 버전

- 버전은 주.부.수로 구성돼 있으며 각각의 정의는 다음과 같다.
  - 기존 버전은 호환되지 않게 API가 바뀌면 `주버전`을 올리고
  - 기존 버전과 호환되면서 새로운 기능을 추가할 때는 `부 버전`을 올리고,
  - 기존 버전과 호환되면서 버그를 수정한 것이라면 `수 버전`을 올린다.
  - Ex) 16.0.1 -> 주.부.수
  - 16.0.0 -> 16.0.1로 변경 -> 버그 수정
  - 16.0.0 -> 16.1.0로 변경 -> 기존 기능을 사용하는 방법은 바뀌지 않고, 새로운 기능 추가
  - 16.0.0 -> 17.0.0로 변경 -> 16.0.0과 호환되지 않도록 제공하는 API에서 변경이 일어남
- 주 버전 0(0.y.z)는 초기 개발을 위해 쓴다 -> 주의를 기울여야함
- 버그수정이지만 API 스펙 변경을 동반한다면 주버전을 올려야함

### npm 버전 규칙

- react@16.0.0 : 버전앞에 아무런 특수 기호가 없다면 정확히 해당 버전에 대해서만 의존
- react@^16.0.0 : 버전앞에 ^ 기호가 있다면 16.0.0버전과 호환, 즉 16.0.0이상 ~ 17.0.0 미만은 모두 호환
- react@~16.0.0 : 버전앞에 ~ 기호가 있다면 패치버전만 호환, 즉 16.0.0 이상 ~ 16.1.0 미만은 모두 호환
- 한 가지 염두에 둬야 할 점은 유의적 버전은 어디까지나 개발자들 간의 약속일 뿐, 실제로 해당 API 버전이 유의적 버전에 맞춰 구현돼 있는지는 알 수 없다.

### 의존성

- dependencies : npm i 하면 설치되는 의존성이며, 해당 프로젝트를 실행하는데 꼭 필요한 패키지
- devDependencies : npm i 하면 설치되는 의존성이며, 해당 프로젝트를 실행하는 데는 필요하지 않지만 개발 단계에서 필요한 패키지
- peerDependencies : 주로 서비스보단 라이브러리와 패키지에서 자주 쓰이는 단위, 호환성으로 인해 필요한 경우를 의미

- 패키지를 구분하는 것에 의문을 제기하는 목소리도 존재

  1. 번들러의 존재 : dependencies든 devDependencies로 설치하든 모두 node_modules에 동일하게 설치 -> 최종 결과물에 영향을 미치지 않음
  2. 복잡해진 개발 파이프라인 : 과거에는 구분이 의미가 있었으나 현재는 typescript와 같이 devDependcies에 설치한걸 제외하면 빌드조차 되지 않는 등 문제 발생

- 구분하는게 완전히 무의미한건 아님 -> npm에 업로드할 패키지를 개발한다면 매우 중요함
