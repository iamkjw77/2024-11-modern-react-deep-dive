# 2024.11.08 DIL

p139 ~ p 188

### 리액트 파이버 트리

- 파이버 트리는 두 개가 존재한다.
  1. 현재 모습을 담은 트리 (current)
  2. 작업 중인 상태를 나타내는 트리(workInProgress)
- 리액트는 작업이 끝나면 단순히 포인터만 변경해 workInProgress -> current로 바꿔버림 = 더블버퍼링
- 더블 버퍼링을 사용하는 이유
  - 화면에 표시되는 것을 그리기 위해 내부적으로 처리를 거쳐야함 -> 다 그리지 못한 모습을 사용자에게 보여줄 수 있는 문제 발생
  - 따라서 내부적으로 한 번 처리하고 -> 완성되면 완성된 것을 보여주기 위해 더블 버퍼링 구조를 사용
- 순서
  1. current를 기준으로 모든 작업 시작
  2. 업데이트 발생
  3. currentTree의 복사된 값에서 변경된 부분만 수정
  4. workInProgress 완성
  5. current -> workInProgress로 포인터 변경 후 current 제거

### 파이브 작업 순서

- 그림으로

# 클래스 컴포넌트와 함수 컴포넌트

- 함수형 컴포넌트는 기존에도 존재(0.14버전) -> 상태, 생명주기 메서드가 없이 render할 경우 제한적으로 사용 -> 16.8 버전에서 Hook이 소개된 이후부터 각광받기 시작

### 클래스 컴포넌트

- 최근에는 함수형 컴포넌트를 많이 사용하지만 오래된 코드는 클래스형 컴포넌트로 많이 작성돼있다 -> 클래스형 컴포넌트에 대해 알 필요가 있다.
- 기본적으로 클래스를 선언하고 extends 키워드를 통해 만들고자 하는 컴포넌트를 추가한다. ex) `class SampleComponent extends React.Component`

  - 아래 2개의 차이는 shouldComponentUpdate를 다루는 데 있다. -> 적재적소에 맞게 사용
  - React.Component는 상태가 props가 변경될 때마다 리렌더링 발생
  - React.PureComponent는 얕은 비교만 수행하기 때문에 state가 객체와 같이 복잡한 구조의 데이터 변경은 감지 못함,

- `constructor`
  - 컴포넌트가 초기화 시점에 호출 - state를 초기화
  - ES2022 이후 혹은 바벨을 통해 트랜스파일을 거칠 경우 constructor 없이 state 초기화 가능
- `props`
  - 함수에 인수를 넣는 것과 비슷하게 컴포넌트에 특정 속성을 전달하는 용도로 사용
- `state`
  - 클래스 컴포넌트 내부에서 관리하는 값(상태값)
  - 항상 객체여야만 한다 -> 이 값에 변화가 있을 때마다 리렌더링 발생
- `메서드`
  - 렌더링 함수 내부에서 사용되는 함수
  - 보통 DOM에서 발생하는 이벤트와 함께 사용
    - constructor에서 this를 바인딩 하는 방법
      1. 일반함수 - bind 사용
         - 일반 함수로 호출하면 this가 전역객체(strict 모드에서는 undefined)가 바인딩 -> bind 함수를 통해 this를 바인딩해야 함
         - this.handleClick = this.handleClick.bind(this)
      2. 화살표 함수
         - 작성 시점에 this가 상위 스코프로 결정되기 떄문에 바인딩이 따로 필요 x
      3. 렌더링 함수 내부에서 새롭게 만들어 전달
         - <button onClick={()=>this.handleClick()}>
         - 하지만 이 방법은 매번 렌더링 일어날 때마다 새로운 함수 생성 -> 최적화 어려움 -> 이 방법은 지양

### 클래스 컴포넌트 생명주기

![스크린샷 2024-11-09 오후 7 34 30](https://github.com/user-attachments/assets/9816d469-889e-4bfb-8e3c-25afc337e946)

- 생명주기 메서드가 실행되는 시점은 크게 3가지

  - 마운트 : 컴포넌트가 마운팅(생성)되는 시점
  - 업데이트 : 이미 생성된 컴포넌트의 내용이 변경(업데이트)되는 시점
  - 언마운트 : 컴포넌트가 더 이상 존재하지 않는 시점

- `Render`
  - 클래스 컴포넌트의 유일한 필수 값
  - 컴포넌트가 UI를 렌더링하기 위해 사용
  - 렌더링은 2가지 (마운트, 업데이트) 과정에서 일어난다.
  - `항상 순수해야 하며 부수 효과가 없어야 한다.` -> 같은 입력값이 들어가면 항상 같은 결과물 반환 -> render 내부에서 this.setState와 같이 직접 상태값을 수정해서는 안된다.
- `componentDidMount`
  - 컴포넌트가 마운트되고 준비되는 즉시 실행
  - this.setState를 통해 state를 변경하는 것이 가능
  - 일반적으로 state는 생성자에서 다루고 API 호출 후 업데이트, DOM에 의존적인 작업 등 꼭 필요한 곳에서만 사용
- `componentDidUpdate`
  - 업데이트가 일어난 이후 바로 실행
  - state나 props의 변화에 따라 DOM을 업데이트하는 등에 사용
  - this.setState를 통해 state 변경 가능 -> 적절한 조건문이 아닐 경우 계속 호출될 수 있다. -> 주의
- `componentWillUnmount`
  - 컴포넌트가 언마운트되거나 더 이상 사용되지 않기 직전에 사용
  - 메모리 누수나 불필요한 작동을 막기 위한 클린업 함수를 호출하기 위한 최적의 위치
  - this.setState 호출 불가능
  - 이벤트 제거, API 호출 취소, setInterval, setTimout 타이머 지우는 작업 등
- `shouldComponentUpdate`
  - state나 props의 변경으로 리액트 컴포넌트가 다시 리렌더링되는 것을 막고 싶을 때 사용
  - 특정한 성능 최적화 상황에서만 사용 -> 일반적으론 상태값이 바뀌면 컴포넌트가 리렌더링 되기 때문에
- `static getDerivedStateFromProps`
  - render를 호출하기 직전에 호출
  - static으로 선언돼 있어 this에 접근 불가능
- `getSnapShotBeforeUpdate`

  - DOM이 업데이트되기 직전에 호출
  - 반환되는 값은 componentDidUpdate로 전달
  - DOM에 렌더링되기 전에 윈도우 크기를 조절하거나 스크롤 위치 조정하는 등 작업에 유용

- 에러 상황에서 사용되는 메서드
  - 아래의 2개 메서드와 getSnapshotBeforeUpdate 메서드는 훅으로 구현돼 있지 않기 때문에 필요하다면 클래스형으로 사용해야함
  - 아래의 2메서드는 ErrorBoundary 컴포넌트를 만들기 위한 목적으로 많이 사용 -> 전역에서 처리되지 않은 에러를 처리하기 위한 용도 -> ErrorBoundary 외부 에러는 잡을 수 없다.
  - `getDerivedStateFromError`
    - 자식(하위) 컴포넌트에서 에러가 발생했을 때 호출되는 에러 메서드
    - static 메서드로 error를 인수로 받는다. 이때 error는 하위 컴포넌트에서 발생한 에러
    - 부수효과를 발생시켜선 안된다.
  - `componentDidCatch`
    - 자식 컴포넌트에서 에러가 발생했을 때 실행
    - getDerivedStateFromError에서 에러를 잡고 state를 결정한 이후에 실행
    - 자식컴포넌트에서 발생한 에러와 정확히 어떤 컴포넌트에서 에러를 발생시켰는지에 대한 정보인 info 2개의 인수를 받음
    - 부수 효과를 수행할 수 있다.

### 클래스 컴포넌트의 한계

1. 데이터 흐름을 추적하기 어렵다
   - 여러 메서드에서 state 업데이트 발생,
   - 메서드 순서가 강제돼 있지 않아 읽기 어려움
2. 애플리케이션 내부 로직의 재사용이 어렵다
   - 코드 재사용을 위해 HOC를 사용 할 수 있는데 래퍼 지옥에 빠질 수 있음 -> 클래스 컴포넌트에선 매끄럽게 처리하기 곤란
3. 기능이 많아질수록 컴포넌트가 커진다
   - 생명주기 메서드 사용이 잦아지면 크기가 기하급수적으로 커질 수 있다.
4. 함수형 컴포넌트에 비해 어렵다
   - 함수에 비해 클래스는 비교적 어렵고 일반적이지 않다.
   - this, 클래스 컴포넌트를 처음 접하는 사람, 자바스크립트를 조금 해본 사람 모두 혼란에 빠질 수 있다.
5. 코드 크기를 최적화 하기 어렵다
   - 번들 크기를 줄이는 데도 어려움을 겪는다.

### 함수 컴포넌트

- 무상태 컴포넌트를 구현하기 위한 하나의 수단 -> Hook의 등장으로 많은 각광을 받는 중
- 클래스 컴포넌트에 비해 여러모로 간결해짐
- this 바인딩을 조심 할 필요 없고, state는 객체가 아닌 원시값으로 관리되어 사용하기가 편해짐 - 물론 객체로도 관리 가능

### 함수 컴포넌트 vs 클래스 컴포넌트

1. 생명주기 메서드의 부재
   - 클래스 컴포넌트의 생명주기 메서드가 함수형 컴포넌트에 존재하지 않음 -> 생명주기 메서드는 React.Component에서 오는것인데 함수형은 상속받지 않아 존재하지 않음
   - 함수 컴포넌트에선 useEffect hook을 통해 componentDidMount, componentDidUpdate, componentWillUnmount를 `비슷하게` 구현할 수 있다.
2. 함수 컴포넌트와 렌더링된 값
   - 함수 컴포넌트는 렌더링된 값을 고정하고, 클래스 컴포넌트는 그렇지 못하다.

### 클래스 컴포넌트 공부해야 할까?

- 클래스는 사라질 계획도 없고, 아직 클래스 컴포넌트를 사용하는 곳이 많으므로 공부를 하는게 좋긴하다.
- 특히 에러 처리 코드는 함수형 컴포넌트에 없기 때문에 클래스 컴포넌트에 대한 지식은 어느 정도 필요하다

# 렌더링은 어떻게 일어나는가?

### 리액트의 렌더링이란?

- 모든 컴포넌트들이 `현재 자신들이 가지고 있는 props, state의 값을 기반으로 어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 과정`

### 리액트의 렌더링이 일어나는 이유

- 렌더링 과정을 이해하는 것도 중요하지만 렌더링이 언제 발생하느냐가 더 중요하다.
- 렌더링 발생 시기
  - 최초 렌더링 : 리액트가 브라우저에 정보를 제공하기 위해 최초 렌더링 수행
  - 리렌더링 : 최초 렌더링 발생 이후 발생하는 모든 렌더링
    - 리렌더링이 발생하는 경우
      1. state가 변경될 경우
      2. 클래스 컴포넌트의 forceUpdate가 실행되는 경우 - render()내부에서 사용할 경우 무한루프 빠짐
      3. 함수 컴포넌트의 useReducer에서 dispatch가 실행되는 경우
      4. 컴포넌트의 key props가 변경되는 경우
      5. props가 변경되는 경우
      6. 부모 컴포넌트가 변경되는 경우

### 리액트 렌더링 프로세스

- Render Phase - 가상 DOM을 만드는 단계
  - 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업
  - 컴포넌트를 실행해 이 결과와 이전 가상 DOM을 비교하는 과정을 거쳐 필요한 컴포넌트를 체크하는 단계
  - type, props, key를 통해 비교
- Commit Phase - 실제 DOM에 반영하는 단계
  - 렌더 단계의 변경사항을 실제 DOM에 적용하여 사용자에게 보여주는 과정
  - 이 단계가 끝나면 브라우저의 렌더링이 발생
- 리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는 것은 아님 -> 가시적인 변화가 없더라도 리액트 렌더링은 일어날 수 있다.

### 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션

- useMemo, useCallback 훅과 고차 컴포넌트인 memo는 리액트에서 발생하는 렌더링을 최소한으로 줄이기 위해서 제공된다.
- 정확이 언제 사용하는가? -> 오랜 논쟁 주제

- 주장1 : 섣부른 최적화는 독이다, 꼭 필요한 곳에만 메모이제션을 추가하자.
  - 메모이제이션도 비용이기 때문에 항상 신중해야한다.
- 주장2 : 렌더링 과정의 비용은 비싸다, 모조리 메모이제이션해 버리자
  - 실무 개발자는 생각보다 최적화나 성능 향상에 쏟을 시간이 많지 않다 -> 일단 memo로 감싸고 생각해보자
  - 메모이제이션 하지 않은 것 보다 메모이제이션 했을때 더 많ㅇ느 이점을 누릴 수 있다
