# 2024.12.11 DIL

p670 ~

### import React from 'react'가 더 이상 필요없다 : 새운 JSX transform

- JSX는 브라우저가 이해할 수 있는 코드가 아니므로 바벨이나 타입스크립트를 통해 변환 과정이 필요하다.
- 16버전까지는 이런 JSX 변환을 위해 코드 내에서 React를 사용하는 구문이 없더라도 import React from 'react'가 필요했고, 없다면 에러가 발생했다.
- 17버전 부터는
  1. import React가 필요없다는 장점 외에도,
  2. 불필요한 import 구문을 삭제해 번들링 크기를 약간 줄일 수 있고,
  3. 컴포넌트 작성을 간결하게 해준다.

### 그밖의 주요 변경 사항

- 이벤트 풀링 제거

  - 리액트 16에는 이벤트 풀링 기능이 있었다.
  - 리액트는 이벤트 처리를 위해 SyntheticEvent가 존재 -> 브라우저의 이벤트를 한번 더 감싼 이벤트 객체
  - 래핑한 이벤트를 사용하기에 이벤트가 발생할 경우 매번 새로운 이벤트를 만듦 -> 메모리 할당 작업 발생 -> 메모리 누수 방지를 위해 이벤트를 주기적으로 해제해야함
  - 이벤트 풀링이란 SyntheticEvent 풀을 만들어서 이벤트가 발생할 때마다 가져오는 것

- 이벤트 풀링 시스템

  1. 이벤트 핸들러가 이벤트를 발생시킨다.
  2. 합성 이벤트 풀에서 합성 이벤트 객체에 대한 참조를 가져온다
  3. 이벤트 정보를 합성 이벤트 객체에 넣어준다.
  4. 유저가 지정한 이벤트 리스너가 실행된다.
  5. 이벤트 객체가 초기화되고 다시 이벤트 풀로 돌아간다.

- 16이하의 버전에서는 이벤트 풀링 방식을 통해 이벤트를 재사용한다 -> 재사용 사이에 모든 이벤트 필드를 null로 초기화 -> 비동기의 경우 event에 접근하면 null로 받기 때문에 e.persist()와 같은 처리가 필요했다
- 비동기 코드로 이벤트에 핸들러에 접근하기 위해 별도 메모리 공간에 합성 이벤트 객체를 할당해야한다는 점, 이 같은 방식이 성능 향상에 도움이 안된다는 점 때문에 이벤트 풀링 제거

### useEffect 클린업 함수의 비동기 실행

- 16버전에서는 동기적으로 처리 -> 클린업 함수가 완료되기 전까지 다른 작업을 방해하므로 불필요한 성능 저하 발생
- 17 이후부터는 화면이 완전히 업데이트된 이후에 클린업 함수가 비동기적으로 실행
- 즉 16버전은 리렌더링 이전에 발생
- 17버전은 리렌더링 이후에 발생 -> 더 빨라짐

### 컴포넌트의 undefined 반환에 대한 일괄적인 처리

- 16, 17버전은 컴포넌트 내부에서 undefined를 반환하면 오류가 발생한다.
- 16 버전에서는 forwardRef, memo에서 undefined를 반환하면 에러가 발생하지 않았다
- 17버전부터는 에러가 정상적으로 발생
- 18버전은 undefined를 반환해도 에러가 발생하지 않음

### 정리

- 17버전은 사용자에게 영향을 미칠 수 있는 큰 변화를 최소화하고
- 다음 버전 업을 위한 버전업 정도로 마무리

# 리액트 18버전 살펴보기

- 새로 추가된 훅 살펴보기
- 18버전에서는 16.8에서 처음 선보였던 이래로 새로운 훅이 대거 추가됐다.
- 앞으로도 함수 컴포넌트 사용이 주를 이룰 것이라는 리액트 팀의 방향성으로도 볼 수 있다.

### useId

- 컴포넌트별로 유니크한 값을 생성하는 새로운 훅
  - 유니크한 값을 생성하는 것은 쉽지 않다.
    - 하나의 컴포넌트가 여러 군데에서 재사용 되는 경우 고려
    - 서버 사이드 렌더링 환경에서 하이드레이션이 일어날 때 서버와 컴포넌트에서 동일한 값을 가져야 함
  - useId를 사용하면 클라이언트와 서버에서 불일치를 피하면서, 컴포넌트 내부의 고유한 값을 생성할 수 있다.
  - `:`로 감싸져 있는데 이는 CSS 선택자나, querySelector에서 작동하지 않도록 하기 위한 의도적인 결과

### useTransition

- UI 변경을 가로막지 않고 상태를 업데이트할 수 있는 리액트 훅
- 상태 업데이트를 긴급하지 않은 것으로 간주해 무거운 렌더링 작업을 조금 미룰 수 있고, 사용자에게 더 나은 사용자 경험을 제공할 수 있다.
- 18의 변경 사항의 핵심 중 하나인 동시성을 다룰 수 있는 새로운 훅이다.
- 앱의 성능을 향상시킬 뿐만 아니라 사용자에게 좀 더 자연스러운 서비스를 경험할 수 있게 해준다.
- 주의사항
  1. startTransition 내부는 반드시 setState와 같은 상태를 업데이트하는 함수와 관련된 작업만 넘길 수 있다. 만약 props나 커스텀 훅에서 반환하는 값 등을 사용하고 싶다면 뒤이어 나올 useDefferedValue를 사용하면 된다.
  2. startTransition으로 넘겨주는 상태 업데이트는 다른 모든 동기 상태 업데이트로 인해 실행이 지연될 수 있다. 예를 들어, 타이핑으로 인해 setState가 일어나는 경우 타이핑이 끝날 때까지 useTransition으로 지연시킨 상태 업데이트는 일어나지 않는다.
  3. startTransition으로 넘겨주는 함수는 반드시 동기함수여야 한다. 만약 이 안에 setTimeout과 같은 비동기 함수를 넣으면 제대로 작동하지 않게 된다. 이는 startTransition 작업을 지연시키는 작업과 비동기 함수가 실행되는 작업 사이에 불일치가 일어나기 때문이다.

### useDefferedValue

- 리렌더링이 급하지 않은 부분을 지연할 수 있게 도와주는 훅
- 특정 시간 동안 발생하는 이벤트를 하나로 인식해 한 번만 실행해주는 디바운스와 비슷하다
- 차이점
  - 디바운스는 고정된 지연 시간을 필요로 하지만 useDefferedValue는 고정된 지연 시간 없이 첫 번째 렌더링이 완료된 이후에 useDefferedValue로 지연된 렌더링을 수행한다.
  - 그러므로 지연된 렌더링은 중단할 수도 있으며, 사용자의 인터랙션을 차단하지도 않는다.
- useTransition과 차이점
  - useTransition은 state값을 업데이트하는 함수를 감싸서 사용
  - useDefferedValue는 state 값 자체만을 감싸서 사용

### useSyncExternalStore

- 일반적인 애플리케이션 코드를 작성할 때는 사용할 일이 별로 없는 훅
- 테어링 현상
  - 리액트에서는 하나의 state 값이 있음에도 서로 다른 값을 기준으로 렌더링 되는 현상
- 리액트에서 관리할 수 없는 외부 데이터 소스(클로저 범위 밖, 글로벌 변수, DOM 등)에 동시성 처리가 추가돼 있지 않다면 테어링 현상이 발생하고, useSyncExternalStore는 테어링 현상을 해결하기 위한 훅이다.

### useInsertionEffect

- CSS-in-js라이브러리 훅
- DOM이 실제로 변경되지 전에 동기적으로 실행
- `라이브러리를 작성하는 경우가 아니라면 참고만 하고, 가급적 사용하지 않는 것이 좋다.`

- useInsertionEffect - DOM 렌더링 이전, DOM 변경 작업 전 실행
- useLayoutEffect - DOM 렌더링 이전, DOM의 변경 작업이 다 끝난 후 실행
- useEffect - 렌더링 이후
