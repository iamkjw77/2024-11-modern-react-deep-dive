# 2024.11.12 DIL

p196 ~ p216

# useEffect

### useEffect란

- 애플리케이션 내 컴포넌트의 여러 값들을 활용해 동기적으로 부수 효과를 만드는 메커니즘

```javascript
function Component() {
  ///

  useEffect(() => {}, []);
}
```

- 첫 번째 인수 : 실행할 부수 효과가 포함된 함수
- 두 번째 인수 : 의존성 배열
- useEffect는 렌더링할 때마다 의존성에 있는 값을 보면서 의존성의 값이 이전과 다른 게 하나라도 있다면 부수 효과를 실행하는 평범한 함수
- 따라서 state와 props의 변화 속에서 일어나는 렌더링 과정에서 실행되는 부수 효과 함수

### 클린업 함수의 목적

- 이벤트를 등록하고 지울 때 사용
- 클린업 함수는 새로운 값을 기반으로 렌더링 뒤에 실행되지만, 함수가 정의됐을 당시에 선언됐던 이전 값을 보고 실행
- 특정 이벤트의 핸들러가 무한히 추가되는 것을 방지
- 언마운트라기 보다는 리렌더링됐을 때 이전 상태를 청소해 주는 개념

### 의존성 배열

1. 빈배열 : 최초 렌더링 직후 실행된 다음부터는 더 이상 실행되지 않는다.
2. 아무런 값을 넘기지 않음 : 렌더링이 발생할 때마다 실행
   - 의존성 배열이 없는 useEffect vs useEffect 사용 하지 않는 경우
     - 서버 사이드 렌더링 관점에서는 클라이언트 사이트에서 실행되는 것을 보장 - 내부에서 window 객체에 접근 가능
     - useEffect는 렌더링 완료된 이후에 실행되는 반면 useEffect를 사용하지 않는 경우는 컴포넌트가 렌더링되는 도중에 실행 + 서버 사이드의 경우 서버에서도 실행 - 성능에 악영향을 미침
3. 원하는 값을 넣음 : 의존성이 변경될 때 리렌더링

### useEffect를 사용할 때 주의할 점

- 리액트를 작성할 때 가장 많이 사용하는 훅이면서 가장 주의해야 할 훅이다.
- 잘못 사용하면 예기치 못한 버그 or 무한 루프에 빠질 수 있다.

1. eslint-disable-line react-hook/exhaustive-deps 주석은 최대한 자제하라

   - 의존성이 포함돼 있지 않으니 넣으세요!
   - 정말 의존성으로 빈배열[]이 필요하다면 최초 마운트 시점에만 필요한지 되물어봐야한다 -> 정말 그렇다면 useEffect 내 부수 효과가 실행될 위치가 잘못됐을 가능성이 크다

   ```javascript
   // log를 props로 받은 최초의 시점에만 실행된다. -> 첫 렌더링에만 로그를 나타내기 위한 의도로 작성
   // 버그의 위험성을 안고 있다 -> 부모 컴포넌트에서 실행하는게 옳을지도 모름 ->

   function Component({ log }: { log: string }) {
     useEffect(() => {
       logging(log);
     }, []);
   }
   ```

2. useEffect의 첫 번째 인수에 함수명을 부여하라

   - 많은 코드에서 첫 번째 인수로 익명 함수를 넘겨준다.
   - useEffect의 수가 적거나, 복잡성이 낮으면 큰 문제 x -> useEffect의 코드가 복잡하고 많아질수록 파악하기 어려워짐

   ```javascript
   // 익명함수
   useEffect(() => {
     logging(user.id);
   }, []);

   useEffect(
     function logActiveUser() {
       logging(user.id);
     },
     [user.id]
   );
   ```

3. 거대한 useEffect를 만들지 마라
   - 부수효과의 크기가 커질수록 애플리케이션 성능에 악영향을 미친다.
   - 부득이하게 큰 useEffect를 만들어야 한다면 적은 의존성 배열을 사용하는 여러 개의 useEffect로 분리
   - 불가피하게 여러 변수가 들어가야 하는 상황이라면 최대한 useCallback, useMemo로 사전에 정제한 내용들만 useEffect에 담아두는 것이 좋다.
4. 불필요한 외부 함수를 만들지 마라
   - useEffect내부에 실행되는 함수가 외부에 선언될 경우 가독성이 안좋고, 불필요한 코드가 많아질 수 있다.
   - 내부로 가져오면 더욱 간결하고, 불필요한 의존성 배열도 줄일 수 있다.

### 왜 useEffect의 콜백 인수로 비동기 함수를 바로 넣을 수 없을까?

1. useEffect 내부에서 state를 결과에 따라 업데이트 로직이 있다고 가정
2. 응답 속도에 따라 이상하게 나올 수 있음 -> 이전 state가 10초, 바뀐 state가 1초일 경우
3. 이전 state 기반으로 결과가 나와버리는 불상사 발생 -> useEffect의 경쟁상태(race condition)라고 함

- 비동기 함수는 어떻게 실행할까?
- useEffect의 인수로 비동기 함수를 지정할 수 없을 뿐 -> 비동기 함수 실행 자체가 문제 되는 것은 아님 -> useEffect 내부에서 비동기 함수 선언 후 실행 or 즉시 비동기 함수 만들어서 실행

  ```javascript
  useEffect(() => {
    let shouldIgnore = false;

    async function fetchData() {
      const response = await fetch('url');
      const result = await response.json();
      if (!shouldIgnore) {
        setData(result);
      }
    }

    fetchData();

    return () => {
      // 이전 비동기 함수에 대한 처리
      // 비동기 useEffect는 state의 경쟁 상태를 야기할 수 있고 cleanup 함수의 실행 순서도 보장할 수 없기 때문에 개발자의 편의를 위해 useEffect에서 비동기 함수를 인수로 받지 않는것임
    };
  }, []);
  ```

# useMemo

- 비용이 큰 연산에 대한 결과를 저장(메모이제이션)해 두고, 이 저장된 값을 반환하는 훅이다.
- 첫 번째 인수 : 어떤 값을 반환하는 생성 함수
- 두 번째 인수 : 의존성 배열
- 렌더링 발생 시 의존성 배열의 값이 변경되지 않았으면 함수를 재실행하지 않고 이전에 기억해둔 값을 반환하고, 변경됐다면 첫 번째 인수의 함수를 실행한 후 그 값을 반환하고 그 값을 다시 기억
- 비용이 많이 드는 연산이란? : 논란

# useCallback

- 인수로 넘겨받은 콜백 자체를 기억 -> 함수를 재사용한다는 의미
- 함수의 재생성을 막아 불필요한 리소스 또는 리렌더링을 방지하고 싶을 때 사용
- useCallback과 useMemo의 차이는 대상이 변수냐 함수냐의 차이일 뿐
- useMeemo로 useCallback을 구현할 순 있지만 코드가 너무 길어지기 때문에 useCallback을 제공하는 것으로 추측
