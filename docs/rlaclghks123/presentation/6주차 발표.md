# NextJs 13과 리액트 18

- NextJs 13은 `Next.js의 릴리스 역사를 통틀어 가장 큰 변화가 있는 릴리스`라고 해도 과언이 아니다
  1. 서버 사이드 렌더링의 구조에 많은 변화가 있었던 리액트 18을 채택
  2. 기존 NextJs의 큰 약점인 레이아웃을 본격적으로 지원
  3. 바벨을 대체할 러스트 기반 SWC를 뒤이어 웹팩을 대체할 Turbopac 출시

### App 디렉터리의 등장

- 13버전 이전까지 모든 페이지는 각각 물리적으로 구별된 파일로 독립돼 있었다.
- 공통으로 무언가를 집어 넣을 수 있는 곳은 \_document, \_app이 유일 -> 그나마도 이 파일들은 `서로 다른 목적을 지니고 있다.`
  - \_document : `페이지에서 쓰이는 html, body 태그를 직접 수정`하거나, `CSS-In-JS를 지원하기 위한 코드를 삽입`하는 제한적인 용도로 사용
  - \_app : `페이지를 초기화하기 위한 용도로 사용` (공통 레이아웃을 유지할 수 있는 유일한 방법)
    - 페이지 변경 시에 유지하고 싶은 레이아웃
    - 페이지 변경 시 상태유지
    - componentDidCatch를 활용한 에러 핸들링
    - 페이지간 추가적인 데이터 삽입
    - global CSS 주입

### App 디렉터리 방식

### 1. 라우팅

- 기존에 /pages로 정의하던 라우팅 방식 -> /app 디렉터리로 이동
- 파일명으로 라우팅하는 것이 불가능해짐
- 기본적으로 파일 시스템을 기반으로 하고 있지만 이전과 약간의 차이가 존재한다.
  - Next.js 12 이하: /pages/a/b.tsx 또는 /pages/a/b/index.tsx는 모두 동일한 주소로 변환된다. 즉, 파일명이 index라면 이 내용은 무시된다.
  - Next.js 13 app: /app/a/b는 /a/b로 변환되며, `파일명은 무시된다. 폴더명까지만 주소로 변환된다.`
- 즉 13버전의 app 디렉터리 내부의 파일명은 라우팅 명칭에 아무런 영향을 미치지 못한다. -> app 내부에서 가질 수 있는 파일명은 몇몇 예약어로 제한

### 2.layout.js

- 13버전 이후에는 app 디렉터리 내부의 폴더명이 라우팅 되며, 폴더에 포함될 수 있는 파일명은 몇 가지로 제한 -> 그중 하나가 layout.js
- `페이지의 기본적인 레이아웃을 구성하는 요소`
- `오로지 자신과 자식 라우팅에만 영향을 미친다.`
- 꼭 레이아웃이 필요하지 않더라도 웹페이지에 필요한 기본 정보만 담아둬도 충분히 유용함

- 주의해야 할 점
  1. layout은 app 디렉터리 내부에서는 예약어이다. 무조건 layout.{js|jsx|ts|tsx}로 사용해야 하며, `레이아웃 이외의 다른 목적으로는 사용할 수 없다.`
  2. `layout은 children을 props로 받아서 렌더링해야 한다.` 레이아웃이므로 당연히 그려야 할 컴포넌트를 외부에서 주입받고 그려야 한다.
  3. `layout 내부에는 반드시 export default로 내보내는 컴포넌트가 있어야 한다.`
  4. `layout 내부에서도 API 요청과 같은 비동기 작업을 수행할 수 있다.`

### 3.page.js

- `layout과 마찬가지로 예약어`
- NextJs에서 일반적으로 다뤘던 페이지를 의미

- page가 받는 props 종류
  1. params: 옵셔널 값으로, 앞서 설명한 [...id]와 같은 `동적 라우트 파라미터를 사용할 경우 해당 파라미터에 값이 들어온다.`
  2. searchParams: URL에서 ?a=1과 같은 URLSearchParams를 의미한다.
  - 한 가지 주목해야 할 것은 이 값은 layout에서 제공되지 않는다는 것이다.
  - 그 이유는 layout은 페이지 탐색 중에는 리렌더링을 수행하지 않기 때문이다. 즉, 같은 페이지에서 search parameter만 다르게 라우팅을 시도하는 경우 layout을 리렌더링하는 것은 불필요하기 때문이다.
  - 만약 `search parameter에 의존적인 작업을 해야 한다면 반드시 page 내부에서 수행해야 한다.`

### error.js

- `라우팅 영역에 사용되는 공통 에러 컴포넌트`
- error.js를 사용하면 특정 라우팅별로 서로 다른 에러 UI를 렌더링하는 것이 가능해짐

- props로 받는 것
  1. error : 에러 정보를 담고 있는 객체
  2. reset : 에러 바운더리를 초기화할 함수
- 같은 수준의 layout에서 에러가 발생할 경우 해당 error 컴포넌트로 이동하지 않음 -> 같은 구조로 페이지가 렌더링 되기 때문 -> layout에서 발생한 에러를 처리하려면 상위 컴포넌트의 error를 사용하거나, global error 사용

### not-found.js

- 특정 라우팅 하위의 주소를 찾을 수 없는 404 페이지를 렌더링할 때 사용

### loading.js

- Suspense를 기반으로 해당 컴포넌트가 불러오는 중임을 나타낼 때 사용
- "use client" 지시자를 사용해 클라이언트에서 렌더링되게 할 수 있다.

### route.js

- 해당 파일 내부에서 `REST API의 get, post와 같은 메서드명을 예약어로 선언`해 두면 HTTP 요청에 맞게 해당 메서드를 호출하는 방식으로 작동
- routes.ts가 존재하는 폴더 내부에는 page.tsx가 존재할 수 없다. 만약 공존한다면 경고 메세지 발생

- 받을 수 있는 파라미터
  1. request: NextRequest 객체이며, fetch의 Request를 확장한 Next.js만의 Request라고 보면된다. 이 객체에는 API 요청과 관련된 cookie, headers 등뿐만 아니라 nextUrl 같은 주소 객체도 확인할 수 있다.
  2. context: params만을 가지고 있는 객체이며, 이 객체는 앞서 파일 기반 라우팅에서 언급한 것돠 동일한 동적 라우팅 파라미터 객체가 포함되어 있다. 이 객체는 Next.js에서 별도 인터페이스를 제공하지 않으므로 주소의 필요에 따라 원하는 형식으로 선언하면 된다.

# 리액트 서버 컴포넌트

### 기존 리액트 컴포넌트와 서버 사이드 렌더링의 한계

- `리액트의 모든 컴포넌트는 클라이언트에서 작동하며, 브라우저에서 자바스크립트 코드 처리가 이뤄진다.`
- 웹사이트 방문 -> 리액트에 실행한 필요한 코드 다운로드 -> 리액트 컴포넌트 트리 만든 뒤 -> DOM에 렌더링
- 서버 사이드 렌더링 : 미리 서버에서 DOM을 만든다 -> 클라이언트에서 만들어진 DOM을 기준으로 하이드레이션 수행 -> 브라우저에서 상태 추적 -> 이벤트 핸들러 DOM에 추가 -> 응답에 따라 트리 변경

- 서버 사이드 렌더링의 한계

  1. 자바스크립트 번들 크기가 0인 컴포넌트를 만들 수 없다
  2. 백엔드 리소스에 대한 직접적인 접근이 불가능하다.
  3. 자동 코드 분할이 불가능하다.
  4. 연쇄적으로 발생하는 클라이언트와 서버의 요청을 대응하기 어렵다.

- 서버사이드 렌더링

  - 장점 - 정적 컨텐츠를 빠르게 제공, 서버에 있는 데이터에 손쉽게 제공
  - 단점 - 사용자 인터랙션에 따른 다양한 사용자 경험을 제공하긴 어려움

- 클라이언트 사이드 렌더링

  - 장점 - 사용자의 인터랙션에 따라 다양한 것들을 제공
  - 단점 - 서버에 비해 느리고, 데이터를 가져오는 것도 어렵다

- 위 두 구조의 장점을 모두 취하고자 하는 것이 바로 리액트 서버 컴포넌트이다.

### 서버 컴포넌트란

- 하나의 언어, 하나의 프레임워크, 하나의 API와 개념을 사용하면서 `서버와 클라이언트 모두에서 컴포넌트를 렌더링할 수 있는 기법`
- `서버에서 할 수 있는 일은 서버가 처리하게 두고, 서버가 할 수 없는 일은 클라이언트인 브라우저에서 수행`
- 단 클라이언트 컴포넌트는 서버 컴포넌트를 import 할 수 없다.
- 모든 컴포넌트는 서버 컴포넌트가 될 수 있고, 클라이언트 컴포넌트가 될 수 있다.

- 3가지 컴포넌트의 차이

  - 서버 컴포넌트

    - `요청이 오면 그 순간 서버에서 딱 한 번 실행될 뿐이므로 상태를 가질 수 없다`. -> 리액트에서 상태를 가질 수 있는 useState, useReducer 등의 훅을 사용할 수 없다.
    - `렌더링 생명주기도 사용할 수 없다.` -> 한 번 렌더링되면 그걸로 끝이기 때문이다. 따라서 useEffect, useLayoytEffect를 사용할 수 없다.
    - 앞의 두 가지 제약사항으로 인해 `effect나 state에 의존하는 커스텀 훅을 또한 사용할 수 없다.` 다만 effect나 state에 의존하지 않고 서버에서 제공할 수 있는 기능만 사용하는 훅이라면 사용가능하다.
    - 브라우저에서 실행되지 않고 서버에서만 실행되기 때문에 `DOM API를 쓰거나 window, document 등에 접근할 수 없다.`
    - 데이터베이스, 내부 서비스, 파일 시스템 등 `서버에서만 있는 데이터를 async/await으로 접근할 수 있다.` 컴포넌트 자체가 async한 것이 가능하다.
    - 다른 서버 컴포넌트를 렌더링하거나 div, span, p 같은 요소를 렌더링하거나 혹은 클라이언트 컴포넌트를 렌더링할 수 있다.

  - 클라이언트 컴포넌트

    - 브라우저 환경에서만 실행되므로 `서버 컴포넌트를 불러오거나, 서버 전용 훅이나 유틸리티를 불러올 수 없다.`
    - 그러나 서버 컴포넌트가 클라이언트 컴포넌트를 렌더링하는데, 그 `클라이언트 컴포넌트가 자식으로 서버 컴포넌트를 갖는 구조는 가능하다`. 그 이유는 클라이언트 입장에서 봤을 때 서버 컴포넌트는 이미 서버에서 만들어진 트리를 가지고 있을 것이고, 클라이언트 컴포넌트는 이미 서버에서 만들어진 그 트리를 삽입해서 보여주기만 하면 되기 때문이다. 따라서 서버 컴포넌트와 클라이언트 컴포넌트를 중첩해서 갖는 구조로 설계하는 것이 가능하다.
    - 이 두 가지 예외 사항을 제외하면 일반적으로 우리가 알고 있는 리액트 컴포넌트와 같다. state, effect를 사용할 수 있으며, 브라우저 API도 사용할 수 있다.

  - 공용 컴포넌트
    - 이 컴포넌트는 서버와 클라이언트 모두에서 사용할 수 있다. 공통으로 사용할 수 있는만큼, 당연히 서버 컴포넌트와 클라이언트 컴포넌트의 모든 제약을 받는 컴포넌트가 된다.

- 리액트는 어떻게 서버 컴포넌트인지, 클라이언트 컴포넌트인지, 공용 컴포넌트인지 판단할까?
  - 리액트는 모든 것을 다 공용 컴포넌트로 판단한다.
  - 대신 클라이언트 컴포넌트라는 것을 명시적으로 선언하려면 파일 맨 첫 줄에 `use client`라고 작성해 두면 된다.

### 서버 사이드 렌더링과 서버 컴포넌트의 차이

- 서버 사이드 렌더링은 응답받은 페이지 전체를 HTML로 렌더링하는 과정을 서버에서 수항한 후 결과를 클라이언트에 내려준다.
- 이후 클라이언트에서 하이드레이션 과정을 거쳐 서버의 결과물을 확인하고 이벤트를 붙이는 작업을 수행한다.
- `서버사이드 렌더링의 목적은 초기에 인터랙션은 불가능하지만, 정적인 HTML을 빠르게 내려주는 데 초점을 두고 있다.` -> 여전히 초기 HTML이 로딩된 이후에는 클라이언트에서 자바스크립트 코드를 다운로드하고 파싱하고 실행하는 데 비용이 든다.
- `서버사이드 렌더링과 서버 컴포넌트는 대체제가 아닌 상호보완하는 개념으로 봐야 할 것이다.`

### 서버 컴포넌트는 어떻게 동작하는가

1. `서버가 렌더링 요청을 받는다.` -> 서버가 렌더링 과정을 수행해야 하므로 리액트 서버 컴포넌트를 사용하는 모든 페이지는 항상 서버에서 시작. 즉 루트에 있는 컴포넌트는 항상 서버 컴포넌트
2. `서버는 받은 요청에 따라 컴포넌트를 JSON으로 직렬화(serialize)한다.` 이때 서버에서 렌더링할 수 있는 것은 직렬화해서 내보내고, 클라이언트 컴포넌트로 표시된 부분은 해당 공간을 플레이스홀더 형식으로 비워두고 나타낸다. 브라우저는 이후에 이 결과물을 받아서 다시 역직렬화한 다음 렌더링을 수행한다. 이게 무슨 말인지 잘 와닿지 않는다면 서버가 렌더링 요청을 보냈을 때 클라이언트에 보내는 값을 실제로 살펴보면 된다.

```
  M1:{"id": "./src/SearchField.client.js","chunks":["client5"],"name": ""}
  M2:{"id": "./src/EditButton.client.js","chunks":["client1"],"name": ""}
  S3:"react.suspense"
  J0:["$","div",null,{"className":"main","children":[["$","section",null,{"className":"colsidebar",...}]]}]
```

- 위와 같은 데이터 형태를 와이어 포맷(wire format)이라고 하며, 서버는 이 값을 스트리밍해 클라이언트에 제공한다. 한눈에 봤을 때 이해하기 쉬운 구조로 되어있는데, 하나씩 그 형태를 살펴보자.
  - M: M으로 시작하는 줄은 클라이언트 컴포넌트를 의미하며, 클라이언트 번들에서 해당 함수를 렌더링하기 위해 필요한 정보가 어디(chunk)에 담겨있는지 참조를 전달해준다. 위 코드에서는 SearchField.client.js와 EditButton.client.js가 클라이언트 모듈의 참조로 전해졌다.
  - S: Suspense를 의미한다.
  - J: 서버에서 렌더링된 서버 컴포넌트이다. J0은 App.server.js(최상단 루트 컴포넌트)를 표현한 것임을 알 수 있다. 그리고 여기에는 렌더링에 필요한 모든 element, className, props, children 정보 등이 들어가 있다. 여기서 한 가지 흥미로운 점은 @1, @2와 같은 요소이다.

3. 브라우저가 리액트 컴포넌트 트리를 구성한다.
   - 브라우저가 서버로 스트리밍으로 JSON 결과물을 받았다면 이 구문을 다시 파싱한 결과물을 바탕으로 트리를 재구성해 컴포넌트를 만들어 나간다.

- 리액트 서버 컴포넌트의 작동 방식의 특별한 점
  - 스트리밍 전송: 서버에서 JSON 데이터를 스트리밍 형태로 보내, 클라이언트가 빠르게 컴포넌트를 렌더링할 수 있습니다.
  - 개별 번들링: 컴포넌트별로 번들링되어 필요한 컴포넌트만 지연 로드하거나 별도로 가져올 수 있습니다.
  - JSON 기반 렌더링: 결과물을 HTML이 아닌 JSON으로 전달해, 서버 컴포넌트와 클라이언트 컴포넌트를 조화롭게 구성하며 렌더링 속도를 높입니다.

### Next.js에서의 리액트 서버 컴포넌트

- 기본적인 서버 컴포넌트의 제약은 동일하다
  1. 서버 컴포넌트는 클라이언트 컴포넌트를 불러올 수 없다.
  2. 클라이언트 컴포넌트는 서버 컴포넌트를 children props로 받는 것만 가능하다.
- 루트 컴포넌트, Layout, page.js 등 모두 서버 컴포넌트여야하며, 서버 컴포넌트의 제약을 받는다.

```javascript
import ClientComponent from './ClientComponent';
import ServerComponent from './ServerComponent';

export default function ParentServerComponent() {
  return (
    <ClientComponent>
      <ServerComponent />
    </ClientComponent>
  );
}
```

- 대부분 리액트 서버 컴포넌트에서 제공하는 내용과 별다른 차이가 없는데, NextJs에서 서버 컴포넌트를 도입하면서 달라진 부분이 몇 가지 있다.

### 새로운 fetch 도입과 getServerSideProps, getStaticProps, getInitialProps의 삭제

- 과거 Next.js의 서버 사이드 렌더링과 정적 페이지 제공을 위해 이용되던 getServerSideProps, getStaticProps, getInitialProps가 /app 디렉터리 내부에서는 삭제됐다.
- 그 대신 모든 데이터 요청은 웹에서 제공하는 표준 API인 fetch를 기반으로 이뤄진다.

- getServerSideProps는 서버 사이드 렌더링만을 위한 것이었으므로, 이제 서버에서 데이터를 직접 불러올 수 있게 됐다.
- 컴포넌트가 비동기적으로 작동하는 것도 가능해진다.
- 추가로 리액트팀은 `fetch API를 확장해 같은 서버 컴포넌트 트리 내에서 동일한 요청이 있다면 재요청이 발생하지 않도록 요청 중복을 방지했다.`
- fetch 요청에 대한 내용을 서버에서는 렌더링이 한 번 끝날 때까지 캐싱하며, 클라이언트에서는 별도의 지시자나 요청이 없는 이상 해당 데이터를 최대한 캐싱해서 중복된 요청을 방지한다.

### 정적 렌더링과 동적 렌더링

- 과거 Next.js에는 getStaticProps를 활용해 서버에서 불러오는 데이터가 변경되지 않는 경우 정적으로 페이지를 만들어 제공할 수 있는 기능이 있었다.
- 이 기능을 활용하면 해당 주소로 들어오는 경우 모든 결과물이 동일하기 때문에 CDN에서 캐싱해 기존 서버사이드 렌더링보다 더 빠르게 데이터를 제공할 수 있다는 장점이 있었다.

- next 13에서는 아래와 같이 동작
- 정적 렌더링 : 빌드 타임에 렌더링을 미리 해두고 캐싱해 재사용할 수 있게끔 해뒀다.
- 동적 렌더링 : 서버에 매번 요청이 올 때마다 컴포넌트를 렌더링하도록 변경

- 정적으로 캐싱하지 않는 방법도 존재한다. -> fetch에 옵션 추가

  1. {cache: 'no-cache'} 속성 추가
  2. {next : {revalidate: 0}}

- 이 밖에도 함수 내부에서 Next.js가 제공하는 next/headers나 next/cookie 같은 헤더 정보와 쿠키 정보를 불러오는 함수를 사용하게 된다면 해당 함수는 동적인 연산을 바탕으로 결과를 반환하는 것으로 인식해 `정적 렌더링 대상에서 제외된다.`
- 만약 동적인 주소이지만 특정 주소에 대해서 캐싱하고 싶은 경우 -> generateStaticParams 사용

- fetch 옵션 정리
  - fetch(URL, { cache: 'force-cache' }): `기본값`으로 getStaticProps와 유사하게 `불러온 데이터를 캐싱해 해당 데이터로만 관리한다.`
  - fetch(URL, { cache: 'no-store' }), fetch(URL, { next: { revalidate: 0 }}): getServerSideProps와 유사하게 `캐싱하지 않고 매번 새로운 데이터를 불러온다.`
  - fetch(URL, { next: { revalidate: 10 }}): getStaticProps에 revalidate를 추가한 것과 동일하며, `정해진 유효시간 동안에는 캐싱하지 않고, 이 유효시간이 지나면 캐시를 파기한다.`

### 캐시와 mutation, 그리고 revalidating

- Next.js는 fetch의 기본 작동을 재정의해 { next: { revalidate?: number | false }}를 제공하는데, 이를 바탕으로 해당 데이터의 유효한 시간을 정해두고 이 시간이 지나면 다시 데이터를 불러와서 페이지를 렌더링 하는것이 가능하다.
- 만약 루트에 revalidate=60을 선언해두면, 하위에 있는 모든 라우팅에서는 페이지를 60초 간격으로 갱신해 새로 렌더링하게 된다. 그리고 앞선 예제처럼 fetch 내부에 옵션으로 제공하는 것도 가능하다

  1. 최초로 해당 라우트로 요청이 올 때는 미리 정적으로 캐시해 둔 데이터를 보여준다.
  2. 이 캐시된 초기 요청은 revalidate에 선언된 값만큼 유지된다.
  3. 만약 해당 시간이 지나도 일단은 캐시된 데이터를 보여준다.
  4. Next.js는 캐시된 데이터를 보여주는 한편, 시간이 경과했으므로 백그라운드에서 다시 데이터를 불러온다.
  5. 4번의 작업이 성공적으로 끝나면 캐시된 데이터를 갱신하고, 그렇지 않다면 과거 데이터를 보여준다.

- 캐시를 전체적으로 무효화하고 싶다면 router에 추가된 refresh 메서드로 router.refresh()를 하면 된다.
- 이는 브라우저를 새로고침하는 등 브라우저의 히스토리에 영향을 미치지 않고, 오로지 서버에서 루트부터 데이터를 전체적으로 가져와서 갱신하게 된다

### 스트리밍을 활용한 점진적인 페이지 불러오기

- 과거 서버사이드 렌더링 방식

  - 요청받은 페이지를 모두 렌더링해서 내려줄 때까지 사용자에게 아무것도 보여줄 수 없다. -> 사용자는 빈 페이지만 봄 -> 실제로 페이지를 다 받아도 인터랙션 x -> 하이드레이션 후 사용 가능
  - 모든 작업이 순차적으로 다 완료돼야만 온전하게 볼 수 있다

- 위 문제 해결 방법
  - HTML을 작은 단위로 쪼개서 완성되는 대로 클라이언트로 점진적으로 보내는 스트리밍 도입 -> 모든 데이터가 로드될 떄까지 기다리지 않더라도 먼저 데이터가 로드되는 컴포넌트를 빠르게 보여줄 수 있다.
  - 스트리밍 사용 방법
    1. 경로에 loading.tsx 배치
    2. Suspense 배치 : 좀 더 세분화된 제어 가능
