## React에서의 동등 비교와 shallowEqual의 이해

1. 동등 비교 연산자 `==`, `===`, `Object.is`의 차이점
2. React에서의 상태 관리와 비교의 중요성
3. `shallowEqual`의 개념과 사용 사례

### 동등 비교 연산자 간의 차이점

1. `==` 동등연산자
    1. 타입 변환 수행 
        
        ```jsx
        console.log(1 == '1'); // true
        console.log(null == undefined); // true
        ```
        
2. `===` 일치 연산자
    1. 타입과 값이 모두 같아야 true 
        
        ```jsx
        console.log(1 == '1'); // true
        console.log(null == undefined); // true
        ```
        
3. `Object.is` 
    1. NaN과 undefined와 같이 예외상황에 대해서 개발자의 의도에 부합하게 작용
        
        ```jsx
        console.log(Object.is(NaN, NaN)); // true
        console.log(Object.is(-0, +0));   // false
        ```
        

### React에서의 동등 비교 중요성

1. **state변경**
2. **새로운 props**
3. 부모컴포넌트 리렌더링
4. context 변경
5. …

- 렌더링 성능을 사용자 경험에 영향을 주기 때문에 효율적인 비교를 통해 렌더링을 최소화 시키면서 향상시킬 수 있음

### ShallowEqual의 개념

1. shallowEqual이란? 
    1. 객체의 첫 깊이 수준의 프로퍼티만을 비교하며 동등성을 판단
    2. 중첩된 객체나 배열은 참조 값만 비교 
2. ShallowEqual 동작방식
    1. 프로퍼티 수와 키를 비교
    2. 각 프로퍼티 값이 같은지 비교

```jsx
user = {
	name : "bishoe01",
}
const user = this.state.user;
user.name = "goom"
 
console.log(this.state.user === user);
```

### React ShallowEqual

1. memo
    - 함수형 컴포넌트 불필요 렌더링 방지
    - props를 shallow comparison하여 결정
    
    ```jsx
    const MyComponent = React.memo(function MyComponent(props) {
    /내용/
    });
    ```
    
2. PureComponent
    - `React.PureComponent`는 `shouldComponentUpdate`에서 props와 state를 shallow comparison
        
        ```jsx
        class MyComponent extends React.PureComponent {
          render() {
        /내용/
          }}
        ```
        
3. shouldComponentUpdate 직접사용
    - 커스텀 비교 로직을 작성하여 재렌더링 여부 제어
    
    ```jsx
    import shallowEqual from 'shallowequal';
    
    class MyComponent extends React.Component {
      shouldComponentUpdate(nextProps, nextState) {
        return !shallowEqual(this.props, nextProps) || !shallowEqual(this.state, nextState);
      }
      render() {
    /내용/
      }
    }
    ```
- useEffect, useCallback,useMemo의 의존성 배열에는 어떠한 로직이 실행될까?
- 예시코드 
```jsx
import React, { useEffect, useState } from 'react';

function App() {
  const [user, setUser] = useState({ name: 'Alice' });

  useEffect(() => {
    console.log('Effect 실행: 사용자 정보가 변경되었습니다.');
  }, [user]);

  const changeUserName = () => {
    // 잘못된 방식: 기존 객체의 프로퍼티를 직접 변경
    user.name = 'Bob';
    setUser(user);
  };

  return (
    <div>
      <p>{user.name}</p>
      <button onClick={changeUserName}>Change User Name</button>
    </div>
  );
}

export default App;
```

- 버튼을 클릭하면 changeUserName 함수가 호출되어 user.name을 변경하고 상태를 업데이트합니다.
- 그러나 useEffect는 실행되지 않습니다.
- 이유:
    - user 객체의 참조가 변경되지 않았기 때문에 Object.is 비교에서 동일하다고 판단합니다.
- 결과:
    - 사용자 이름은 변경되지만, useEffect는 실행되지 않습니다.
#### 모범예시
```jsx
const changeUserName = () => {
  // 올바른 방식: 새로운 객체를 생성하여 상태 업데이트
  setUser({ ...user, name: 'Bob' });
};
```


#### 예시2
```jsx
import React, { useEffect, useState, useMemo } from 'react';

function App() {
  const [numbers, setNumbers] = useState([1, 2, 3]);

  const total = useMemo(() => {
    console.log('합계를 계산합니다.');
    return numbers.reduce((a, b) => a + b, 0);
  }, [numbers]);

  const addNumber = () => {
    // 잘못된 방식: 기존 배열에 새로운 요소를 직접 추가
    numbers.push(numbers.length + 1);
    setNumbers(numbers);
  };

  return (
    <div>
      <p>Total: {total}</p>
      <button onClick={addNumber}>Add Number</button>
    </div>
  );
}

export default App;
```
#### 모범예시
```jsx
const addNumber = () => {
  // 올바른 방식: 새로운 배열을 생성하여 상태 업데이트
  setNumbers([...numbers, numbers.length + 1]);
};
```
- lodash의 isEqual 메서드와 비교
    - Lodash의 isEqual 소개
        - _.isEqual은 Lodash 라이브러리에서 제공하는 깊은 비교 함수입니다.
    - 객체나 배열의 모든 수준의 프로퍼티를 재귀적으로 비교하여 동등성을 판단합니다.

```jsx
import { isEqual } from 'lodash';

const obj1 = { a: 1, b: { c: 2 } };
const obj2 = { a: 1, b: { c: 2 } };

console.log(obj1 === obj2);         // false (참조 비교)
console.log(_.isEqual(obj1, obj2)); // true  (값 비교)
```
- 예시코드



### Shallow Equal vs Shallow Comparison

1. Shallow Equal
    - 객체의 최상위 프로퍼티들의 값을 비교
    - Object.is()를 사용하여 각 프로퍼티 비교
    ```jsx
    const obj1 = { a: 1, b: { x: 1 } };
    const obj2 = { a: 1, b: { x: 1 } };
    // shallowEqual(obj1, obj2) === false
    // b 프로퍼티의 참조값이 다르기 때문
    ```

2. Shallow Comparison
    - 단순 참조 비교 (===)
    - 메모리 주소만 비교
    ```jsx
    const obj1 = { a: 1 };
    const obj2 = { a: 1 };
    console.log(obj1 === obj2); // false
    ```

3. 주요 차이점
    - Shallow Equal: 객체의 첫 번째 레벨 프로퍼티들의 값을 실제로 비교
    - Shallow Comparison: 단순히 참조 주소만 비교
    - React에서는 주로 Shallow Equal을 사용하여 불필요한 리렌더링 방지
