## React Hooks
React Hooks는 함수형 컴포넌트에서 상태 관리와 생명주기 기능을 사용할 수 있게 해주는 기능
클래스형 컴포넌트에서만 사용할 수 있었던 state와 생명주기 메서드를 함수형 컴포넌트에서도 사용가능

주요 특징:
- 재사용 가능한 로직을 쉽게 만들 수 있음
- 복잡한 컴포넌트를 쉽게 이해할 수 있음
- 클래스 컴포넌트의 this 바인딩 문제 해결
- 관련 로직을 한곳에서 관리할 수 있음

---

## useState
- 상태를 정의하고 관리하는 훅 
```jsx
import { useState } from 'react';
const [state, setState] = useState(초기값);
```
- 안썼을 때의 코드
```jsx
function Component() {
    const [_,triggerRender] = useState();
    let state = 'hello';
    function handleClick() {
        state = 'world';
        triggerRender();
    }
    return <div onClick={handleClick}>{state}</div>;
}
```
이렇게해도 상태는 변경되지만 리렌더링이 일어나지 않는다. 
-> 매번 렌더링이 발생될 때 마다 초기화되기 때문
### ❓그러면 어떻게 useState는 상태를 머금고 있을 수 있나❓
- 정답은 클로저! 
> 클로저는 함수가 자신이 선언된 범위 밖에서 호출될 때 그 함수가 선언된 범위의 변수들을 참조할 수 있는 기능

### 게으른 초기화
- useState의 초기값으로 복잡한 계산이 필요할 때 사용
- 컴포넌트가 처음 렌더링될 때만 실행되고, 리렌더링시에는 실행되지 않음
```jsx
// 일반적인 초기화 - 매 렌더링마다 계산
const [members, setMembers] = useState(Array(1000).fill().map((_, i) => ({ id: i })));
// 게으른 초기화 - 첫 렌더링에만 계산 (처음 만들어질 때만 사용)
const [members, setMembers] = useState(() => {
    console.log('초기화는 한 번만 실행됩니다');
    return Array(1000).fill().map((_, i) => ({ id: i }));
});
```
- 무거운 연산을 하는 경우 초기값으로 함수를 전달하여 초기화 시점을 조절할 수 있음 (ex. 네트워크 요청, 비동기 연산)
- 기존에는 빈값으로 생성을 한 후 useEffect에서 값을 초기화해줬는데, 게으른 초기화를 사용하면 초기값으로 함수를 전달하여 초기화 시점을 조절할 수 있음

---

## useEffect
- 컴포넌트의 여러 값들을 활용해 동기적으로 부수 효과를 만드는 메커니즘
- `언제` 일어나는지보다 어떤 상태값과 함께 실행되는지 살펴보는 것이 중요하다.

### ❓어떻게 의존성 배열이 변경되었는지 알고 콜백함수를 실행할 수 있을까❓
- 함수형 컴포넌트는 매번 함수를 실행해 렌더링을 수행한다는 점을 기억
- 렌더링 할 때마다 의존성에 있는 값을 보면서 콜백함수를 실행할지 결정하는 부수 효과 함수 

### 클린업 함수의 목적
- 콜백이 실행되기 전에 이전 콜백이 실행되는 것을 방지하기 위해 사용
- 언마운트와 클린업의 차이
    - 언마운트: 컴포넌트가 사라질 때
    - 클린업: 컴포넌트가 사라지기 전에 실행되는 함수
- 클린업은 이전 렌더링의 useEffect에서 설정된 값이나 구독을 정리하는 용도로 사용됨
- 새로운 값으로 useEffect가 실행되기 전에 이전 값에 대한 정리가 필요할 때 사용

### 의존성 배열
- 빈배열을 두면 처음 렌더링될때만 실행
- 배열자체를 두지 않으면 렌더링 될 때마다 실행
### ❓그렇다면 배열 안쓸거면 왜 useEffect를 쓰는걸까❓
- 의존성 배열을 사용하면 콜백함수가 실행되는 시점을 정확하게 제어할 수 있음 ( window 객체도 활용이 가능)
- 컴포넌트의 렌더링이 완료된 이후에 실행되기 때문에 클라이언트 사이드 이벤트 처리에 유용

### 주의사항
- 빈배열은 웬만하면 쓰지 않는게 좋음
- useEffect는 의존성 배열로 전달한 값의 변경에 의해 실행되어야하는 훅이기 때문 
- 특정 값을 사용하지만 해당 값의 변경 시점을 피할 목적이라면 메모이제이션을 적절히 활용해 해당값의 변화를 막거나 적당한 실행 위치를 고민해보는 것이 좋다 
- useEffect는 너무 크지 않게 유지하면서 useMemo,useCallback으로 정제된 친구들을 사용하는 것이 좋다 

### useEffect 첫번째 인수에 함수명을 부여 
- 함수명을 부여하면 함수 내부에서 콜백함수를 쉽게 찾을 수 있음
```jsx
useEffect(() => {
    logging(user.id);
}, [user.id]);

useEffect(
    function logActiveUser(){
        logging(user.id);
    },[],
);
```

---

### useContext
