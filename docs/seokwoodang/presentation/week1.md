# 리액트의 핵심요소 깊게 살펴보기
## 2.1 JSX란?
JSX는 페이스북에서 독자적으로 만든 새로운 문법  
따라서 JSX가 포함된 코드를 아무 처리없이 실행하면 에러가 발생한다.  
따라서 트랜스파일러를 거쳐야 자바스크립트 런타임이 이해할 수 있는 의미있는 자바스크립트 코드로 변환된다.

#### 설계 목적
> 다양한 트랜스파일러에서 다양한 속성을 가진 트리 구조를 토큰화하여 자바스크립트가 이해할 수 있는 코드로 변환하는 것.  
따라서 단순히 HTML , XML을 넘어 다른 구문으로도 확장 될 수 있게끔 설계되어있다.

#### 구성 요소
> JSXElement, JSXAttributes, JSXChildren, JSXStrings 


### JSXElement
> JSX의 가장 기본 요소로 HTML의 요소와 비슷한 역할을 한다.
```
<> // Fragment
  <div> // OpeningElement
	  <img/> // SelfClosingElement
  </div>// ClosingElement
</>
```

리액트의 컴포넌트는 반드시 대문자로 시작되어야 하는데 이는 HTML태그면과 사용자가 만든 컴포넌트 명을 구분 짓기 위해 있는 규칙이다.

#### JSXElementName
> element의 요소 이름으로 쓸 수 있는 것들.
- JSXIdentifier : JSX 내부에서 사용할 수 있는 식별자 규칙을 의미한다.
	- $, _ 가 가능하지만 숫자로 시작하거나 다른 특수문자로는 시작 불가능.
	- [자바스크립트 식별자 규칙](https://sunghyuk0108.github.io/javascript/javascript-nameing/)
- JSXNamespacedName 
	- <foo:bar> 와 같이 식별자를 연결 시켜주는 것.
	- 하지만 React에서는 해당 NameSpacedName을 지원하지 않는다고 한다.
	- ![image](https://github.com/user-attachments/assets/e014af6d-7f89-4bc8-bef9-955be90b4167)
- JSXMemberExpression
	- JSXIdentifier.JSXIdentifier 조합
```
const MyComponents = { 
	Header: function Header() { 
		return <h1>Header</h1>; 
	}, 
	Footer: function Footer() { 
		return <h1>Footer</h1>; 
	} 
}; 

<MyComponents.Header /> 
<MyComponents.Footer />
```


### JSXAttributes
JSXElement에 부여할 수 있는 속성을 의미한다. 단순히 속성이므로 필수가 아니다.
한번 읽어보고 넘어가자.
### JSXChildren
JSXElement의 자식 값을 나타낸다. JSX는 트리구조를 갖고 있기 때문에 부모 자식 관계를 나타낼 수 있다.
- JSXText : <,>,},{ 을 제외한 문자열. 앞의 문자들은 다른 JSX문법과 혼동을 줄 수 있기 때문에 제외되었다.
- JSXElement : 값으로 다른 JSX요소가 들어갈 수 있다.
- JSXFragment : 값으로 빈 JSX 요소인 <></>가 들어갈 수 있다.
- {JSXChildExpression} : 내부적으로 함수값 같은걸 의미한다.

## 가상 DOM과 리액트 파이버


### DOM과 브라우저 렌더링 과정
1. 브라우저가 주소에 방문해 HTML 파일을 다운로드 한다.
2. 브라우저의 렌더링 엔진은 HTML을 파싱해 DOM 노드로 구성된 트리를 만든다.
3. CSS파일도 다운받아 CSSOM 트리를 만든다.
4. 브라우저는 위에서 만든 DOM노드를 빠르게 방문하는데 display : none과 같은 친구는 제외하고 분석한다.
5. 분석한 친구들을 대상으로 해당 노드에 대한 CSSOM정보를 찾고 CSS 스타일 정보를 이 노드에 적용한다.   
이 과정은 아래 두 가지로 나눌 수 있다.  
	1. 레이아웃 : 각 노드가 브라우저 화면의 어느 좌표에 나타나야 하는지 계산하는 과정. 이 과정을 거치면 반드시 페인팅 과정도 거치게 된다.
	2. 페인팅 : 레이아웃 단계를 거친 노드에 색과 같은 실제 유효한 모습을 그리는 과정.
   3. _[레이아웃과 페인팅 css속성 ](https://www.lmame-geek.com/css-triggers/)_

### 가상 DOM의 탄생 배경
근래의 사이트들은 인터랙션을 통해 렌더링이 많이 일어나는 작업들을 다룬다.   
이는 수 많은 리렌더링 작업을 해주기에는 리소스가 너무 많이 들어가게 된다. => 가상 DOM 개념  

#### 가상DOM이란? 
> 웹 페이지가 표시해야 할 DOM을 메모리에 저장하고 리액트가 실제 변경에 대한 준비가 완료되었을 때 실제 브라우저의 DOM에 반영하는 방식.

_듣기에는 좋아보이지만 가상 DOM이 무조건 빠르다는 생각은 오해이다._
  
  
  
#### 리액트 파이버
> 리액트 파이버는 리액트에서 관리하는 자바스크립트 객체.
> 파이버는 파이버 재조정자에 의해 관리됨.  
> 가상DOM과 실제 DOM을 비교해 변경 사항을 수집 후 둘 사이에 차이가 있으면 변경에 관련된 정보를 갖고있는 파이버를 기준으로 화면에 렌더링을 요청.

##### 리액트 파이버의 목적
> 웹에서 발생하는 애니메이션 레이아웃, 인터랙션 등 올바른 결과를 반드는 반응성 문제를 해결하는 것.

##### 리액트 파이버의 능력
1. 작업을 작은 단위로 쪼개고 우선순위를 매긴다.
2. 작업의 우선순위를 처리할 수 있다.
3. 이전의 작업을 다시 하거나 폐기할 수 있다.
   위의 모든 작업은 비동기로 일어나게 된다. 따라서 파이버는 하나의 작업단위로 구성되어있다.

렌더 단계에서 리액트는 사용자에게 노출되지 않는 모든 비동기 작업을 수행한다.  
파이버는 객체로 이루어져 있으며 하나의 element에 하나가 생성되는 1:1의 관계를 갖고 있다.   
생성된 파이버들은 state가 변경되거나 생명주기 메서드가 실행되거나 DOM의 변경이 필요한 시점 등에 실행된다.  
리액트는 파이버를 처리할 때마다 이런 작업을 바로 또는 스케줄링하기도 한다.  
이는 우선순위가 높은 작업은 가능한 빠르게 처리하거나 , 낮은 작업을 연기시키는 등의 유연한 처리를 가능하게 한다.  

#### 파이버 트리 
> 파이버 트리는 두개가 존재  
현재 모습을 담은 파이버트리, 작업 중인 상태의 workInProgress 트리.  
리액트의 파이버 작업이 끝나면 리액트는 포인터를 변경해 workInProgress 트리를 현재 트리로 변경해버린다.  
이를 ```더블 버퍼링```이라고 한다.


#### 파이버의 작업순서
1. 리액트는 beginWork() 함수를 실행해 파이버 작업을 수행하는데 더 이상 자식이 없는 파이버를 만날 때까지 트리 형식으로 시작.
2. 1번 작업이 끝나면 completeWork() 함수를 실행해 파이버 작업을 완료.
3. 형제가 있다면 형제로 이동.
4. 2,3번이 끝나면 return.
```
<A1>
	<B1>안녕하세요</B1>
	<B2>
		<C1>
			<D1/>
			<D2/>
		</C1>
	</B2>
	<B3/>
</A1>
```
위의 과정을 통해 트리를 생성.  
setState등의 업데이트를 기반으로 새로운 workInProgress트리를 생성.  
하지만 기존에 만들어놓은 트리가 있으므로 업데이트 된 props를 받아 파이버 내부에서 처리.  

_과거에 동기적으로 리액트가 처리했던 이 파이버를 업데이트 하는 과정을, 현재는 우선순위가 높은 다른 업데이트가 오면 현재 업데이트를 일시 중단하거나 새롭게 만들거나 폐기할 수 있다._


### 파이버와 가상DOM

#### 가상DOM을 사용하는 이유
리액트 컴포넌트의 정보를 1:1로 갖고 있는 것이 파이버, 리액트 아키텍처 내부에서 비동기로 이뤄진다. 
실제 브라우저 구조인 DOM에 반영하는 것은 _동기적_으로 일어나기 때문에 여러작업을 메모리 상에서 먼저 수행해 최종 결과물만 실제 브라우저 DOM에 적용.

```
가상DOM의 핵심은 브라우저의 DOM을 더욱 빠르게 반영하는 것이 아닌 값으로 UI를 표현하는 것이다.
값으로 UI를 표현하여 흐름을 효율적으로 관리하기 위한 매커니즘이 리액트의 핵심이다.
```


## 클래스 컴포넌트와 함수 컴포넌트

### 클래스 컴포넌트

#### 자주 사용되는 개념 정리
constructor
- state를 초기화.
- super() 함수를 통해 상위 컴포넌트에서 prop을 전달받음.

props : 컴포넌트에 특정 속성을 전달하는 용도.   
state : 클래스 컴포넌트 내부에서 관리하는 값. 항상 객체여야하며 변화가 있을 때마다 리렌더링.   
메서드 : 렌더링 함수 내부에서 사용되는 함수이며 DOM의 이벤트와 함께 사용.   

#### 생명주기 메서드

마운트 : 컴포넌트의 마운팅 시점
- render()
	- 컴포넌트가 UI를 렌더링하기 위해 사용.
	- 항상 순수해야하며 부수효과 없어야함. ( state의 변경이 없어야 한다. )
	- 최대한 간결하고 깔끔하게 작성.
- componentDidMount()
	- 컴포넌트가 마운트되고 준비되는 즉시 실행.
	- state 변경이 가능.   ( 해당 작업은 브라우저가 실제로 UI를 업데이트 하기 전에 실행되어 사용자가 변경되는 것을 눈치챌 수 없게 만든다. )
	- 성능에 문제를 일으킬 수 있으므로 확인하고 사용하자.

업데이트 : 이미 생성된 컴포넌트의 내용이 변경되는 시점
 - componentDidUpdate()
	- 컴포넌트 업데이트가 일어난 이후 바로 실행.
	- state나 props의 변화에 따라 DOM을 업데이트 하는데 사용.
	- 하지만 조건문이 반드시 함께 사용되어야 함.
- shouldComponentUpdate()
	- state나 props의 변경으로 리렌더링되는것을 막을 때 사용됨.

언마운트 : 컴포넌트가 더 이상 존재하지 않는 시점
- componentWillUnmount()
	- 컴포넌트가 언마운트되거나 더 이상 사용되지 않기 직전에 호출된다.
	- 메모리 누수나 불필요한 작동을 막기 위한 클리업 함수를 호출하기 위한 최적의 위치다. ( setTimeout, setInterval 지우기 좋음 )
	- state를 변경할 수 없다.


<img width="1129" alt="image" src="https://github.com/user-attachments/assets/0d94d437-46df-4669-9744-2ca036bec796">


#### 클래스 컴포넌트의 한계
- 데이터의 흐름을 추적하기 어려움.
	- 서로 다른 여러 메서드에서 state의 업데이트가 일어날 수 있음.
	- 메서드의 순서가 강제 되어있지 않아 판단하기 어려움.
- 내부 로직의 재사용이 어려움.
	- 재사용하고 싶은 로직이 있다면 계속 고차 컴포넌트로 감싸줘야하는데 래퍼지옥에 빠지게 됨.
- 기능이 많아질 수록 컴포넌트의 크기가 커짐.
- 사용이 어려움
	- 자바스크립트 개발자는 클래스보다 함수에 익숙하다.
- 코드의 최적화가 어려움.
	- 사용되지 않는 트리쉐이킹이 되지 않음.
- 핫 리로딩이 불리함.
	- 핫 리로딩은 코드 변경시 재시작하지 않고 코드만 업데이트 해서 변경사항을 빠르게 적용하는 기법.
	- 불리한 이유는 클래스는 최초 렌더링시 instance를 생성하기 때문에 state가 초기화 되어 상태를 잃어버리기 때문.

### 함수 컴포넌트 
#### 생명주기가 존재하지 않는다.
하지만 useEffect 훅을 사용해 위의 생명주기를 비슷하게 구현할 수 있다. ( 똑같지는 않다. )   
useEffect는 state를 활용해 부수효과를 만드는 매커니즘일 뿐이기 때문이다.

#### 렌더링 된 값을 고정한다.
클래스 컴포넌트
- props 가 this.props이므로 생명주기 메서드가 변경된 값을 읽어올 수 있다. 따라서 렌더링 된 값을 고정하지 않는다.
  
함수형 컴포넌드
- 렌더링이 일어나는 순간의 값을 고정하여 렌더링해준다.

_draft, webRTC 공식문서는 class component 기준으로 작성_

## 렌더링은 어떻게 일어나는가?

### 리액트의 렌더링
리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 현재 자신들이 갖고 있는 props와 state 값을 기반으로 UI를 어떻게 구성하고 어떤 DOM의 결과를 브라우저에게 제공할지 계산하는 일련의 과정.

### 리액트의 렌더링 조건
1. 최초 렌더링
2. 리렌더링
	1. 클래스 컴포넌트의 상태가 변화
	2. 클래스 컴포넌트의 forceUpdate 실행
	3. 함수 컴포넌트의 useState()의 두번째 요소 setter가 실행되는 경우
	4. 함수 컴포넌트의 useReducer()의 두번째 요소 dispatch가 실행되는 경우
	5. 컴포넌트의 key props가 변경되는 경우
		1. 리액트에서 key는 형제 요소들 사이에서 동일한 요소를 식별하는 값.   
리렌더링이 일어날 시에 리액트 파이버에서 current 트리와 workInProgress 트리 사이에서 어떤 컴포넌트의 변경이 있었는지 구별해야 하는데 이 두 컴포넌트 사이에서 구별하는 값이 바로 key.
	6. props가 변경되는 경우
	7. 부모 컴포넌트가 렌더링될 경우

### 리액트의 렌더링 프로세스
1. 렌더링 프로세스가 시작되면 리액트는 컴포넌트의 루트에서부터 차근차근 아래쪽으로 내려가면서 업데이트가 필요하다고 되어있는 모든 컴포넌트를 찾는다.
2. 발견 시 클래스 컴포넌트는 render()함수를 실행하고 함수 컴포넌트는 FunctionComponent()를 호출한다.
3. 렌더링 결과물은 jsx문법으로 되어있으며 이것을 자바스크립트로 컴파일해 React.createElement()를 호출하는 구문으로 변환한다. => UI구조를 자바스크립트 객체로 변환한다.
4. 결과물을 도출한 뒤에 새로운 트리인 가상 DOM과 비교해 실제 DOM에 반영하기 위한 모든 변경사항을 차례차례 수집한다.


### 렌더와 커밋
> 리액트의 렌더링은 렌더단계와 커밋단계라는 총 두단계로 분리되어 있다.

![image](https://github.com/user-attachments/assets/0054799d-d992-4271-bea7-651e9f9c1cb9)

#### 렌더
컴포넌트를 렌더링하고 변경사항을 계산하는 모든 작업으로 렌더링 프로세스에서 컴포넌트를 실행해 결과와 이전 가상 DOM을 비교하는 과정을 거쳐 변경이 필요한 컴포넌트를 체크하는 단계.   
여기서 비교하는 세가지는 ```type, props, key```.   
이중 하나라도 변경되면 업데이트가 필요한 컴포넌트로 표시.
#### 커밋
렌더 단계의 변경사항을 실제 DOM에 적용해 사용자에게 보여주는 과정으로 이 단계가 끝나야 브라우저의 렌더링이 발생.
1. DOM 업데이트
2. 모든 DOM노드 및 인스턴스를 가리키도록 리액트 내부의 참조 업데이트
3. 메서드 호출
	1. 클래스 컴포넌트의 경우 componentDidMount, componentDidUpdate 호출
	2. 함수 컴포넌트의 경우 useLayoutEffect 호출

*리액트의 랜더링이 일어난다고 무조건 DOM 업데이트가 일어나는 것은 아니다.*
따라서 커밋단계가 생략될 수 있다.



## 메모이제이션 
### 섣부른 최적화는 독이다 vs 전부 처리하자
독이다
- 메모이제이션에도 비용이 든다.
  
전부 처리하자
- 얕은 비교라 얼마 비용이 안든다.
- 하지 않았을때의 잠재 위험 비용이 더 비싸다.

### 책의 저자 왈  
당신이 초보라구요? 웬만하면 다 처리하세요.   
시간이 많고 고수라구요? 적절한 곳을 알테니 거기만 처리하세요   
