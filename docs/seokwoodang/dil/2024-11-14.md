### useReducer
> useState의 심화버전으로 사전에 정의된 dispatcher로만 state를 수정할 수 있게 만들어준 훅이다.
> state 업데이트를 미리 정의해둔 dispatcher로만 제한하는 것. == 시나리오를 제한적으로 두고 변경을 빠르게 확인한다.

#### 반환값
- state
  - useReducer가 가지고 있는 값을 의미한다.
  - useState처럼 배열을 반환하며 동일하게 첫번째 요소가 이 값이다.
- dispatcher
  - state를 업데이트 하는 함수.
  - setState는 값을, dispatcher는 action을 넘겨준다.   
 
#### 인수
- reducer
  - 기본 action을 정의하는 함수.
- initialState
  - useReducer의 초깃값.
- init
  - 게으른 초기화를 위한 함수이다. ( 이 값이 존재하면 initialState를 인수로 init함수 실행 )

```
const memoizedValue = useMemo(()=>expensiveComputation(a,b),[a,b])  
```

<br/>
<br/>
<br/>

### useImperativeHandle
> 부모에게서 넘겨받은 ref를 원하는 대로 수정할 수 있는 훅.   
> ref 자체에만 액세스해야 하는 경우에는 굳이 useImperativeHandle 훅을 사용할 필요가 없다.  
> 해당 훅은 ref를 통해 하위 구성 요소의 특정 메서드나 속성에 액세스할 때 사용되곤 하는데 이또한 리액트가 지향하는 바에 따르면   
> 사용하지 않는 것이 좋다. props로 처리가 가능하다면 props와 state로 처리해주자.   
> forwardRef 또한 props로 ref를 내려줄 때 네이밍을 ref로 하지 않으면 사용하지 않아도 된다.
<br/>
<br/>
<br/>


### useLayoutEffect
> useEffect와 동일하나, 모든 DOM의 변경 후에 동기적으로 발생한다.
> 여기서 DOM의 변경은 렌더링을 의미한다. => 브라우저에 실제로 해당 변경 사항이 반영되는 시점이 아님.

#### 실행순서
1. 리액트가 DOM 업데이트
2. useLayoutEffect 실행
3. 브라우저에 변경 사항을 반영
4. useEffect를 실행

브라우저에 반영되기 전에 작업이 되기 때문에 사용자 경험을 늘릴 수 있지만   
useLayoutEffect가 계산이 된 후에야 브라우저에 변경사항이 반영되기 때문에 꼭 필요한 작업이 아니면 넣지 않도록 주의하자.  

<br/>
<br/>
<br/>

### 훅의 규칙
1. 최상위에서만 훅을 호출해야 한다. 반복문, 조건문, 중첩함수 내에서 훅 실행 불가.   
   이는 컴포넌트 렌더링시 항상 동일한 순서로 훅이 호출되는 것을 보장하기 위함이다.
2. 훅을 호출할 수 있는 것은 리액트 함수 컴포넌트 혹은 사용자 정의 훅의 두 가지 경우 뿐이다.   
   자바스크립트 함수 내에서는 훅 사용 불가.
   
  
<br/>
<br/>
<br/>
<br/>

## 사용자 정의 훅과 고차 컴포넌트 중 무엇을 써야 할까?
### 사용자 정의 훅
> 리액트에서만 사용할 수 있는 기법으로 이름을 반드시 use로 시작한다는 규칙이 있다.
> 내부적으로 리액트에서 사용하는 훅을 쓸 수 있으며 훅의 규칙또한 따라야 한다.

### 고차 컴포넌트
> 컴포넌트 자체의 로직을 재사용하기 위한 방법으로 고차함수의 일종이기 때문에 리액트가 아니더라도 자바스크립트 환경에서 널리 쓰일 수 있다.

#### 주의할 점
- 이름을 작성할 때 with를 써줘야 한다. ( 강제 아님 )
- 부수 효과를 최소화 해야한다. ( 인수로 받은 컴포넌트를 수정, 추가, 삭제하지 않아야 한다. )


### 사용자 정의 훅 vs 고차 컴포넌트
#### 사용자 정의 훅이 필요한 경우
- 리액트에서 제공하는 훅으로만 공통 로직을 격리할 수 있을 때.


#### 고차 컴포넌트를 사용해야 하는 경우
- 함수 컴포넌트의 반환값, 렌더링 결과물에도 영향을 미치는 공통 로직이라면 고차 컴포넌트를 사용하자.






