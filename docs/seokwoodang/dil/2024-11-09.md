## 클래스 컴포넌트와 함수 컴포넌트

### 클래스 컴포넌트

#### 자주 사용되는 개념 정리
constructor
- state를 초기화 한다.
- super() 함수를 통해 상위 컴포넌트에서 prop을 전달받을 수 있게 해준다.

props : 컴포넌트에 특정 속성을 전달하는 용도로 쓰인다.
state : 클래스 컴포넌트 내부에서 관리하는 값을 의미한다. 이 값은 항상 객체여야하며 변화가 있을 때마다 리렌더링 된다.
메서드 : 렌더링 함수 내부에서 사용되는 함수이며 DOM의 이벤트와 함께 사용된다.

#### 생명주기 메서드

마운트 : 컴포넌트의 마운팅 시점
- render()
	- 컴포넌트가 UI를 렌더링하기 위해 쓰인다.
	- 항상 순수해야하며 부수효과가 없어야 한다. ( state의 변경이 없어야 한다. )
	- 따라서 최대한 간결하고 깔끔하게 작성해야한다.
- componentDidMount()
	- 컴포넌트가 마운트되고 준비되는 즉시 실행된다.
	- state 변경이 가능하다. ( 해당 작업은 브라우저가 실제로 UI를 업데이트 하기 전에 실행되어 사용자가 변경되는 것을 눈치챌 수 없게 만든다. )
	- 하지만 성능에 문제를 일으킬 수 있으므로 확인하고 사용하자.

업데이트 : 이미 생성된 컴포넌트의 내용이 변경되는 시점
 - componentDidUpdate()
	- 컴포넌트 업데이트가 일어난 이후 바로 실행된다.
	- state나 props의 변화에 따라 DOM을 업데이트 하는데 사용된다.
	- 하지만 조건문이 반드시 함께 사용되어야 한다.
- shouldComponentUpdate()
	- state나 props의 변경으로 리렌더링되는것을 막을 때 사용됨.

언마운트 : 컴포넌트가 더 이상 존재하지 않는 시점
- componentWillUnmount()
	- 컴포넌트가 언마운트되거나 더 이상 사용되지 않기 직전에 호출된다.
	- 메모리 누수나 불필요한 작동을 막기 위한 클리업 함수를 호출하기 위한 최적의 위치다. ( setTimeout, setInterval 지우기 좋음 )
	- state를 변경할 수 없다.


<img width="1129" alt="image" src="https://github.com/user-attachments/assets/0d94d437-46df-4669-9744-2ca036bec796">


#### 클래스 컴포넌트의 한계
- 데이터의 흐름을 추적하기 어렵다.
	- 서로 다른 여러 메서드에서 state의 업데이트가 일어날 수 있음.
	- 메서드의 순서가 강제 되어있지 않아 판단하기 어려움.
- 내부 로직의 재사용이 어려움.
	- 재사용하고 싶은 로직이 있다면 계속 고차 컴포넌트로 감싸줘야하는데 래퍼지옥에 빠지게 됨.
- 기능이 많아질 수록 컴포넌트의 크기가 커짐.
- 어려움
	- 자바스크립트 개발자는 클래스보다 함수에 익숙하다.
- 코드의 최적화가 어렵다.
	- 사용되지 않는 트리쉐이킹이 되지 않는다.
- 핫 리로딩이 불리하다.
	- 핫 리로딩은 코드 변경시 재시작하지 않고 코드만 업데이트 해서 변경사항을 빠르게 적용하는 기법.
	- 불리한 이유는 클래스는 최초 렌더링시 instance를 생성하기 때문에 state가 초기화 되어 상태를 잃어버리기 때문이다.

### 함수 컴포넌트 
#### 생명주기가 존재하지 않는다.
하지만 useEffect 훅을 사용해 위의 생명주기를 비슷하게 구현할 수 있다. ( 똑같지는 않다. )
useEffect는 state를 활용해 부수효과를 만드는 매커니즘일 뿐이기 때문이다.
#### 렌더링 된 값을 고정한다.
클래스 컴포넌트
- props 가 this.props이므로 생명주기 메서드가 변경된 값을 읽어올 수 있다. 따라서 렌더링 된 값을 고정하지 않는다.
함수형 컴포넌드
- 렌더링이 일어나는 순간의 값을 고정하여 렌더링해준다.

draft, webRTC 공식문서는 class component 기준으로 작성

## 렌더링은 어떻게 일어나는가?

### 리액트의 렌더링
리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 현재 자신들이 갖고 있는 props와 state 값을 기반으로 UI를 어떻게 구성하고 어떤 DOM의 결과를 브라우저에게 제공할지 계산하는 일련의 과정.

### 리액트의 렌더링 조건
1. 최초 렌더링
2. 리렌더링
	1. 클래스 컴포넌트의 상태가 변화
	2. 클래스 컴포넌트의 forceUpdate 실행
	3. 함수 컴포넌트의 useState()의 두번째 요소 setter가 실행되는 경우
	4. 함수 컴포넌트의 useReducer()의 두번째 요소 dispatch가 실행되는 경우
	5. 컴포넌트의 key props가 변경되는 경우
		1. 리액트에서 key는 형제 요소들 사이에서 동일한 요소를 식별하는 값이다. 리렌더링이 일어날 시에 리액트 파이버에서 current 트리와 workInProgress 트리 사이에서 어떤 컴포넌트의 변경이 있었는지 구별해야 하는데 이 두 컴포넌트 사이에서 구별하는 값이 바로 key이다.
	6. props가 변경되는 경우
	7. 부모 컴포넌트가 렌더링될 경우

### 리액트의 렌더링 프로세스
1. 렌더링 프로세스가 시작되면 리액트는 컴포넌트의 루트에서부터 차근차근 아래쪽으로 내려가면서 업데이트가 필요하다고 되어있는 모든 컴포넌트를 찾는다.
2. 발견 시 클래스 컴포넌트는 render()함수를 실행하고 함수 컴포넌트는 FunctionComponent()를 호출한다.
3. 렌더링 결과물은 jsx문법으로 되어있으며 이것을 자바스크립트로 컴파일해 React.createElement()를 호출하는 구문으로 변환한다. => UI구조를 자바스크립트 객체로 변환한다.
4. 결과물을 도출한 뒤에 새로운 트리인 가상 DOM과 비교해 실제 DOM에 반영하기 위한 모든 변경사항을 차례차례 수집한다.
### 렌더와 커밋
리액트의 렌더링은 렌더단계와 커밋단계라는 총 두단계로 분리되어 있다.
#### 렌더
컴포넌트를 렌더링하고 변경사항을 계산하는 모든 작업으로 렌더링 프로세스에서 컴포넌트를 실행해 결과와 이전 가상 DOM을 비교하는 과정을 거쳐 변경이 필요한 컴포넌트를 체크하는 단계이다.
여기서 비교하는 세가지는 type, props, key이다. 이중 하나라도 변경되면 업데이트가 필요한 컴포넌트로 표시.
#### 커밋
렌더 단계의 변경사항을 실제 DOM에 적용해 사용자에게 보여주는 과정으로 이 단계가 끝나야 브라우저의 렌더링이 발생한다.
1. DOM 업데이트
2. 모든 DOM노드 및 인스턴스를 가리키도록 리액트 내부의 참조 업데이트
3. 메서드 호출
	1. 클래스 컴포넌트의 경우 componentDidMount, componentDidUpdate 호출
	2. 함수 컴포넌트의 경우 useLayoutEffect 호출

*리액트의 랜더링이 일어난다고 무조건 DOM 업데이트가 일어나는 것은 아니다.*
따라서 커밋단계가 생략될 수 있다.



## 메모이제이션 
### 섣부른 최적화는 독이다 vs 전부 처리하자
독이다
- 메모이제이션에도 비용이 든다. 
전부 처리하자
- 얕은 비교라 얼마 비용이 안든다.
- 하지 않았을때의 잠재 위험 비용이 더 비싸다.

책의 저자 왈
당신이 초보라구요? 웬만하면 다 처리하세요.
시간이 많고 고수라구요? 적절한 곳을 알테니 거기만 처리하세요
